{"pubDate": "2025-12-18T18:00:44", "original_title": "Bare Metal STM32: Increasing the System Clock and Running Dhrystone", "link": "https://hackaday.com/2025/12/18/bare-metal-stm32-increasing-the-system-clock-and-running-dhrystone/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/10/stm32_ic_logo.jpg", "original_content": "When you start an STM32 MCU with its default configuration, its CPU will tick along at a leisurely number of cycles on the order of 8 to 16 MHz, using the high-speed internal (HSI) clock source as a safe default to bootstrap from. After this phase, we are free to go wild with the system clock, as well as the various clock sources that are available beyond the HSI.\nIncreasing the system clock doesnt just affect the CPU either, but also affects the MCUs internal buses via its prescalers and with it the peripherals like timers on that bus. Hence its essential to understand the clock fabric of the target MCU. This article will focus on the general case of increasing the system clock on an STM32F103 MCU from the default to the maximum rated clock speed using the relevant registers, taking into account aspects like Flash wait states and the APB and AHB prescalers.\nAlthough the Dhrystone benchmark is rather old-fashioned now, itll be used to demonstrate the difference that a faster CPU makes, as well as how complex accurately benchmarking is. Plus its just interesting to get an idea of how a lowly Cortex-M3 based MCU compares to a once top-of-the line Intel Pentium 90 CPU.\n\nStitching The Clock Fabric\nThe F103s clock tree isnt identical to that of other families of STM32 MCUs, but the basic concepts remain the same. See the below graphic from Reference Manual 0008 for the clock tree of STM32F10x MCUs:\nThe clock tree of the STM32F10x MCUs. (Source: RM0008)\nWe can see the HSI clocked at 8 MHz, which feeds into the clock input switch (SW), from where it can provide the 8 MHz system clock without further fuss. Our other options are to use the HSE, which is fed in via its respective oscillator pins and from there is wired to the same switch as the HSI. If we want to get a higher clock speed than what the HSI or HSE can provide directly, we need to use the Phase Locked Loop (PLL) to generate a higher clock speed.\nFor this we need to first configure the PLL, enable it and select it as the input source for the clock switch. Before we can throw the switch, however, we also need to make sure that the prescalers for the buses (APB1, APB2, AHB) are set correctly. As we can see in the clock tree diagram, we have maximum speeds for each bus and fixed scaling numbers for each prescaler.\nThis pattern continues with individual peripherals, some of which also have their own prescaler  like USB and the ADC  but this is just something to keep in mind for when using these peripherals. If were just trying to crank the CPU core up to its maximum speed and still want to use the UART, all we need is to get the PLL configuration right, along with the AHB and APB prescalers so that the UART peripheral can be interacted with.\nPlugging In Numbers\nBefore we start happily punching numbers on our keyboard to make the MCU go faster, theres one tedious detail that we have take care of first: appeasing the Flash memory so that it can keep up. This involves configuring the right number of wait states, the use of prefetching and similar options. For this we open our copy of RM0008 to page 60 to ogle at the FLASH_ACR register and its options.\nIn this Flash access control register for the F103 and kin we get to enable or disable the prefetch buffer and the latency. Fortunately, for the latency the RM tells us exactly how many wait states we have to set here depending on our target system clock speed. For the 72 MHz that the F103 is rated for, we have to set two wait states.\nScrolling up a bit to page 58 and doing the unspeakable thing of reading the documentation, we can see that the prefetch buffer is turned on after reset by default and is best left enabled. As for the half cycle option, this is related to power optimization, which means that you will not touch this unless you know what you are doing and are sure that you need to change this.\nConsequently we can configure our Flash as:\nFLASH-ACR |= 2  FLASH_ACR_LATENCY_Pos | FLASH_ACR_PRFTBE;\nNext we wish to use the HSE via the PLL to get the most accurate and fastest system clock speed, which first requires enable the HSE and waiting for RCC_CR_HSERDY to change to 1 as indicate that it is ready for use.\nRCC-CR  RCC_CR_HSEON\nwhile ((RCC-CR  RCC_CR_HSERDY) == 0) {\n    // Handle time-out.\n}\nUp next is configuring the PLL, starting with setting the PLL source to HSE:\nRCC-CFGR |= RCC_CFGR_PLLSRC;\nNow we can configure the AHB and APB prescalers. These take the new system clock and divide it by the set number. For the F103, the 36 MHz-limited APB1 needs to be set to 2, while AHB and APB2 can run at the full 72 MHz, ergo 1.\nRCC-CFGR |= 1  RCC_CFGR_HPRE_Pos;\nRCC-CFGR |= 2  RCC_CFGR_PPRE1_Pos;\nRCC-CFGR |= 1  RCC_CFGR_PPRE2_Pos;\nFinal Steps\nContinuing configuring of the PLL and assuming that it is currently disabled, we can now mash in its multiplier number. Unlike other STM32 families, the F1s PLL is rather simple, with just a single multiplication factor. Since were using the HSE, we need to know the board that we are using and the speed that this HSE oscillates at. Taking the common Blue Pill STM32F103 board as example, this features an 8 MHz HSE input, meaning that we have to multiply this by 9 to get the target of 72 MHz.\nRCC-CFGR |= 7  RCC_CFGR_PLLMULL_Pos;\nThe target PLLMUL register starts at 0x02 for a multiplier of x4, ergo we need to subtract two from our target multiplier. With that done we can enable the PLL and wait for it to stabilize:\nRCC-CR |= RCC_CR_PLLON;\nwhile (!(RCC-CR  RCC_CR_PLLRDY)) {\n    // Timeout handling.\n}\nNext we throw the big switch to use the PLLs output as the system clock source and wait for the switch to complete:\n\nRCC-CFGR = ~(RCC_CFGR_SW);\nRCC-CFGR |= RCC_CFGR_SW_PLL;\nwhile (!(RCC-CFGR  RCC_CFGR_SWS_PLL)) { }\n\nWe should be up and running now, leaving us just to update the global CMSIS SystemCoreClock variable with the new clock speed of 72 MHz.\nBenchmarking\nThese certainly are Dhrystone results. (Credit: Maya Posch)\nRunning Dhrystone on our F103 seems like a bit of a challenge as the benchmark was created for your typical desktop and server systems. To achieve this, I took the original pre-ANSI C code for Dhrystone 2.1 and adapted it to a Nodate project. The dhrystone.cpp file contains the benchmark itself, with no significant modifications other than to set up the MCU and the UART as standard output target. The number of runs is also hardcoded to be 100 million so that it doesnt have to be punched in every time.\nAfter compiling the benchmark and flashing it to the STM32F103 board, it seemed to take a few eternities for it to complete with so many runs. When the boards single LED finally started doing its leisurely blinking routine to indicate completion, it turned out that 347 seconds had expired, or roughly 5.78 minutes. As can be seen in the start time, this wasnt the first attempt, after a 10 million run completed too quickly according to the benchmarks criteria. Cest la vie.\nAnnoyingly, the printf-lite implementation that I use with Nodate didnt seem to like the 32-bit float values and were absent in the final output, so I had to do the calculations for the Dhrystones Per Second (DPS) and related MIPS (DPS / 1757) myself. Since the times() implementations ticks equal seconds, this was at least fairly easily, giving the following numbers:\n\nDPS: ~288,184.438\nMIPS: ~164.021\n\nTo see whether these numbers are at all plausible, I consulted a few lists of Dhrystone benchmark results, including one for DPS and one for MIPS. Taking into account the noise created by running it on an OS versus bare metal, my use of -Og optimization level and other differences, the placement at the level of about a Pentium 100 doesnt seem too farfetched.\nThere is an official ARM Dhrystone benchmarking guide (AN273), which cites a DPS of 40,600.9 for a Cortex-M MCU running at 18.5 MHz. This would be 158,014 DPS if extrapolated linearly, but obviously not the exact board, MCU or compile flags are used, so rough ballpark seems to be the term of the day here.\nPerhaps the most interesting finding is that a lowly STM32F103 MCU can keep up with a once high-end Pentium CPU of the early 1990s, at least within the limited integer-only Dhrystone benchmark.\u00a0 Next target will probably be to run the more modern and extensive CoreMark on the F103 and other STM32 MCUs, to give a more holistic perspective.", "title": "- STM32F103 MCU\u306e\u30b7\u30b9\u30c6\u30e0\u30af\u30ed\u30c3\u30af\u3092\u6700\u5927\u306b\u3059\u308b\u65b9\u6cd5", "body": "STM32F103\u306e\u6642\u8a08\u8a2d\u5b9a\u3092\u6700\u9069\u5316\u3057\u3001CPU\u901f\u5ea6\u309272MHz\u306b\u3059\u308b\u65b9\u6cd5\u3092\u89e3\u8aac\u3002", "titles": ["- STM32F103 MCU\u306e\u30b7\u30b9\u30c6\u30e0\u30af\u30ed\u30c3\u30af\u3092\u6700\u5927\u306b\u3059\u308b\u65b9\u6cd5", "- PLL\u3092\u5229\u7528\u3057\u305fMCU\u306e\u9ad8\u6027\u80fd\u5316\u306e\u30b9\u30c6\u30c3\u30d7", "- \u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u8a2d\u8a08\u8005\u5fc5\u898b\uff01\u30d5\u30e9\u30c3\u30b7\u30e5\u30e1\u30e2\u30ea\u306e\u8a2d\u5b9a\u3068\u6700\u9069\u5316", "- Dhrystone\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u3067\u898b\u308bMCU\u306e\u6027\u80fd\u5411\u4e0a", "- STM32F103\u304c\u304b\u3064\u3066\u306e\u30da\u30f3\u30c6\u30a3\u30a6\u30e0CPU\u3068\u7af6\u3048\u308b\u7406\u7531"]}