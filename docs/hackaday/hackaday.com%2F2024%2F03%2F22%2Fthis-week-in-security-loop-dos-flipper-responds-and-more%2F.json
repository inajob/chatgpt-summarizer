{"pubDate": "2024-03-22T14:00:45", "original_title": "This Week in Security: Loop DOS, Flipper Responds, and More!", "link": "https://hackaday.com/2024/03/22/this-week-in-security-loop-dos-flipper-responds-and-more/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2016/01/darkarts.jpg", "original_content": "Heres a fun thought experiment. UDP packets can be sent with an arbitrary source IP and port, so you can send a packet to one server, and could aim the response at another server. What happens if that response triggers another response? What if you could craft a packet that continues that cycle endlessly? That is essentially the idea behind Loop DoS (Denial of Service).\nThis unique avalanche of packets has been managed using specific implementations of several different network services, like TFTP, DNS, and NTP. There are several CVEs being used to track the issue, but CVE-2024-2169 is particularly odd, with the description that Implementations of UDP application protocol are vulnerable to network loops. This seems to be a blanket CVE for UDP, which is particularly inappropriate given that the first DoS of this sort was first reported in 2009 at the latest.\nMore details are available in a Google Doc. There some interesting tidbits there, like the existence of cross-protocol loops, and several legacy protocols that are vulnerable by design. The important thing to remember here is you have to have an accessible UDP port for this sort of attack to take place, so if youre not using it, firewall it.\nFlipper Flips Back\nWeve covered the saga of the Flipper Zero vs the Canadian government, in the context of car theft. The short version is that Canada has seen an uptick of car thefts from organized crime. Rather than meaningfully dealing with this problem, the Canadian government went looking for scapegoats, and found the Flipper Zero.\nWell now, Flipper has responded, and put simply, the message is stop the madness. There has never been a confirmed case of using a flipper to steal a car, and its very unlikely its ever happened. On a modern car with proper rolling-code security, its not meaningfully possible to use the Flipper Zero for the theft. The two primary ways criminals actually steal cars are with dedicated keyfob repeaters and CAN bus hackers.\nThere is a petition to sign, and for Canadians, Flipper suggests contacting your local member of parliament.\nData-only EoP\nIn a post on the state of modern exploitation, [Connor McGarr] explores the world of post-shellcode Elevation of Privilege (EoP) exploits. Why are we talking about exploitation without shellcode? Namely because the latest and greatest of Windows kernel hardening: kCET, kCFG, and HVCI. Thats kernel Control-flow Enforcement Technology, kernel Control Flow Guard, and Hypervisor-Protected Code Integrity. Those technologies together essentially guarantee that any area of kernel memory can either be writable or executable, but not both. Thats a pretty hard limit.\nSo whats left? Apparently a lot. Starting with the simplest, a data-only exploit, an attacker can sniff the token of a system process and use it to elevate their own. The rest of the post is an in-depth treatment of how an attacker process can sniff and manipulate its way to a nearly kernel-level position. Impressive stuff.\nFortinet Old and New\nWe have a deep dive into a Forticlient vulnerability, CVE-2023-48788, a SQL injection in the FcmDaemon process. The vulnerable field here was FCTUID, and a WAITFOR DELAY message was enough to prove it was the vulnerability. Turning this into an RCE is trivial thanks to the extremely helpful xp_cmdshell function of Microsoft SQL server. Thats off by default, but can be turned back on via SQL statements. *sigh* Its a bit jarring to cover Microsofts stellar work on hardening the Windows kernel, only to find old cruft in their SQL server still causing problems like this.\nAnd then theres the newer Fortinet issue, in the Fortigate SSL VPN. Researchers at Assetnote give us all the details on how they tracked this one down, starting with patch diffing and fuzzing the likely vulnerable endpoint. That led to a crash, which was a great start, but even a Ghidra decompile wasnt quite enough to work out how to turn the crash into an exploit. What was really needed was to hook a debugger to the crashing function.\nAnd that gets into the hack before the hack. As typically happens, the Assetnote folks had to take a system image and backdoor it to get true root access and a usable system terminal. That was an adventure in itself. With that done, GDB did its magic, revealing that the crash they found was nearly useless for exploitation. But a bit of manipulation with leading 0s in the packet that caused the crash, and they had a primitive: The bytes 0x0a0d could be written to the stack, at a mostly controlled location. Is that enough for an exploit? Just two bytes?\nWhen you can send packets that get stored on the heap, and you have a debugger to watch what happens, it turns out that is enough. A return pointer was chosen, that could be corrupted with this two-byte write, to jump program execution through a gadget right into a carefully controlled heap location. Write the payload that pops /bin/sh, and victory! Except, remember all that hacking they did on their test copy of Fortigate? One of those steps was replacing the /bin/sh binary with something useful. After a bit more wrangling, and borrowing a function or two from the system SSL library, the exploit was finally finished, using a nodejs reverse shell. Whew! At least fixes are available.\nHow To ROP\nHave you always wondered how Return Oriented Programming (ROP) actually works in the context of writing an exploit? [Vandan Pathak] has the step-by-step guide for the rest of us. The very basic explanation is that you manipulate the return address of a function, to jump to an unintended function. One of the most popular tricks is to jump into libc, the standard C library.\nBits and Bytes\nToday I learned about a nifty security feature for Linux, as well as an exploit to bypass it. USBGuard is a ruleset to allow and deny USB devices. The trick is that not every USB device is what it claims to be, like a Raspberry Pi or Arduino in gadget mode.\nIn the same manner as the detailed exploit write-ups above, Github has published an impressive hack of the Pixel 8, that uses GPU memory to bypass the ARM Memory Tagging Extension. Were out of room to cover this one in depth, but its worth a read.\nAnd finally, Linux hit a new milestone: Weve got malware. The Canonical Snap Store has a problem with hosting fake Bitcoin wallet apps. Such a malicious app was removed back in February, but it looks like the bad penny has turned up again. But this time it was a whole dime. Ten malicious wallets on the Snap Store. For a very long time the Linux ecosystem has been trustworthy as a place to not get malware, specifically if installing software from system repositories. Unfortunately, the Snap Store does not seem to be such a trustworthy software source. Caveat Emptor and Downloader Beware.", "title": "UDP\u30d1\u30b1\u30c3\u30c8\u3092\u4f7f\u3063\u305fLoop DoS\u653b\u6483\u306b\u3088\u308b\u30b7\u30b9\u30c6\u30e0\u505c\u6b62", "body": "UDP\u30d1\u30b1\u30c3\u30c8\u306b\u3088\u308bDoS\u653b\u6483\u306e\u6982\u5ff5\u3084Flipper Zero\u306e\u30ad\u30e3\u30f3\u30da\u30fc\u30f3\u3001Fortinet\u306e\u8106\u5f31\u6027\u3001Linux\u306eUSBGuard\u907f\u3051\u65b9\u6cd5\u306a\u3069\u591a\u5c90\u306b\u308f\u305f\u308b\u60c5\u5831\u304c\u542b\u307e\u308c\u308b\u9577\u6587\u3002", "titles": ["UDP\u30d1\u30b1\u30c3\u30c8\u3092\u4f7f\u3063\u305fLoop DoS\u653b\u6483\u306b\u3088\u308b\u30b7\u30b9\u30c6\u30e0\u505c\u6b62", "Flipper Zero\u306b\u95a2\u3059\u308b\u30ab\u30ca\u30c0\u653f\u5e9c\u3068\u306e\u8ad6\u4e89", "Windows\u30ab\u30fc\u30cd\u30eb\u306e\u30cf\u30fc\u30c9\u30cb\u30f3\u30b0\u306b\u3064\u3044\u3066\u306e\u73fe\u4ee3\u306e\u30a8\u30af\u30b9\u30d7\u30ed\u30a4\u30c8", "Fortinet\u306e\u53e4\u3044\u8106\u5f31\u6027\u3068\u65b0\u305f\u306aSSL VPN\u306e\u554f\u984c", "\u30ea\u30bf\u30fc\u30f3\u6307\u5411\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0(ROP)\u306e\u5b9f\u969b\u306e\u5b9f\u88c5\u306b\u3064\u3044\u3066"]}