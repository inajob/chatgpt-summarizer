{"pubDate": "2025-06-13T11:00:05", "original_title": "A Remote-Controlled USB Rubber Ducky Clone", "link": "https://hackaday.com/2025/06/13/a-remote-controlled-usb-rubber-ducky-clone/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/06/usb_rubber_ducky_rf_clone.png", "original_content": "\nDespite the repeated warnings of system administrators, IT personnel, and anyone moderately aware of operational security, there are still quite a few people who will gladly plug a mysterious flash drive into their computers to see what\u2019s on it. Devices which take advantage of this well-known behavioral vulnerability have a long history, the most famous of which is Hak5s USB Rubber Ducky. That emulates a USB input device to rapidly execute attacker-defined commands on the target computer. The main disadvantage of these keystroke injection attacks, from the attacker\u2019s point of view, is that they\u2019re not particularly subtle. It\u2019s usually fairly obvious when something starts typing thousands of words per minute on your computer, and the victim\u2019s next move is probably a call to IT. This is where [Krzysztof Witek]s open-source Rubber Ducky clone has an advantage: it uses a signal detected by a SYN480R1 RF receiver to trigger the deployment of its payload. This does require the penetration tester who uses this to be on the site of the attack, but unlike with an always-on or timer-delayed Rubber Ducky, the attacker can trigger the payload when the victim is distracted or away from the computer.This project is based around the ATmega16U2, and runs a firmware based on microdevt, a C framework for embedded development which [Krzysztof] also wrote. The project includes a custom compiler for a reduced form of Hak5s payload programming language, so at least some of the available DuckyScript programs should be compatible with this. All of the project\u2019s files are available on GitHub.Perhaps due to the simplicity of the underlying concept, we\u2019ve seen a few open source implementations of malicious input devices. One was even built into a USB cable.", "title": "\u8b0e\u306eUSB\u30c7\u30d0\u30a4\u30b9\u306b\u6f5c\u3080\u5371\u967a\u6027", "body": "USB\u30c9\u30e9\u30a4\u30d6\u3092\u5229\u7528\u3057\u305f\u653b\u6483\u306b\u95a2\u3059\u308b\u8a18\u4e8b\u3067\u3001\u7279\u306b\u65b0\u3057\u3044Rubber Ducky\u30af\u30ed\u30fc\u30f3\u304c\u7d39\u4ecb\u3055\u308c\u3066\u3044\u308b\u3002", "titles": ["\u8b0e\u306eUSB\u30c7\u30d0\u30a4\u30b9\u306b\u6f5c\u3080\u5371\u967a\u6027", "Hak5\u306eUSB Rubber Ducky\u3092\u51cc\u3050\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30d7\u30ed\u30b8\u30a7\u30af\u30c8", "\u653b\u6483\u8005\u304c\u6ce8\u76ee\u3059\u308bRF\u53d7\u4fe1\u6a5f\u3092\u5229\u7528\u3057\u305f\u65b0\u3057\u3044\u30a2\u30d7\u30ed\u30fc\u30c1", "ATmega16U2\u30d9\u30fc\u30b9\u306e\u30ab\u30b9\u30bf\u30e0USB\u30ad\u30fc\u30b9\u30c8\u30ed\u30fc\u30af\u653b\u6483\u30c7\u30d0\u30a4\u30b9", "GitHub\u3067\u516c\u958b\uff01Hak5\u4e92\u63db\u306e\u30da\u30a4\u30ed\u30fc\u30c9\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u8a00\u8a9e\u3092\u3082\u3064\u30d7\u30ed\u30b8\u30a7\u30af\u30c8"]}