{"pubDate": "2024-05-13T05:00:17", "original_title": "Emulate a KIM-1 with a Commodore 64", "link": "https://hackaday.com/2024/05/12/emulate-a-kim-1-with-a-commodore-64/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/05/emu.png", "original_content": "When you think about virtualization, you usually think about making some CPU pretend to be another CPU. However, there are sometimes advantages to making a computer pretend to be the same computer.\nThats the case with [oldvcr]s KIMplement, which emulates a KIM-1 with a 6502 using a Commodore 64, which also uses a 6502.The reason this makes sense is that you have total control over an emulated CPU. If a program, for example, writes to a critical memory location or tries to take over the screen or keyboard, you can easily make the emulator do something more appropriate. Things like breakpoints and single stepping also become trivial.\nThe virtual machine at the heart of it is 6o6 (6502 on 6502), and it seems to perform well. By virtualizing, you can easily protect the system from programs that try to, for example, take over an interrupt vector. This is similar to how x86 protected mode can run old real-mode code in a virtual environment and intervene for certain instructions. The emulation is good enough that the emulator can run the emulator, which then runs the emulator to actually run the real target. Thats wasteful, of course, but it does speak to the completeness of the pretend CPU.\nIf you want a KIM-1 (and an 1802 Elf) but only have an Arduino, you can emulate a different way. At least an emulated KIM-1 doesnt develop bad memory chips.", "title": "\u30b3\u30e2\u30c9\u30fc\u30eb64\u3092\u4f7f\u3063\u305fKIM-1\u30a8\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3", "body": "\u4eee\u60f3\u5316\u306fCPU\u3092\u4ed6\u306eCPU\u306b\u898b\u305b\u308b\u3053\u3068\u3068\u3057\u3066\u8003\u3048\u3089\u308c\u308b\u304c\u3001\u540c\u3058\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3092\u898b\u305b\u308b\u5229\u70b9\u3082\u3042\u308b\u3002KIM-1\u30686502\u3092\u30a8\u30df\u30e5\u30ec\u30fc\u30c8\u3059\u308bKIMplement\u304c\u3042\u308a\u3001\u4e3b\u306b\u30b3\u30e2\u30c9\u30fc\u30eb64\u3092\u4f7f\u3046\u3002\u5236\u5fa1\u306f\u7c21\u5358\u3067\u3001\u4f8b\u3048\u3070\u30e1\u30e2\u30ea\u306b\u66f8\u304d\u8fbc\u307f\u3084\u753b\u9762\u3001\u30ad\u30fc\u30dc\u30fc\u30c9\u306e\u652f\u914d\u3092\u5236\u9650\u3067\u304d\u308b\u3002", "titles": ["\u30b3\u30e2\u30c9\u30fc\u30eb64\u3092\u4f7f\u3063\u305fKIM-1\u30a8\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3", "6502\u3092\u4f7f\u3063\u305fKIM-1\u306e\u4eee\u60f3\u5316\u3068\u5b9f\u73fe", "\u5b89\u5168\u306a\u30b7\u30b9\u30c6\u30e0\u306e\u305f\u3081\u306eCPU\u30a8\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3", "\u4eee\u60f3\u30de\u30b7\u30f3606\u306b\u3088\u308b\u5b9f\u884c\u6027\u80fd", "Arduino\u3067\u306eKIM-1\u30a8\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3"]}