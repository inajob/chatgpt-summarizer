{"pubDate": "2023-12-26T15:00:17", "original_title": "Game Graphics: Rasterization", "link": "https://hackaday.com/2023/12/26/game-graphics-rasterization/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/10/Graphics.jpg", "original_content": "Last time, I talked about racing the beam, a type of graphics used when memory was scarce. Now its time to step into the future with more memory and talk about what modern 2D games still do to this day: rasterization.\nJust in time Memory\nContinuing the trend set by racing the beam, rasterized graphics are also on a grid, just a much tinier one. Though not unique to rasterized, the frame buffer is the logical conclusion of bitmap mode fidelity: enough memory is allocated so that every pixel can have its own color. Whats different about a frame buffer is that everything is drawn before it is shown and, crucially, this doesnt have to happen in the same order as the pixels are displayed. Rasterization draws entire shapes  triangles, lines and rectangles  into the frame buffer and the screen is typically updated all at once.\nCrude Circles\nYou may have noticed I didnt mention circles earlier. Thats because we dont actually draw circles, we approximate them. Its a simple thing, really: Would you rather draw 50 triangles, or compute 10000 distance calculations? Well, if you said triangles, the computers agree with you.\nThis diagram shows an exaggerated representation of how a circle can be approximated using triangles. Its quite obvious here where the triangles are, but the more triangles you add, the closer you can get to a perfect circle. More complex shapes, like text, polygons and abstract shapes can also be made with triangles.\nThe plotting predicament\nBut approximating circles isnt the only problem in rasterization, approximating triangles is a problem too! There are a limited number of pixels, which means that all but a perfectly aligned rectangle needs to be approximated in the actual rasterization process.\nThere are several ways to rasterize triangles, from left to right: any pixel that touches the outline of the triangle, any pixel whose center lies within the triangle, or any pixel that lies fully within the triangle. The second (or center) one is most common, because it avoids both unnecessary overlap and unnecessary gaps, notable artifacts of the other two methods respectively. Unnecessary overlap causes semitransparent shapes to show a seam of more opaque pixels, while unnecessary gaps cause most shapes to show a seam of unplotted pixels, both of which are undesirable.\nNow thats nice and all, but how does a computer actually implement such a thing? My computer graphics library does it with linear algebra. First, I divide the triangle into one or two trapezoids with a horizontal top and bottom line. Then, I divide it into imaginary horizontal lines at the vertical center of each row of pixels. Finally, I plot pixels from left to right within these horizontal lines.\nRectangles and lines are simpler: rectangles always have two horizontal and two vertical edges so they can be drawn with two for loops and lines are usually drawn by simply linearly interpolating between both endpoints. All other shapes can be drawn using these three primitives like I said earlier.\nColorful math\nSince the switch to framebuffers, we can specify the color per pixel without having to use a palette, like when racing the beam. This opens up the possibility for semitransparent shapes, some ways of drawing text, images and even shaders.\nShaders are programs that run in the GPU, but what most people think when they hear shaders are actually fragment shaders. Also known as pixel shaders, theyre used to calculate the color of a single pixel in the shape.\nMost fragment shaders use texture coordinates, also known as UV coordinates or UVs, as the primary variable. Be that to literally apply a texture (i.e. an image), or to change the color (right). UVs range from 0 to 1 and are used primarily for images. The square in the center shows its UVs by making U (left to right) red and V (top to bottom) green. The other two squares show effects that are possible using UVs, which is of course changing the colors.\nConclusion\nRasterization is a rendering technique that takes advantage of the large amounts of memory afforded to computers. By its nature, it takes much better advantage of parallel processors in the form of GPUs and is a lot more flexible than racing the beam. Using rasterized graphics, you can draw almost anything, from a simple circle to a complex webpage. Rasterized graphics are flexible and used everywhere today.\nStay tuned for next time, when Ill spice things up with matrix math, more images/sprites and multiple layers!", "title": "\u30e9\u30b9\u30bf\u30e9\u30a4\u30bc\u30fc\u30b7\u30e7\u30f3: \u30e1\u30e2\u30ea\u3092\u6d3b\u7528\u3057\u305f2D\u30b2\u30fc\u30e0\u306e\u63cf\u753b\u6280\u8853", "body": "\u300c\u30ec\u30fc\u30b9\u30fb\u30b6\u30fb\u30d3\u30fc\u30e0\u300d\u3068\u3044\u3046\u30e1\u30e2\u30ea\u304c\u4e0d\u8db3\u3057\u3066\u3044\u305f\u6642\u4ee3\u306e\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u306b\u3064\u3044\u3066\u8a71\u3057\u305f\u524d\u56de\u3068\u306f\u7570\u306a\u308a\u3001\u73fe\u4ee3\u306e2D\u30b2\u30fc\u30e0\u3067\u4f7f\u308f\u308c\u3066\u3044\u308b\u30e9\u30b9\u30bf\u30e9\u30a4\u30bc\u30fc\u30b7\u30e7\u30f3\u306b\u3064\u3044\u3066\u8a71\u3057\u307e\u3057\u3087\u3046\u3002\u30e1\u30e2\u30ea\u306e\u9650\u754c\u3092\u8d85\u3048\u308b\u305f\u3081\u3001\u30d1\u30e9\u30ec\u30eb\u30d7\u30ed\u30bb\u30c3\u30b5\u3067\u3042\u308bGPU\u3092\u5229\u7528\u3057\u3066\u3001\u30e9\u30b9\u30bf\u30e9\u30a4\u30bc\u30fc\u30b7\u30e7\u30f3\u306f\u975e\u5e38\u306b\u512a\u308c\u305f\u6027\u80fd\u3092\u767a\u63ee\u3057\u3001\u30ec\u30fc\u30b9\u30fb\u30b6\u30fb\u30d3\u30fc\u30e0\u3088\u308a\u3082\u67d4\u8edf\u6027\u304c\u3042\u308a\u307e\u3059\u3002\u30e9\u30b9\u30bf\u30e9\u30a4\u30ba\u3055\u308c\u305f\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u3067\u3001\u7c21\u5358\u306a\u5186\u304b\u3089\u8907\u96d1\u306a\u30a6\u30a7\u30d6\u30da\u30fc\u30b8\u307e\u3067\u3001\u307b\u307c\u4f55\u3067\u3082\u63cf\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u30e9\u30b9\u30bf\u30e9\u30a4\u30ba\u3055\u308c\u305f\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u306f\u67d4\u8edf\u3067\u3001\u73fe\u5728\u3069\u3053\u3067\u3082\u4f7f\u7528\u3055\u308c\u3066\u3044\u307e\u3059\u3002", "titles": ["\u30e9\u30b9\u30bf\u30e9\u30a4\u30bc\u30fc\u30b7\u30e7\u30f3: \u30e1\u30e2\u30ea\u3092\u6d3b\u7528\u3057\u305f2D\u30b2\u30fc\u30e0\u306e\u63cf\u753b\u6280\u8853", "\u30c8\u30e9\u30a4\u30a2\u30f3\u30b0\u30eb\u3067\u5186\u3092\u63cf\u304f: \u30e9\u30b9\u30bf\u30e9\u30a4\u30bc\u30fc\u30b7\u30e7\u30f3\u306e\u8fd1\u4f3c\u6280\u8853", "\u30e9\u30b9\u30bf\u30e9\u30a4\u30bc\u30fc\u30b7\u30e7\u30f3\u306e\u4e09\u89d2\u5f62\u63cf\u753b: \u5b8c\u5168\u306b\u30a2\u30d7\u30ed\u30c3\u30af\u30b9\u3055\u308c\u305f\u4e09\u89d2\u5f62\u304c\u5fc5\u8981", "\u30ab\u30e9\u30d5\u30eb\u306a\u6570\u5b66: \u30d5\u30ec\u30fc\u30e0\u30d0\u30c3\u30d5\u30a1\u3067\u306e\u30d4\u30af\u30bb\u30eb\u3054\u3068\u306e\u8272\u306e\u6307\u5b9a", "\u30e9\u30b9\u30bf\u30e9\u30a4\u30bc\u30fc\u30b7\u30e7\u30f3\u306e\u67d4\u8edf\u6027: \u5358\u7d14\u306a\u5186\u304b\u3089\u8907\u96d1\u306a\u30a6\u30a7\u30d6\u30da\u30fc\u30b8\u307e\u3067\u63cf\u753b\u53ef\u80fd"]}