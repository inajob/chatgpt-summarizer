{"pubDate": "2025-11-25T09:00:23", "original_title": "Unusual Circuits in the Intel 386\u2019s Standard Cell Logic", "link": "https://hackaday.com/2025/11/25/unusual-circuits-in-the-intel-386s-standard-cell-logic/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/11/386_extra-transistor_ken_shirriff_cropped.jpg", "original_content": "Intels 386 CPU is notable for being its first x86 CPU to use so-called standard cell logic, which swapped the taping out of individual transistors with wiring up standardized functional blocks. This way you only have to define specific gate types, latches and so on, after which a description of these blocks can be parsed and assembled by a computer into elements of a functioning application-specific integrated circuit (ASIC). This is standard procedure today with register-transfer level (RTL) descriptions being placed and routed for either an FPGA or ASIC target.\nThat said, [Ken Shirriff] found a few surprises in the 386s die, some of which threw him for a loop. An intrinsic part of standard cells is that theyre arranged in rows and columns, with data channels between them where signal paths can be routed. The surprise here was finding a stray PMOS transistor right in the midst of one such data channel, which [Ken] speculates is a bug fix for one of the multiplexers. Back then regenerating the layout would have been rather expensive, so a manual fix like this would have made perfect sense. Consider it a bodge wire for ASICs.\nAnother oddity was an inverter that wasnt an inverter, which turned out to be just two separate NMOS and PMOS transistors that looked to be wired up as an inverter, but seemed to actually there as part of a multiplexer. As it turns out, its hard to determine sometimes whether transistors are connected in these die teardowns, or whether theres a gap between them, or just an artifact of the light or the etching process.", "title": "\u30a4\u30f3\u30c6\u30eb386 CPU\u306e\u6a19\u6e96\u30bb\u30eb\u8ad6\u7406\u306e\u9769\u65b0", "body": "Intels 386 CPU\u306f\u6a19\u6e96\u30bb\u30eb\u30ed\u30b8\u30c3\u30af\u3092\u7528\u3044\u305f\u521d\u306ex86 CPU\u3002\u56de\u8def\u8a2d\u8a08\u306e\u5947\u5999\u306a\u767a\u898b\u3082\u3042\u3063\u305f\u3002", "titles": ["\u30a4\u30f3\u30c6\u30eb386 CPU\u306e\u6a19\u6e96\u30bb\u30eb\u8ad6\u7406\u306e\u9769\u65b0", "386\u30c1\u30c3\u30d7\u5185\u306e\u9a5a\u304d\uff1aPMOS\u30c8\u30e9\u30f3\u30b8\u30b9\u30bf\u306e\u8b0e", "ASIC\u8a2d\u8a08\u306b\u304a\u3051\u308b\u624b\u52d5\u4fee\u6b63\u306e\u5b9f\u4f8b", "386\u30c1\u30c3\u30d7\u306e\u9006\u8ee2\u5668\u306e\u5947\u5999\u306a\u6b63\u4f53", "\u30c6\u30a3\u30a2\u30c0\u30a6\u30f3\u89e3\u6790\u306b\u304a\u3051\u308b\u30c8\u30e9\u30f3\u30b8\u30b9\u30bf\u63a5\u7d9a\u306e\u96e3\u3057\u3055"]}