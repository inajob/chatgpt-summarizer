{"pubDate": "2024-07-30T17:00:23", "original_title": "Programming Ada: Designing a Lock-Free Ring Buffer", "link": "https://hackaday.com/2024/07/30/programming-ada-designing-a-lock-free-ring-buffer/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2019/09/ProgrammingSystem.jpg", "original_content": "Ring buffers are incredibly useful data structures that allow for data to be written and read continuously without having to worry about where the data is being written to or read from. Although they present a continuous (ring) buffer via their API, internally a definitely finite buffer is being maintained. This makes it crucial that at no point in time the reading and writing events can interfere with each other, something which can be guaranteed in a number of ways. Obviously the easiest solution here is to use a mutual exclusion mechanism like a mutex, but this comes with a severe performance penalty.\nA lock-free ring buffer (LFRB) accomplishes the same result without something like a mutex (lock), instead using a hardware feature like atomics. In this article we will be looking at how to design an LFRB in Ada, while comparing and contrasting it with the C++-based LFRB that it was ported from. Although similar in some respects, the Ada version involves Ada-specific features such as access types and the rendezvous mechanism with task types (threads).\n\nPort Planning\nThe C++ code that the Ada LFRB is based on can be found as a creatively titled GitHub project, although it was originally developed for the NymphCast project. In that projects usage scenario, it provides a memory buffer for network data as its being fetched from a client and made available to the local media player. Here the player requests additional data when it doesnt have enough buffered data to decode the next frame, resulting in a read request to the LFRB. If its buffer doesnt have sufficient data left to fulfill the read request, it triggers the data request task, which for NymphCast means fetching more data from the client until the LFRBs buffer is full again.\nSimplified layout of a ring buffer.\nWith this C++ version we are using only C++14-level features, including std::thread, std::chrono, mutexes and condition variables. For the internal buffer we use a heap-allocated buffer, a uint8_t array, with raw pointers into this array which keep track of the reading and writing locations, alongside a number of atomic variables for the number of free bytes, unread bytes, buffer capacity, and so on. This means that while seemingly simple, the main trick lies in properly updating the pointers and variables to properly reflect the current state.\nSo what would the Ada version look like? We would need a heap-allocated buffer, obviously. Here we would use a simple array, which has the advantage in Ada that its arrays are bound-checked during compile- and run-time. Meanwhile the uint8_t* pointers are replaced with simple index trackers, which will use the predefined Unsigned_32 type from the standard Interfaces package. This guarantees that we can have a buffer capacity of up to 4 GB, just in case that much is ever needed.\nFor the data request thread we use an Ada task, which is effectively the same thing as in C++, just with it being a native part of the language. This means that no packages have to be included and task synchronization mechanisms are also an integral part of the core language. What we do notice here is that Adas multi-threading features are very different from that found in other mainstream languages which overwhelmingly follow the POSIX pthread model. We will look at this in more detail when we get to this part of the design in the next part of this series.\nUnchecked Operations\nAlthough in Ada we can allocate more memory as much as we want using the new keyword, one thing which the language doesnt like you to do is deallocating it, akin to free or delete in C and C++. This is because manual deallocation like this is a common source of really bad things, so youre generally asked to not do this and instead rely on the automatic deallocation methods. If you feel that you really, really have to do manual deallocation of previously allocated memory blocks, you can do so via the Ada.Unchecked_Deallocation package that was added with Ada 95.\nSince we would like to maybe get rid of the buffer which we allocated when the LFRBs capacity was set, for example when the user demands that a differently sized buffer is created, or just for housekeeping reasons when shutting down the application, we have to enter unchecked territory. Fortunately, this isnt hugely complicated, merely requiring us to define a procedure that uses the provided generic template from the Ada.Unchecked_Deallocation package.\nTo demonstrate this, we can implement the allocation and deallocation, starting with allocating the byte array:\ntype buff_array is array(Unsigned_32 range ) of Unsigned_8;\ntype buff_ref is access buff_array;\nbuffer : buff_ref;\nbuffer := new buff_array(0 .. capacity);\nAs the new allocation returns an access type reference (pointer) for the type which are allocating, we need to define a type for this and use this as the reference from then onwards.\nWhen were done with the array, we need to use the custom function which we defined as follows:\nwith Ada.Unchecked_Deallocation;\nprocedure free_buffer is new Ada.Unchecked_Deallocation\n    (Object = buff_array, Name = buff_ref);\nfree_buffer (buffer);\nTo create a deallocation procedure, we just need to provide the generic template with the details of what were trying to deallocate. This means the buff_array type for the object type and buff_ref for the access type name (the pointer type). These correspond to the types which we defined earlier when we allocated the buffer.\nSetting Bounds\nTo be able to safely write and read the buffers contents, we need to keep track of more than just the current read and write indices. We also need to know the starting index of the buffer (always 0), the last index (capacity  1), as well as the current number of free and unread bytes. The latter two start at zero and are updated as data is written and read. This is similar to the C++ version, except for a few offset differences due to the C++ version using mostly pointer arithmetic and this Ada port pure array indices. We are of course free to start an Ada array at any index (like 1) we desire, but for this port we are sticking to 0 as the first index because its tradition.\nOne nice thing about Ada is that if we do get an offset or index wrong, we get a constraint_error exception raised during runtime, along with the where and how. For example if we go out of bounds an Index Check is raised:\nraised CONSTRAINT_ERROR : datarequest.adb:26 index check failed\nThen if we use array slices to write to or copy from part of an array, making a mistake there gets us a Length Check:\nraised CONSTRAINT_ERROR : lfringdatabuffer.adb:329 length check failed\nHere array slices follow the pattern of array(first .. last), where the first byte thats part of the slice is specified with first and the last byte to be included with last.\nDereferencing\nThis leaves us with one more detail regarding access types, which includes the earlier array access type, as well as that of procedure, function and task access types (first two called function pointers in C++ nomenclature). For our array access type this is fairly easy, as demonstrated when e.g. creating an array slice to write data into the buffer:\nbuffer.all(data_back .. writeback) := data;\nDereferencing on the buffer array is done using .all, after which we can use it as normal. For references to procedures, functions and also tasks its even more straightforward, which we will take an in-depth look at in the next part as we begin to implement the LFRB and assemble all of the pieces which we have discussed in this article."}