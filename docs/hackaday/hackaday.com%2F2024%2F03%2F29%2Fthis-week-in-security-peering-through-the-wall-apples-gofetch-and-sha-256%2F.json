{"pubDate": "2024-03-29T14:00:38", "original_title": "This Week in Security: Peering Through the Wall, Apple\u2019s GoFetch, and SHA-256", "link": "https://hackaday.com/2024/03/29/this-week-in-security-peering-through-the-wall-apples-gofetch-and-sha-256/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2016/01/darkarts.jpg", "original_content": "The Linux command wall is a hold-over from the way Unix machines used to be used. Its an abbreviation of Write to ALL, and it was first included in ATT Unix, way back in 1975. wall is a tool that a sysadmin can use to send a message to the terminal session of all logged-in users. So far nothing too exciting from a security perspective. Where things get a bit more interesting is the consideration of ANSI escape codes. Those are the control codes that moves the cursor around on the screen, also inherited from the olden days of terminals.\nThe modern wall binary is actually part of util-linux, rather than being a continuation of the old Unix codebase. On many systems, wall runs as a setgid, so the behavior of the system binary really matters. Its accepted that wall shouldnt be able to send control codes, and when processing a message specified via standard input, those control codes get rejected by the fputs_careful() function. But when a message is passed in on the command line, as an argument, that function call is skipped.\nThis allows any user that can send wall messages to also send ANSI control codes. Is that really a security problem? There are two scenarios where it could be. The first is that some terminals support writing to the system clipboard via command codes. The other, more creative issue, is that the output from running a binary could be overwritten with arbitrary text. Text like:\nSorry, try again.\n[sudo] password for jbennett:\nYou may have questions. Like, how would an attacker know when such a command would be appropriate? And how would this attacker capture a password that has been entered this way? The simple answer is by watching the list of running processes and system log. Many systems have a command-not-found function, which will print the failing command to the system log. If that failing command is actually a password, then its right there for the taking. Now, you may think this is a very narrow attack surface thats not going to be terribly useful in real-world usage. And thats probably pretty accurate. It is a really fascinating idea to think through, and definitively worth getting fixed.\nEdges Private API\nSo theres a funny thing that happens when you visit microsoft.com in the Edge browser. There are buttons labeled Try now for various features, like the Drop file sharing function. When you click the button, the browser opens the drop sidebar to show off how it works. In retrospect, that should have seemed really odd. The secret is that when Microsoft builds Edge from Chromium source, it adds the edgeMarketingPagePrivate API, giving a certain list of Microsoft pages more permissions to do things in the browser.\nOne of those permissions has a bit of a problem: Installing themes. The dirty secret is that a Chromium theme is really a Chromium extension, with a subset of features and permissions. Edge gives Javascript from Microsoft pages the special permission to install a theme. The actual vulnerability here is that this API also unintentionally allows the silent installation of any extension, not just themes. And extensions can be particularly powerful, with the ability to read and modify web pages, access cookies, and more.\nWhile thats obviously not great, there is the limited attack surface to think about. To abuse this, an attacker needs to be able to put JS on a Microsoft site. There are some far-fetched but not impossible scenarios, like a rogue actor at Microsoft, or an XSS (Cross Site Scripting) vulnerability discovered on one of those sites. Then there are more feasible attack vectors, like a malicious browser extension with few permissions, that uses this bug to install an extension with every permission. Or what about an enterprise security appliance that has a trusted SSL certificate, that can snoop on web pages? It seems feasible that if such a device was compromised, slipping a bit of Javascript into a Microsoft page isnt impossible.\nRegardless, version 121.0.2277.98 of Edge contained a fix, adding a check that only themes can be installed via this API. This fix landed just shy of 90 days, on February 9th.\nGoFetch\nAt least one notorious Internet personality has referred to the latest Apple vulnerability disclosure as a backdoor. This seems to over-hype the problem a bit. What we really have is a side-channel that can expose keys. Apples M1 and M2 processors have a Data Memory-dependent Prefetcher (DMP) that looks ahead in program execution, and attempts to load memory into cache before it is needed.\nThe problem is that one of the techniques to pull this off is to look at program memory for pointer-like values, and cache the contents of the memory at those locations. This means that an otherwise black-box cryptography operation can change the system state in detectable ways. The end result is that if an attacker controls the data being acted on in a cryptographic process, and can run a second process on the same machine, the keys themselves can be derived.\nSHA-256 Collisions  Nearly Halfway There\nThis is the sort of thing that makes a security nerds blood run cold for a moment. We now have practical attacks against SHA-256  for the first 31 steps. This requires a bit of context. SHA-256 is a cryptographic hashing function that takes an input, and lays it out into a Message Schedule, and then performs 64 steps of mixing operations. Its those mixing steps that accomplish the one-way nature of SHA-256. Whats claimed here is that if made a version of SHA-256 that only used 31 mixing steps, we could perform collision attacks.\n\nFirst practical SHA-256 collision for 31 steps. #fse2024 pic.twitter.com/qBo3tOLPGB\n Frank  (@jedisct1) March 26, 2024\n\nThe paper for this work has landed, and is as full of heavy cryptography as one would expect. The good news is were still a *very* long ways from an actual SHA-256 attack, and the state-of-the-art is moving quite slowly. Yes, your bitcoins are still safe.\nIts Not a Vulnerability\nBut servers are still getting compromised. The Ray framework is getting widespread adoption as an easily deploy-able service to get AI models up and doing real work. And unfortunately, the Ray framework is getting attacked in an ongoing campaign. And a Ray instance is quite the juicy target, with plenty of data to scrape, as well as lots of juicy compute infrastructure to mine cryptocurrency on. Whats interesting is that Ray doesnt have an authentication layer by design.\nDue to Ray\u2019s nature as a distributed execution framework, Ray\u2019s security boundary is outside of the Ray cluster\nThis isnt the first popular application designed this way, and the common lesson is that when you hand users a footgun like this, some size-able percentage of them will happily use it. A CVE was issued for the lack of authentication, but was (rightfully) disputed by Anyscale.\nThere is an important distinction to make here, that just because this issue isnt a proper vulnerability, it doesnt mean that it isnt a problem, or shouldnt be improved. And thats finally the conclusion Anyscale has come to. Whats now available is an official test script, slated to get included in Ray 2.11, that looks for exposure and warns about it. Time will tell if a future version of Ray will get full authentication by default.\nBits and Bytes\nIn an interesting first, Zenhammer allows the flipping of DDR5 memory bits in a rowhammer attack, though in only one of the ten sticks of memory tested. To successfully pull off the attack against a Zen processor, the DRAM address obfuscation function had to be reverse-engineered, and a few other Zen-specific techniques had to be used. From my read, Micron seemed to come out the winner of the small sample size used.\nA pair of SharePoint vulnerabilities used at last years Pwn2Own contest has now made the list of actively exploited vulnerabilities. Its a bit humorous that the vulnerabilities has been known for over a year, and only now are US federal agencies actually forced to fix them.\nSpeaking of which, this years Pwn2Own contest just wrapped up. Over a million dollars was won by researchers, with Manfred Paul taking the top spot. We look forward to all of this years bugs getting fixed and disclosed.\nAnd finally, Google was paying attention to the Loop DoS announcement, and has a report out about a real-world DoS attack that included a presumably unintentional loop element. CLDAP, a UDP partial implementation of LDAP, was used several years ago in a reflection attack against Googles QUIC infrastructure. The QUIC servers responded with Reset packets to each of the CLDAP servers. And a handful of those servers sent the reset packets right back, resulting in a 20 million packet-per-second loop across the Internet. The solution is fascinating too: Ensure that Reset packets are always shorter than the packet being responded to, down to a threshold where packets were just ignored. Nifty.", "title": "Linux\u30b3\u30de\u30f3\u30c9wall\u306e\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u30ea\u30b9\u30af\u3068ANSI\u30a8\u30b9\u30b1\u30fc\u30d7\u30b3\u30fc\u30c9", "body": "Unix\u30de\u30b7\u30f3\u3067\u4f7f\u7528\u3055\u308c\u3066\u3044\u305fLinux\u30b3\u30de\u30f3\u30c9wall\u306f\u3001\u5168\u54e1\u306b\u66f8\u304d\u8fbc\u3080\u3053\u3068\u3092\u610f\u5473\u3059\u308b\u7565\u8a9e\u3067\u3001\u30b7\u30b9\u30c6\u30e0\u7ba1\u7406\u8005\u304c\u5168\u30e6\u30fc\u30b6\u30fc\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u9001\u4fe1\u3067\u304d\u308b\u3002ANSI\u30a8\u30b9\u30b1\u30fc\u30d7\u30b3\u30fc\u30c9\u3092\u8003\u616e\u3059\u308b\u3068\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u4e0a\u306e\u554f\u984c\u304c\u767a\u751f\u3059\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u3002Edge\u30d6\u30e9\u30a6\u30b6\u3084\u4ed6\u306e\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u4e0a\u306e\u554f\u984c\u3082\u767a\u751f\u3002", "titles": ["Linux\u30b3\u30de\u30f3\u30c9wall\u306e\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u30ea\u30b9\u30af\u3068ANSI\u30a8\u30b9\u30b1\u30fc\u30d7\u30b3\u30fc\u30c9", "Edge\u30d6\u30e9\u30a6\u30b6\u306eAPI\u306b\u3088\u308b\u6f5c\u5728\u7684\u306a\u62e1\u5f35\u6a5f\u80fd\u306e\u554f\u984c", "Apple\u30d7\u30ed\u30bb\u30c3\u30b5\u306e\u30b5\u30a4\u30c9\u30c1\u30e3\u30cd\u30eb\u653b\u6483\u3068\u9375\u306e\u6f0f\u6d29", "SHA-256\u306b\u304a\u3051\u308b\u885d\u7a81\u653b\u6483\u306e\u9032\u5c55", "Ray\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af\u306e\u8a8d\u8a3c\u30ec\u30a4\u30e4\u30fc\u306e\u6b20\u5982\u3068\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u5bfe\u7b56"]}