{"pubDate": "2025-03-21T23:00:16", "original_title": "Moving Software Down to Hardware", "link": "https://hackaday.com/2025/03/21/moving-software-down-to-hardware/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/03/hardware-programming-main.png", "youtube": "https://www.youtube.com/watch?v=_pVlHPgud7I", "original_content": "In theory, any piece of software could be built out of discrete pieces of hardware, provided there are enough transistors, passive components, and time available. In general, though, were much more likely to reach for a programmable computer or microcontroller for all but the simplest tasks for several reasons: cost, effort, complexity, economics, and sanity. [Igor Brichkov] was working with I2C and decided that he wanted to see just where this line between hardware and software should be by implementing this protocol itself directly with hardware.\nOne of the keys to programming a communications protocol in hardware is getting the timing right, the first part of which is initializing communications between this device and another on the bus. [Igor] is going to be building up the signal in parts and then ORing them together. The first part is a start condition, generated by one oscillator and a counter. This also creates a pause, at which point a second oscillator takes over and sends data out. The first data needed for I2C is an address, which is done with a shift register and a counter pre-set to send the correct bits out on the communications lines.\nTo build up the rest of the signal, including data from the rotary encoder [Igor] is using for his project, essentially sets of shift registers and counters are paired together to pass data out through the I2C communications lines in sequence. It could be thought of that the main loop of the hardware program is a counter, which steps through all the functions sequentially, sending out data from the shift registers one by one. We saw a similar project over a decade ago, but rather than automating the task of sending data on I2C it allowed the user to key in data manually instead.\n\n", "title": "I2C\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3067\u5b9f\u88c5\u3059\u308b\u6311\u6226", "body": "\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306f\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3067\u69cb\u6210\u53ef\u80fd\u3060\u304c\u3001\u30b3\u30b9\u30c8\u3084\u624b\u9593\u304b\u3089\u30de\u30a4\u30b3\u30f3\u3092\u4f7f\u3046\u306e\u304c\u4e00\u822c\u7684\u3002I2C\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u30cf\u30fc\u30c9\u3067\u5b9f\u88c5\u3059\u308b\u8a66\u307f\u306b\u53d6\u308a\u7d44\u3080\u3002", "titles": ["I2C\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3067\u5b9f\u88c5\u3059\u308b\u6311\u6226", "\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3067\u306e\u901a\u4fe1\u30bf\u30a4\u30df\u30f3\u30b0\u306e\u91cd\u8981\u6027", "\u30b7\u30d5\u30c8\u30ec\u30b8\u30b9\u30bf\u3068\u30ab\u30a6\u30f3\u30bf\u3092\u4f7f\u3063\u305f\u4fe1\u53f7\u751f\u6210", "I2C\u901a\u4fe1\u306b\u304a\u3051\u308b\u30c7\u30fc\u30bf\u9001\u4fe1\u306e\u30e1\u30ab\u30cb\u30ba\u30e0", "\u624b\u52d5\u5165\u529b\u304b\u3089\u81ea\u52d5\u30c7\u30fc\u30bf\u9001\u4fe1\u3078\u306e\u9032\u5316"]}