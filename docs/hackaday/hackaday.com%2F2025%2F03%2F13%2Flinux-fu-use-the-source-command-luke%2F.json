{"pubDate": "2025-03-13T17:00:48", "original_title": "Linux Fu: Use the Source (Command), Luke", "link": "https://hackaday.com/2025/03/13/linux-fu-use-the-source-command-luke/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "You can argue if bash is a good programming language or not, but you cant argue that it is a programming language. However, there are a few oddities about it that make it different from most other languages you probably know. For one thing, variables are dynamically scoped. Second, you can easily change variables in an upper scope. This leads to a problem when you want to do something like reset your path:\n\n#!/bin/bash\n#: This does NOT work\nPATH=/usr/bin:/bin\n\nWell, actually, it does work; it just doesnt work the way you imagine it might. The key is to realize that when you execute our script (say, resetpath), a new copy of bash runs. It inherits all the variables from your shell. Now the script sets PATH for the new copy of bash. Anything else you run in that script will see your change. But when the script exits, the new copy of bash is gone and the old copy sees the same old PATH it always did.\n\nSometimes, this is a benefit, similar to call by value in other languages. However, what if you want to influence things? Whats more is that the situation is just the opposite within bash functions. For example:\n\n#!/bin/bash\n\nb() {\n  echo B: $x\n  x=200\n}\n\na() {\n  x=100\n  b\n  echo A: $x\n}\n\na\n#: output\n#: B: 100\n#: A: 200\n\nFunction b has no difficulty reading and even setting variable x.\nThe Answer, Of Source Course\nThe answer to the first problem is to use the source command (which can be either the word source or a single period). This tells bash to avoid running a new interpreter and just pretend youd entered all the lines in a file from the console.\nThis is great sometimes. Our resetpath script will actually work just fine with either of these commands:\n\nsource resetpath\n. resetpath\n\nYou dont even need the #! line, although it doesnt hurt. However, there are a few problems.\nThe Catches\nFirst, if you exit, then you exit the entire shell, not something you probably meant to do. Second, you wind up polluting the variable space of the parent. For example, if your script creates a function X, with a regular shell script, that function goes away as soon as your script stops. With a source script, function X now will live forever unless you do something about it.\nNeither of these problems are insurmountable, of course, and youll see a few ways to address it in the example code in this post.\nA Simple Example\nIf you spend a lot of time on the command line, you might want to have shortcut names for directories. Whats more, you might want to execute a little script when you go to particular directories or even when you leave them.\nMy plan is to keep a simple file in ~/.proj_dirs. To keep things simple, Im assuming you can figure out the bash format:\nPROJ_DIRSdocs]=~/library/documents\nPROJ_DIRSvideo]=~/library/videos\nPROJ_DIRSarduino]=/home/alw/projects/embedded/Arduino\n. . .\nThe eventual goal is to replace the cd command (or, at least, allow for that). However, it would be a pain to have to write something like source pcd arduino every time.\nThe Alias Solution\nThe answer is pretty simple. You can create a script that can install itself as an alias. Heres the basic flow:\n#!/bin/bash\n#: This is not a bash shell script \n#: But needs to be sourced. However... \n#: Try: \n#: eval $(__project_dir.sh --__install project_dir) \nif  $1 == --__install ] # this should only be called from real script \nthen \n   aname=$2 \n   if  $aname ==  ] \n   then \n      aname=pcd \n    fi\n    echo -n alias $aname=source  \n    aname=$(realpath -s $0)\n    echo $aname \n    exit 0 \nfi \n#: Your source script goes here\n...\n\nThe idea is that if you run as a regular script with __install, it returns the alias command. You can then eval that in, for example, a startup script (like .bashrc or .profile), and then youll have the alias you want. By default, the code uses pcd, although you can set up any name you like on the command line. You could even create an alias for cd if you wanted to do that.\nWhy Not Automatic?\nYou could, of course, detect if you were running normally or as a source automatically. Turns out this is somewhat finicky across shells, although if you are sure you are always using real bash, it is feasible. For example:\nif  ${BASH_SOURCE0]} == $0 ]]\nthen\n   echo I am not sourced!\nfi\nVariables\nOnce you have the basic framework, it is easy to write the scripts to read the database (also using source) and do the actual work. However, there is a slight problem. Once you produce all the variables you need to do the work, it leaves all that pollution in your shells namespace.\nOf course, you could write a function to clean up everything you use, but thats a pain and error prone, too. A better idea is to write your code in a bash function. Then you can use local variables that will go away when the function returns. That leaves you with just your function to clear up with unset.\nThat leads to this simple framework:\n#!/bin/bash\nif  ${BASH_SOURCE0]} == $0 ]]\nthen\n   if  $1 == --__install ] # this should only be called from real script\n   then\n      aname=$2\n      if  $aname ==  ]\n      then\n        aname=pcd # default alias name\n      fi\n      echo -n alias $aname=source \n      aname=$(realpath -s $0)\n      echo $aname\n      exit 0\n   fi\n   echo You must source this script\n   exit 1\nfi\n\n#: Ok your script goes here\n\nmain() {\n. . .\n\n}\n\n#: Be sure to have this at the end\n#: Actually named with underscores in the real code\n#: But that upsets the rendering in browser\n#: Actual code at https://gist.github.com/wd5gnr/c5681f2f7072938d5d7afe7a1e3e9132\ngo() {\n   local tmprv\n   main $@\n   tmprv=$?\n   unset main, go\n   return $tmprv\n}\n\ngo $@\nreturn $?\nThe very bottom calls the go function, which calls your main function. Then the go function destroys your main function and itself. If you create new functions that you dont want to keep around, youll need to destroy them yourself. Besides, you might be creating functions you want to keep, so the framework cant decide.\nThe Whole Thing\nYou can find the entire example on GitHub. Outside of the management of the alias and the variable scope, the script is unremarkable. Note the optional scripts in the directories (.dir_enter and .dir_exit) are sourced also, so they only need to be readable (-r) not executable (-x).\nThe only other nuance is that if you enter anything as a directory that the program doesnt recognize, it assumes it is an actual directory, so you can use this to replace the cd command entirely if you want.\nSince the script can tell if it is sourced or not, it is possible to start in the source mode and then call yourself as a normal script to do work where that makes more sense. As usual with bash, there are lots of possibilities.\nWe talk about bash programming a lot around here. Debugging can be helpful, although they havent packaged the debugger for newer versions of bash lately."}