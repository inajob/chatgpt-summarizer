{"pubDate": "2024-07-18T14:00:01", "original_title": "Secrets of the Old Digital Design Titans", "link": "https://hackaday.com/2024/07/18/secrets-of-the-old-digital-design-titans/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/07/rypbh.png", "original_content": "Designing combinatorial digital circuits seems like it should be easy. After all, you can do everything you want with just AND, OR, and NOT gates. Bonus points if you have an XOR gate, but you can build everything you need for combinatorial logic with just those three components. If all you want to do is design something to turn on the light when the ignition is on AND door 1 is open OR door 2 is open, you wont have any problems. However, for more complex scenarios, how we do things has changed several times.\nIn the old days, youd just design the tubes or transistor circuits you needed to develop your logic. If you were wiring up everything by hand anyway, you might as well. But then came modules like printed circuit boards. There was a certain economy to having cards that had, say, two NOR gates on a card. Then, you needed to convert all your logic to use NOR gates (or NAND gates, if thats what you had).\nSmall-scale ICs changed that. It was easy to put a mix of gates on a card, although there was still some slight advantage to having cards full of the same kind of gate. Then came logic devices, which would eventually become FPGAs. They tend to have many of one kind of cell with plenty of logic gates on board, but not necessarily the ones you need. However, by that time, you could just tell a computer program what you wanted, and it would do the heavy lifting. That was a luxury early designers didnt have.\nBasis\nHow can you do everything with a NOR gate? Easy if you dont mind spending gates. Obviously, if I need a NOR gate, Im done. If I need an OR gate, I just feed the output of a NOR gate to all the pins of another NOR gate. The output of the second gate will be the OR of the first gates inputs.\nDeMorgans theorem tells us that if NOT(A OR B) is the same as (NOT A) AND (NOT B). It is!\n\n\n\n\nA\nB\nNOT A\nNOT B\nNOT(A OR B)\n(NOT A) AND (NOT B)\n\n\n0\n0\n1\n1\n1\n1\n\n\n0\n1\n1\n0\n0\n0\n\n\n1\n0\n0\n1\n0\n0\n\n\n1\n1\n0\n0\n0\n0\n\n\n\n\nSo you can create a NOT gate with a NOR gate (or a NAND gate) and an AND/NAND gate by mixing up NOR and NOT gates. Conversely, you can create OR/NOR gates by mixing up NAND and NOT gates. So, either way, you are covered.\n<!--more-->\nThe only problem is figuring out how to express any arbitrary expression as a bunch of NOR or NAND gates. A common way to do this is to have a product of sums or sum of products arrangement. In this context, a product is an AND gate, and a sum is an OR gate. This also works with things where you use diodes and wired AND logic, such as those you find in a programmable logic array or open collector arrangements. Think about it. A bunch of open collector outputs tied to a pull up resistor acts like a giant AND gate. Any low input causes a low output.\nSuppose you wanted to determine whether a two-bit binary number is odd or even. Yes, yes, there is an easy way to do that, but assume you dont know that yet. Lets assume the most significant bit is A and the least significant is B. Further, well use the notation A for NOT(A). AB is A AND B, while A+B is A OR B. The two odd values are 01 and 11, so we can set up another logical Y that is true when we have one of those OR the other:\nY=A'B + AB\nTroubleshooting\nThis works, of course. But if you are adept at troubleshooting digital logic, you might notice something  again, assuming that you dont already know the answer to this problem. The output, Y, doesnt really depend on A at all because we have AB or AB together. So just intuitively, we know the real answer is Y=B. No gates are needed at all!\nBut how would we figure out a minimum in a more complex example? For instance, suppose you have a four-digit number and want to drive a seven-segment LED. Segment a, for example, is the top bar of the figure 8 that forms the display. It should be on for inputs 0, 2, 3, 5, 6, 7, 8, and 9. Then, you need to do this for six other segments. Hard to see exactly how to decode that, right?\nMethods\nBefore computers would do it for you, there were two common methods to resolve things like this without resorting to brute force. The most notable of these is the Karnaugh or K map. These are great for a small number of inputs. Lets go back to the two-bit number. Our K map looks like this one.\nA two-input K map\nEach of these four cells containing a zero or one represents a single AND gate with A and B set as shown (that is, if A or B are true or false). The number in the cell is the output in that state. If you dont care about an output given a certain state of inputs, you can put an X in that square and treat them the same as a 1 if you want to (but you dont have to). By the way, these maps were made using the very useful K map solver you can find online.\nNext, you circle all the 1s that are next to each other in a rectangle including any that wrap around the edges. When you have a bunch of ones clustered together, you can wipe out the variables that change from 0 to 1 in the group.\nIn this case, the 1s cover both A and A, so we can easily see the answer is Y=B. Of course, we knew that already, but you can figure it out easily using a map like this, even if you dont already know the answer.\nFor a map this small, you dont have many options, but the number of 1s (or Xs) in an implicant  a group  must be a power of two. So you can draw a rectangle around two cells or four, but not three.\nBigger, My My\nA 3-input K map\nNote that the values of A and B only change by one bit in adjacent cells. So, a 3-variable K map looks like this is the one adjacent. Note that the left-hand column reading from top to bottom goes 00, 01, 11, 10. So, only one bit changes at a time (like a grey code).\nIn this case, the prime implicants  the parts that matter  are AB and BC. Thats because the top row strikes the C input when AB=00 and the top left 1 and the bottom left 1 join to cancel out A.\nTwo implicants: AB and BC\nEvery rectangular grouping that covers a power of two cells is a prime implicant. Sometimes, a group will cover terms that other groups will also cover. In that case, that group is not an essential prime implicant but, rather, a redundant prime implicant. But if even one square only belongs to a group, then that group is an essential prime implicant and will have a role in the final result. Sometimes, youll have several prime implicants that cover each other so that you can pick one or the other, and it doesnt matter which one. Those are known as selective prime implicants.\nAs you can see below, once you have four bits, the K map gets large. Beyond 4 bits, it is usually impractical without switching how you draw the map. Remember the 7-segment decoder example? Here is the K map for segment A of a decoder that accepts numbers from 0 to 9. Note the Xs for numbers larger than 9. If you draw circles around the groupings of 1s, you can develop the formula: Y=C+A +BD+BD. Thats much easier than trying to do it without a K map. The C is due to the right-hand columns (remember to include the Xs when it helps you). The A term is due to the bottom two rows. The other two terms pick up the stray 1s not covered by those two groups. Of course, to design an entire decoder, youd need six more K maps, one for each segment.\n\nIt is also possible to group the 0s instead of the 1s and obtain a product of sums. The process is similar but you use the 0s and not the 1s.\nThe real challenge is when you want to go beyond four bits. For that, you often go to a table-like format known as the Quine McCluskey method. Or just use a computer. We wont judge.\nOf course, if you want to make complex digital designs, you need a clock. But you can still use maps where you need combinatorial logic in a synchronous design. We mentioned you can make anything out of AND, OR, and NOT. But you can get those gates using a multiplexer or even a relay, which is, after all, just a mechanical multiplexer. Come to think of it, you can make logic gates out of darn near anything.\nBanner image by [Kit Ostrihon], demonstrating multidimensional K-maps\nThumbnail image: K-map 6,8,9,10,11,12,13,14 anti-race by [Cburnett]\n", "title": "NOR\u30b2\u30fc\u30c8\u3092\u4f7f\u3063\u305f\u30c7\u30b8\u30bf\u30eb\u56de\u8def\u8a2d\u8a08\u306e\u624b\u6cd5", "body": "\u7d44\u307f\u5408\u308f\u305b\u8ad6\u7406\u56de\u8def\u306fAND\u3001OR\u3001NOT\u30b2\u30fc\u30c8\u3060\u3051\u3067\u4f5c\u308c\u308b\u304c\u3001\u8907\u96d1\u306a\u5834\u5408\u306f\u4f55\u5ea6\u3082\u5909\u5316\u3002K\u30de\u30c3\u30d7\u3067\u6700\u5c0f\u306e\u8868\u73fe\u3092\u898b\u3064\u3051\u308b\u65b9\u6cd5\u304c\u3042\u308b\u30023\u5165\u529b\u4ee5\u4e0a\u306e\u5834\u5408\u306fQuine McCluskey\u6cd5\u3084\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30fc\u3092\u4f7f\u3046\u3002\u307e\u305f\u3001\u540c\u671f\u8a2d\u8a08\u3067\u306f\u30af\u30ed\u30c3\u30af\u304c\u5fc5\u8981\u3002", "titles": ["NOR\u30b2\u30fc\u30c8\u3092\u4f7f\u3063\u305f\u30c7\u30b8\u30bf\u30eb\u56de\u8def\u8a2d\u8a08\u306e\u624b\u6cd5", "\u8ad6\u7406\u6f14\u7b97\u3092NOR\u30b2\u30fc\u30c8\u3068NAND\u30b2\u30fc\u30c8\u3067\u8868\u73fe\u3059\u308b\u65b9\u6cd5", "\u30c7\u30b8\u30bf\u30eb\u56de\u8def\u306e\u6700\u9069\u5316: \u30ab\u30eb\u30ce\u30fc\u30de\u30c3\u30d7\u3068\u30d7\u30e9\u30a4\u30e0\u30a4\u30f3\u30d7\u30ea\u30ab\u30f3\u30c8", "\u30c7\u30b8\u30bf\u30eb\u56de\u8def\u8a2d\u8a08\u306b\u304a\u3051\u308bK\u30de\u30c3\u30d7\u306e\u6d3b\u7528\u6cd5", "\u8907\u96d1\u306a\u56de\u8def\u8a2d\u8a08\u306b\u304a\u3051\u308b\u30ad\u30e5\u30a4\u30f3\u30fb\u30de\u30af\u30e9\u30b7\u30fc\u6cd5\u306e\u5229\u7528"]}