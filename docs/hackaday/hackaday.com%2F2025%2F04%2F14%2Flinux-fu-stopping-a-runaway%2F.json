{"pubDate": "2025-04-14T17:00:11", "original_title": "Linux Fu: Stopping a Runaway", "link": "https://hackaday.com/2025/04/14/linux-fu-stopping-a-runaway/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "The best kind of Hackaday posts are the ones where there was some insurmountable problem with an elegant solution devised through deep analysis of the problem and creativity. This is not one of those posts. Im sure you are familiar with bit rot. You know, something works for a long time and then, for no apparent reason, stops working. Well, that has been biting me, and lacking the time for the creative, elegant solution, I decided to attack it with a virtual chainsaw.\nIt all started with a 2022 Linux Fu about using autokey.\nThe Problem\nI use autokey to give me emacs-style keystrokes in Web browsers and certain other programs. It intercepts keystrokes and translates them into other keystrokes. The problem is, the current Linux community hates autokey. Well, thats not strictly true. They just love Wayland more. One reason I wont switch from X11 is that I havent found a way to do something like I do with autokey. But since most of the powers-that-be have decided that X11 is bad and Wayland is good, X11 development is starting to show cracks.\nIn particular, autokey isnt in the normal repositories for my distro anymore (KDE Neon). Of course, Ive installed the latest version myself. Im perfectly capable of doing that or even building from source. But lately, Ive noticed my computer hangs, especially after sleeping for a long time. Also, after a long time, I notice that autokey just quits working. It is running but not working and I have to restart it. The memory consumption seems high when this happens.\nYou know how it is. Your system has quirks; you just live with them for a while. But eventually those paper cuts add up. I finally decided I needed to tackle the issue. But I dont really have time to go debug autokey, especially when it takes hours for the problem to manifest.\nThe Chainsaw\nIll say it upfront: Finding the memory leak would be the right thing to do. Build with debug symbols. Run the code and probe it when the problem comes up. Try to figure out what combination of X11, evdev, and whatever other hocus pocus it uses is causing this glitch.\nBut whos got time for that? I decided that instead of launching autokey directly, Id launch a wrapper script. I already had autokey removed from the KDE session so that I dont try to start it myself and then get the system restaring it also. But now I run the wrapper instead of autokey.\nSo what does the wrapper do? It watches the memory consumption of autokey. Sure enough, it goes up just a little bit all the time. When the script sees it go over a threshold it kills it and restarts it. It also restarts if autokey dies, but I rarely see that.\nWhats Memory Mean?\nThe problem is, how do you determine how much memory a process is using? Is it the amount of physical pages it has? The virtual space? What about shared libraries? In this case, I dont really care as long as I have a number that is rising all the time that I can watch.\nThe /proc file system has a directory for each PID and theres a ton of info in there. One of them is an accounting of memory. If you look at /proc/$PID/smaps for some program youll see something like this:\n\n00400000-00420000 r--p 00000000 fd:0e 238814592 /usr/bin/python3.12\nSize: 128 kB\nKernelPageSize: 4 kB\nMMUPageSize: 4 kB\nRss: 128 kB\nPss: 25 kB\nPss_Dirty: 0 kB\nShared_Clean: 128 kB\nShared_Dirty: 0 kB\nPrivate_Clean: 0 kB\nPrivate_Dirty: 0 kB\nReferenced: 128 kB\nAnonymous: 0 kB\nKSM: 0 kB\nLazyFree: 0 kB\nAnonHugePages: 0 kB\nShmemPmdMapped: 0 kB\nFilePmdMapped: 0 kB\nShared_Hugetlb: 0 kB\nPrivate_Hugetlb: 0 kB\nSwap: 0 kB\nSwapPss: 0 kB\nLocked: 0 kB\nTHPeligible: 0\nVmFlags: rd mr mw me sd \n00420000-00703000 r-xp 00020000 fd:0e 238814592 /usr/bin/python3.12\nSize: 2956 kB\nKernelPageSize: 4 kB\nMMUPageSize: 4 kB\nRss: 2944 kB\nPss: 595 kB\nPss_Dirty: 0 kB\nShared_Clean: 2944 kB\nShared_Dirty: 0 kB\nPrivate_Clean: 0 kB\nPrivate_Dirty: 0 kB\n. . .\n\nNote that there is a section for each executable and shared object along with lots of information. You can get all the PSS (proportional set size) numbers for each module added together like this (among other ways):\n\n\ncat /proc/$PID/smaps | grep -i pss | awk {Total+=$2} END { print Total}\n\n\nBuilding the Chainsaw\nSo armed with that code, it is pretty easy to just run the program, see if it is eating up too much memory, and restart it if it is. I also threw in some optional debugging code.\n\n#!/bin/bash\n#- Run autokey, kill it if it gets too big\n#- whats too big? $MLIMIT\nMLIMIT=500000 \n#- how often to check (seconds)\nPOLL=10\n\n#- Print debug info if you want\nfunction pdebug {\n#- comment out if you dont want debugging. Leave in if you do\n#- echo $1 $2 $3 $4\n}\n\nwhile true   # do forever\ndo\n   PID=$(pgrep autokey-qt)  # find autokey\n   pdebug PID,$PID\n   if  ! -z $PID ]   # if it is there\n   then\n      # get the memory size\n      PSS=$(cat /proc/$PID/smaps | grep -i pss | awk {Total+=$2} END { print Total})\n      pdebug PSS, $PSS\n      echo $PSS /tmp/autokey-current.log\n      # too big? \n      if  $PSS -gt $MLIMIT ]\n      then\n         pdebug Kill\n         echo Killed /tmp/autokey-current.log\n         # save old log before we start another\n         cp /tmp/autokey-current.log /tmp/autokey-$PID.log\n         kill $PID\n         PID=\n         sleep 2\n      fi\n   fi\n   if  -z $PID ]\n   then\n      # if died, relaunch\n      pdebug Launch\n      autokey-qt  21 /tmp/autokey-current.log\n   fi\n   pdebug Sleep\n   sleep $POLL\ndone\n\nIn practice, youll probably want to remove the cp command that saves the old log, but while troubleshooting, it is good to see how often the process is killed. Running this once with a big number gave me an idea that PSS was about 140,000 but rising every 10 seconds. So when it gets to 500,000, it is done. That seems to work well. Obviously, youd adjust the numbers for whatever you are doing.\nBad Chainsaw\nThere are lots of ways this could have been done. A systemd timer, for example. Maybe even a cgroup. But this works, and took just a few minutes. Sure, a chainsaw is a lot to just cut a 24, but then again, it will go through it like a hot knife through butter.\nI did consider just killing autokey periodically and restarting it. The problem is I work odd hours sometimes, and that means Id have to do something like tie it to the screensaver. But I agree there are dozens of ways to do this, including to quit using autokey. What would your solution be? Let us know in the comments. Have you ever resorted to a trick this dirty?"}