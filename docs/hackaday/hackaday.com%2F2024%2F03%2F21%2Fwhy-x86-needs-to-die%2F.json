{"pubDate": "2024-03-21T17:00:08", "original_title": "Why x86 Needs To Die", "link": "https://hackaday.com/2024/03/21/why-x86-needs-to-die/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2022/11/old-processors-featured.jpg", "youtube": "https://www.youtube.com/watch?v=vaMxTSm53UU", "original_content": "As Im sure many of you know, x86 architecture has been around for quite some time. It has its roots in Intels early 8086 processor, the first in the family. Indeed, even the original 8086 inherits a small amount of architectural structure from Intels 8-bit predecessors, dating all the way back to the 8008. But the 8086 evolved into the 186, 286, 386, 486, and then they got names: Pentium would have been the 586.\nAlong the way, new instructions were added, but the core of the x86 instruction set was retained. And a lot of effort was spent making the same instructions faster and faster. This has become so extreme that, even though the 8086 and modern Xeon processors can both run a common subset of code, the two CPUs architecturally look about as far apart as they possibly could.\nSo here we are today, with even the highest-end x86 CPUs still supporting the archaic 8086 real mode, where the CPU can address memory directly, without any redirection. Having this level of backwards compatibility can cause problems, especially with respect to multitasking and memory protection, but it was a feature of previous chips, so its a feature of current x86 designs. And theres more!\nI think its time to put a lot of the legacy of the 8086 to rest, and let the modern processors run free.\nSome Key Terms\nTo understand my next arguments, you need to understand the very basics of a few concepts. Modern x86 is, to use the proper terminology, a CISC, superscalar, out-of-order Von Neumann architecture with speculative execution. What does that all mean?\nVon Neumann architectures are CPUs where both program and data exist in the same address space. This is the basic ability to run programs from the same memory in which regular data is stored; there is no logical distinction between program and data memory.\nSuperscalar CPU cores are capable of running more than one instruction per clock cycle. This means that an x86 CPU running at 3 GHz is actually running more than 3 billion instructions per second on average. This goes hand-in-hand with the out-of-order nature of modern x86; the CPU can simply run instructions in a different order than they are presented if doing so would be faster.\nFinally, theres the speculative keyword causing all this trouble. Speculative execution is to run instructions in a branching path, despite it not being clear whether said instructions should be run in the first place. Think of it as running the code in an if statement before knowing whether the condition for said if statement is true and reverting the state of the world if the condition turns out to be false. This is inherently risky territory because of side-channel attacks.\nBut What is x86 Really?\n8086 block diagram by Harkonnen2\nAMDs Zen 4 architecture block diagram\nHere, you can see block diagrams of the microarchitectures of two seemingly completely unrelated CPUs. Dont let the looks deceive you; the Zen 4 CPU still supports real mode; it can still run 8086 programs.\nThe 8086 is a much simpler CPU. It takes multiple clock cycles to run instructionsa: anywhere from 2 to over 80. One cycle is required per byte of instruction and one or more cycles for the calculations. There is also no concept of superscalar or out-of-order here; everything takes a predertermined amount of time and happens strictly in-order.\nBy contrast, Zen 4 is a monster: Not only does it have four ALUs, it has three AGUs as well. Some of you may have heard of the Arithmetic and Logic Unit before, but Address Generation Unit is less well known. All of this means that Zen 4 can, under perfect conditions, perform four ALU operations and three load/store operations per clock cycle. This makes Zen 4 a factor of two to ten faster than the 8086 at the same clock speed. If you factor in clock speed too, it becomes closer to roughly five to seven orders of magnitude. Despite that, the Zen 4 CPUs still supports the original 8086 instructions.\nWhere the Problem Lies\nThe 8086 instruction set is not the only instruction set that modern x86 supports. There are dozens of instruction sets from the well-known floating-point, SSE, AVX and other vector extensions to the obscure PAE (for 32-bit x86 to have wider addresses) and vGIF (for interrupts in virtualization). According to [Stefan Heule], there may be as many as 3600 instructions. Thats more than twenty times as many instructions as RISC-V has, even if you count all of the most common RISC-V extensions.\nThese instructions come at a cost. Take, for example one of x86s oddball instructions: mpsadbw. This instruction is six to seven bytes long and compares how different a four-byte sequence is in multiple positions of an eleven-byte sequence. Doing so takes at least 19 additions but the CPU runs it in just two clock cycles. The first problem is the length. The combination of the six-to-seven byte instruction length and no alignment requirements makes fetching the instructions a lot more expensive to do. This instruction also comes in a variant that accesses memory, which complicates decoding of the instruction. Finally, this instruction is still supported by modern CPUs, despite how rare it is to see it being used. All that uses up valuable space in cutting-edge x86 CPUs.\nIn RISC architectures like MIPS, ARM, or RISC-V, the implementation of instructions is all hardware; there are dedicated logic gates for running certain instructions. The 8086 also started this way, which would be an expensive joke if that was still the case. Thats where microcode comes in. You see, modern x86 CPUs arent what they seem; theyre actually RISC CPUs posing as CISC CPUs, implementing the x86 instructions by translating them using a mix of hardware and microcode. This does give x86 the ability to update its microcode, but only to change the way existing instructions work, which has mitigated things like Spectre and Meltdown.\nFortunately, It Can Get Worse\nLets get back to those pesky keywords: speculative and out-of-order. Modern x86 runs instructions out-of-order to, for example, do some math while waiting for a memory access. Lets assume for a moment thats all there is to it. When faced with a divide that uses the value of rax followed by a multiply that overwrites rax, the multiply must logically be run after the divide, even though the result of the multiply does not depend on that of the divide. Thats where register renaming comes in. With register renaming, both can run simultaneously because the rax that the divide sees is a different physical register than the rax that the multiply writes to.\nThis acceleration leaves us with two problems: determining which instructions depend on which others, and scheduling them optimally to run the code as fast as possible. These problems depend on the particular instructions being run and their solution logic gets more complicated the more instructions exist. The x86 instruction encoding format is so complex an entire wiki page is needed to serve as a TL;DR. Meanwhile, RISC-V needs only two tables (1) (2) to describe the encoding of all standard instructions. Needless to say, this puts x86 at a disadvantage in terms of decoding logic complexity.\nChange is Coming\nOver time, other instruction sets like ARM have been eating at x86s market share. ARM is completely dominant in smartphones and single-board computers, it is growing in the server market, and it has even become the primary CPU architecture in Apples devices since 2020. RISC-V is also progressively getting more popular, becoming the most widely adopted royalty-free instruction set to date. RISC-V is currently mostly used in microcontrollers but is slowly growing towards higher-power platforms like single-board computers and even desktop computers. RISC-V, being as free as it is, is also becoming the architecture of choice for todays computer science classes, and this will only make it more popular over time. Why? Because of its simplicity.\nConclusion\nThe x86 architecture has been around for a long time: a 46-year long time. In this time, its grown from the simple days of early microprocessors to the incredibly complex monolith of computing we have today.\nThis evolution has taken its toll, though, by restricting one of the biggest CPU platforms to the roots of a relatively ancient instruction set, which doesnt even benefit from small code size like it did 46 years ago. The complexities of superscalar, speculative, and out-of-order execution are heavy burdens on an instruction set that is already very complex by definition and the RISC-shaped grim reapers named ARM and RISC-V are slowly catching up.\nDont get me wrong: I dont hate x86 and Im not saying it has to die today. But one thing is clear: The days of x86 are numbered.", "title": "x86\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u306e\u9032\u5316\u3068\u8ab2\u984c", "body": "x86\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u306f8086\u30d7\u30ed\u30bb\u30c3\u30b5\u304b\u3089\u59cb\u307e\u308a\u3001\u9032\u5316\u3092\u7d9a\u3051\u3066\u304d\u305f\u3002\u304c\u3001\u73fe\u4ee3\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u306f8086\u3068\u306f\u5927\u304d\u304f\u7570\u306a\u308b\u3002\u73fe\u4ee3\u306ex86\u306f\u53e4\u3044\u907a\u7523\u306b\u4f9d\u5b58\u3057\u904e\u304e\u3066\u304a\u308a\u3001ARM\u3084RISC-V\u3068\u3044\u3063\u305f\u65b0\u305f\u306a\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u306b\u53d6\u3063\u3066\u4ee3\u308f\u3089\u308c\u308b\u6642\u304c\u6765\u3066\u3044\u308b\u3002", "titles": ["x86\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u306e\u9032\u5316\u3068\u8ab2\u984c", "8086\u30ea\u30a2\u30eb\u30e2\u30fc\u30c9\u304b\u3089\u306e\u8131\u5374", "\u73fe\u4ee3x86\u304a\u3088\u3073RISC\u30d7\u30ed\u30bb\u30c3\u30b5\u306e\u6bd4\u8f03", "x86\u306e\u591a\u6a5f\u80fd\u547d\u4ee4\u30bb\u30c3\u30c8\u306e\u8ab2\u984c", "x86\u306e\u672a\u6765\uff1aARM\u3068RISC-V\u306e\u53f0\u982d"]}