{"pubDate": "2023-06-04T11:00:26", "original_title": "C++17\u2019s Useful Features for Embedded Systems", "link": "https://hackaday.com/2023/06/04/c17s-useful-features-for-embedded-systems/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2017/05/c.jpg", "original_content": "Although the world of embedded software development languages seem to span somewhere between ASM and C89 all the way to MicroPython, there is a lot to be said for a happy medium between ease of development and features that makes the software more robust without adding overhead or bloat to the final firmware image.\nThis is where C++ has objectively many advantages over even C99, and as [\u00c7a\u011flayan D\u00f6kme] argues in a recent blog post C++17 adds many developer critter comforts to C++90 and the more recent C++11 C++14 standards.\nFirst stepping back a generation (technically two, with C++20 also being a thing already), the addition of binary literals (e.g. 0b1010'1100) in C++14 and the expanded use of constexpr is addressed, with the latter foreshadowing C++17s increased focus on compile time optimizations. A new attribute in C++17 that is part of this is [[nodiscard]], which when added before to the return type of a function or method requires the return value to be used in some manner, much like with functions in Ada (contrasted with procedures).\nAs [\u00c7a\u011flayan] notes, the biggest strength of compile-time checks is that it can save a lot of deploy-test-fix round-trips, with the total number of issues caught after deployment that could have been caught during compilation ideally being zero. Here C++17 streamlines the static_assert() mechanism and simplifies using if constexpr to instantiate code depending on compile-time conditions. Beyond compile-time optimizations there are a few other niceties, such as C++17 guaranteeing copy elision (return value optimization) when an object is returned directly, which is a welcome feature in hard real-time environments.\nWith today even MCUs having enough grunt to run multi-threaded applications and potentially firmware compiled from a many-thousand LoC codebase, picking a programming language that assists the developer with such an arduous task is very important, with Ada being the primary choice for high-reliability embedded platforms, but C++ along with C enjoying the most widespread (free) compiler support. Even if C++ isnt supported on every single MCU out there (8051-based and most PIC MCUs mostly), whenever it is an option, its a pretty solid choice, especially with knowledge of these new language features.", "title": "Embedded software development\u306b\u304a\u3051\u308bC++\u306eadvantages\u3068\u306f\uff1f\u3000", "body": "C++17 enhances developer comforts and robustness without adding overhead or bloat to final firmware image. It adds many advantages and features such as binary literals, constexpr, and [[nodiscard]]. It assists the developer in an arduous task, especially in a hard real-time environment. C++ is a pretty solid choice for embedded platforms.", "titles": ["Embedded software development\u306b\u304a\u3051\u308bC++\u306eadvantages\u3068\u306f\uff1f\u3000", "C++14\u304b\u3089C++17\u306b\u304a\u3051\u308bnew attribute\u300c[[nodiscard]]\u300d\u3068\u306f\uff1f", "C++17\u304c\u3082\u305f\u3089\u3059compile-time optimizations\u306e\u4e88\u6e2c\u3068\u306f\uff1f", "C++17\u3067\u6539\u5584\u3055\u308c\u305f\u30b3\u30fc\u30c9\u6761\u4ef6\u5206\u5c90\u306b\u3088\u308b\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u5c55\u958b\u306b\u3064\u3044\u3066", "\u9ad8\u4fe1\u983c\u306aembedded\u74b0\u5883\u3067\u306e\u4e3b\u8981\u8a00\u8a9eAda\u3068C++\u306e\u6bd4\u8f03\u306b\u3064\u3044\u3066"]}