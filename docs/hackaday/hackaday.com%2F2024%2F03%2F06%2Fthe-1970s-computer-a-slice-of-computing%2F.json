{"pubDate": "2024-03-06T18:00:02", "original_title": "The 1970s Computer: A Slice of Computing", "link": "https://hackaday.com/2024/03/06/the-1970s-computer-a-slice-of-computing/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2021/02/Dual.jpg", "original_content": "What do the HP-1000 and the DEC VAX 11/730 have in common with the video games Tempest and Battlezone? More than you might think. All of those machines, along with many others from that time period, used AM2900-family bit slice CPUs.\nThe bit slice CPU was a very successful product that could only have existed in the 1970s. Today, if you need a computer system, there are many CPUs and even entire systems on a chip to choose from. You can also get many small board-level systems that would probably do anything you want. In the 1960s, you had no choices at all. You built circuit boards with gates on the using transistors, tubes, relays, or  maybe  small-scale IC gates. Then you wired the boards up.\nIt didnt take a genius to realize that it would be great to offer people a CPU chip like you can get today. The problem is the semiconductor technology of the day wouldnt allow it  at least, not with any significant amount of resources. For example, the Motorola MC14500B from 1977 was a one-bit microprocessor, and while that had its uses, it wasnt for everyone or everything.\nThe Answer\nThe answer was to produce as much of a CPU as possible in a chip and make provisions to use multiple chips together to build the CPU. Thats exactly what AMD did with the AM2900 family. If you think about it, what is a CPU? Sure, there are variations, but at the core, theres a place to store instructions, a place to store data, some way to pick instructions, and a way to operate on data (like an ALU  arithmetic logic unit). Instructions move data from one place to another and set the state of things like I/O devices, ALU operations, and the like.\n\nBasic bitslice CPU from the AMD data book\nSure, thats an oversimplification, but it can be stretched to describe most traditional CPUs. The AMD chips provided a 4-bit data path that could be chained together. Other chips in the family could manage memory (including, optionally, DMA) and take care of bookkeeping between slices. You could build an 8-bit machine with two slices, a 12-bit machine with three, and so on.\nNot only did this allow fewer ICs than using conventional chips, it also allowed bipolar logic which  especially at the time  was faster but not as dense as NMOS or CMOS. Chips like the AM2900 family let you create flexible CPUs. They fit your application and ran fast compared to what you might be able to do using other methods.\nMicrocoding\nMicrocode is common in many CPUs, and bitslice CPUs were no exception. For example, you might have a very long microcode instruction where each register has a separate read and write line. If you had eight registers, thats 16 bits just in those controls. Then you might also have a function code (4 bits) and a bit indicating if the condition codes should update. Now, each instruction is 21 bits. Thats longer than you want for, say, an 8-bit machine, so you define instructions that execute microcode.\nPinout of AM2901\nFor example, an instruction to add register A to register B and leave the result in B might have three microcode steps. The first would gate register A and B to the data bus and assert the code that makes the ALU add. Then, the second instruction would put the result on the databus and command the B register to read the databus. The final microcode instruction would jump to the main part of the microcode that reads the next instruction and continues the program.\nThats how youd typically design a bitslice CPU. An AM2909 , AM2910, or AM2911 (microprogram sequencers) would address a microprogram store ROM, which would feed commands to an array of AM2901 chips. The 40-pin AM2901 came in several variations (e.g., AM2901B) each having technology improvements to make them smaller and faster.\nThe microprogram store would then orchestrate the fetching of instructions and their execution. Presumably, the microprogram was relatively small compared to the real software, so your ROM with the microcode could be smaller than the ROM containing your actual application.\nCooperation\nOf course, you cant do everything just by adding another chip. They have to cooperate. For example, there is an F output on each chip that is open collector. You tie all the F outputs together with a pull-up resistor. If any CPU slice has a non-zero result, it will pull down the F output. Therefore, if the F output is high, then the entire result (however many bits that may be) must be zero.\nHandling carry is also a problem. If your first slice adds 1111+0001 the answer isnt really 0000. It is 0000 + a carry. You can simply wire up each Cn+4 output to the next chips Cn input to get ripple carry, but that will create a speed penalty that gets worse as you add slices. You can also use an AM2902 to look ahead for better performance. Each 2902 could handle four slices or 16 bits. If you wanted to go beyond that, you could use one AM2902 to look ahead for up to another four AM2902s, each of which handled four CPU slices. Presumably, it would be possible to extend this scheme further if you wanted to go beyond 64 bits, although in 1975, that might not have been your biggest problem with building a machine that large.\nShifting and multiplication required cooperation, too. It was common to use a multiplexer at each end of the chain to determine the source of new bits when shifting. It just depended on what you needed.\nCustomization\nThats one interesting thing about using bit slice. You could design just what you needed. Why build a 32-bit machine if you needed 24-bits for the task at hand? Why use multiplexers to enable a rotate instruction that you will never use?\nThese days, we take a building block and make it fit our problem. With bitslice, you made a CPU that exactly fit what you needed. There were many tidbits about how to do different operations like fetching instructions, multiplying, or byte swapping in the AM2900 data book.\nThat data book also shows the chips youd need, like AM2902s or the 48-pin AM2903 Superslice with extendable registers, multipliers, division, and other special circuits onboard.\nEvolution\nThe AM2900 family was very successful. The original AM2901 started out on a very large die using low-power Schottky and could operate at 80 nanoseconds. By 1978  three years later, the AM2901B die was less than half the size and could handle 50 nanoseconds. By 1981, the AM2901C used ECL internally and could do 37 nanoseconds on the same die. By 1979, you could even get a floating point coprocessor (the AMD9511).\nThese were simple devices because you needed multiple chips to support it and multiple AM2901s to do anything bigger than four bits. The original AM2901, for example, had only 540 gates onboard. Yet they found their way into everything from workstations and music synthesizers to video games. Because of their popularity, there were many second-source suppliers for the device, and it is still possible to find new old stock. There were even Soviet copies produced.\nMore Bitslice\nMany of the CPUs made with the AM2900 were proprietary or military. But if you want to see one that has a good bit of documentation, heres a 1980 Masters thesis on implementing a Nova 1200-compatible CPU using the technology  well, part of one, anyway.\nThe AM2900 wasnt the only game in town. In 1974, National Semiconductors IMP and Intels 3000-series were available. In addition, Motorola, Texas Instruments, Fairchild, Raytheon, and others made similar devices. But for various reasons, the AM2900 is what most people think of when they remember bitslice CPUs. In fact, the Masters thesis about the Nova CPU also has a table of other bitslice tech and the reason they didnt use any of the other ones. For example, some of the devices used PMOS, which was slow. Others used ECL, a fast technology with a deserved reputation for being difficult to use. Another thesis from 1976 has similar logic for selecting the AM2900.\nWant more?\n[Ken Shirriff] took an ECL variant of the AM2901 apart. Theres also a book from 1980 you can read. There is also a ton of documents on a Gopher server (not kidding). If your browser doesnt handle Gopher  and that wont surprise us  try one of the many Gopher proxies. The 16-bit computer design example is especially worth a look. Want a more complex example? Heres a blazing-fast 8080 CPU built with bitslice. Over on Hackaday.io, [zpekic] recently built this 8080 and ran tiny Basic on it (see the video if you dont believe it).\n\nThe Xerox Star 8010 used the AM2900 in 1981. Cost less than $17,000! Luckily, you can emulate one if you like. For that matter, you can sort of emulate the AM2900 using Java, although it might not work for every possible design (tip: download from the releases).", "title": "1970 \u5e74\u4ee3\u306e AM2900 \u30d5\u30a1\u30df\u30ea\u30fc\uff1a\u30a4\u30ce\u30d9\u30fc\u30c6\u30a3\u30d6\u306a\u30d3\u30c3\u30c8\u30b9\u30e9\u30a4\u30b9 CPU \u306e\u6b74\u53f2", "body": "HP-1000\u304a\u3088\u3073DEC VAX 11/730\u306f\u3001\u30d3\u30c7\u30aa\u30b2\u30fc\u30e0Tempest\u3068Battlezone\u3068\u5171\u901a\u70b9\u304c\u3042\u308b\u3002\u3053\u308c\u3089\u306e\u30de\u30b7\u30f3\u306fAM2900\u30d5\u30a1\u30df\u30ea\u30fc\u306e\u30d3\u30c3\u30c8\u30b9\u30e9\u30a4\u30b9CPU\u3092\u4f7f\u7528\u3002\u305d\u308c\u306f1970\u5e74\u4ee3\u306e\u88fd\u54c1\u3067\u3042\u308a\u3001\u591a\u304f\u306e\u30d3\u30c3\u30c8\u30b9\u30e9\u30a4\u30b9CPU\u306e\u8a73\u7d30\u304c\u63d0\u4f9b\u3055\u308c\u3066\u3044\u308b\u3002", "titles": ["1970 \u5e74\u4ee3\u306e AM2900 \u30d5\u30a1\u30df\u30ea\u30fc\uff1a\u30a4\u30ce\u30d9\u30fc\u30c6\u30a3\u30d6\u306a\u30d3\u30c3\u30c8\u30b9\u30e9\u30a4\u30b9 CPU \u306e\u6b74\u53f2", "AMD \u306e AM2900 \u30d5\u30a1\u30df\u30ea\u30fc\uff1a\u67d4\u8edf\u6027\u3092\u6301\u3064\u30d3\u30c3\u30c8\u30b9\u30e9\u30a4\u30b9 CPU \u306e\u7279\u5fb4", "\u9032\u5316\u3059\u308b\u30c6\u30af\u30ce\u30ed\u30b8\u30fc\uff1aAM2900 \u30d5\u30a1\u30df\u30ea\u30fc\u306e CPU \u306f\u3069\u306e\u3088\u3046\u306b\u9032\u5316\u3057\u305f\u304b", "\u30d3\u30c3\u30c8\u30b9\u30e9\u30a4\u30b9 CPU \u306e\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\uff1a\u5fc5\u8981\u306b\u5408\u308f\u305b\u3066\u8a2d\u8a08\u3055\u308c\u305f\u67d4\u8edf\u306a CPU", "1980 \u5e74\u4ee3\u306b\u6d3b\u8e8d\u3057\u305f AM2900 \u30d3\u30c3\u30c8\u30b9\u30e9\u30a4\u30b9 CPU\uff1a\u305d\u306e\u6b74\u53f2\u3068\u9032\u5316"]}