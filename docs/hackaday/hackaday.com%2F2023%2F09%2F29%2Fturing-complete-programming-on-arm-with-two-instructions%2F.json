{"pubDate": "2023-09-29T11:00:08", "original_title": "Turing Complete Programming on ARM With Two Instructions", "link": "https://hackaday.com/2023/09/29/turing-complete-programming-on-arm-with-two-instructions/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2022/01/Esoteric.jpg", "original_content": "There are many questions that can be asked for software projects, with most of these questions starting with Why?. This is true for the challenge of proving that cascading stylesheets are Turing-complete, or that you dont need all those fancy ISA bits of an ARM processors when you already got the LDM and STM commands in the 32-bit ISA. What originally started off as a bit of a running gag in a group of developers led to [Kellan Clark] implementing a Turing-complete computer and a functioning interpreter using nothing but these two opcodes.\nAdding some Brainf**k to your ARM, inside your GBA.\nThese two opcodes essentially allow the storing or reading of data into memory from any combination of the 16 general-purpose registers (GPRs). This makes them both extremely versatile and also extremely open to abuse like in this example. For a straightforward implementation that could prove the concept, [Kellan] decided to pick one of everyones favorite esoteric programming languages: Brainf**k (descrambling algorithm: s/s/u), creating the charmingly titled Armf**k that allows anyone to write BF programs for any suitable ARM processor, like the ARM7TDMI in the Game Boy Advance that [Kellan] targeted.\nAs a proof of concept its unquestioningly intriguing, and a great example of how the most powerful parts of any ISA are those that move data around. After all, as anyone who writes ASM and C knows, computers are just machines that can copy bytes around really fast to make stuff happen. Mind-blowing examples like these serve to illustrate that point quite well.\nTip kindly provided by [eeucalyptus]."}