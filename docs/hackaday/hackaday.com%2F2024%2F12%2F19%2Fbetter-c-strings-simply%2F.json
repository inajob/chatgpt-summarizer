{"pubDate": "2024-12-19T16:30:30", "original_title": "Better C Strings, Simply", "link": "https://hackaday.com/2024/12/19/better-c-strings-simply/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/12/string.png", "original_content": "If you program in C, strings are just in your imagination. What you really have is a character pointer, and we all agree that a string is every character from that point up until one of the characters is zero. While thats simple and useful, it is also the source of many errors. For example, writing a 32-byte string to a 16-byte array or failing to terminal a string with a zero byte. [Thasso] has been experimenting with a different way to represent strings that is still fairly simple but helps keep things straight.\nLike many other languages, this setup uses counted strings and string buffers. You can read and write to a string buffer, but strings are read-only. In either case, there is a length for the contents and, in the case of the buffer, a length for the entire buffer.\n\nWeve seen schemes like this before and [Thasso] borrowed the idea from [Chris Wellons]. The real issue, of course, is that you now have to rewrite or wrap any normal C functions you have that take or return strings. Weve also seen this done where the length is stored ahead of the string so you dont have a field for the character pointer:\n\n\nstruct str\n{\nsz len;\nchar dat0];\n};\n\n\nEven though the prototypical structure has a zero length, the actual structure can be larger.\nIf you are worried about efficiency, [Thasso] and [Wellons] both point out that modern compilers are good at handling small structures, so maybe thats an advantage to not putting the data directly into the struct. If you need characters larger than one byte, the [Wellons] post has some thoughts on that, too.\nThis is all old hat on C++, of course. No matter how you encode your strings, you should probably avoid the naughty ones. Passwords, too."}