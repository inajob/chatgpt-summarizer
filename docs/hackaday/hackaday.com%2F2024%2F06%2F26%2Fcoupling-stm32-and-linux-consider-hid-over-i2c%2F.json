{"pubDate": "2024-06-26T08:00:43", "original_title": "Coupling STM32 And Linux? Consider HID over I2C", "link": "https://hackaday.com/2024/06/26/coupling-stm32-and-linux-consider-hid-over-i2c/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/06/hadimg_stm32_i2chid_feat.png", "original_content": "If youre pairing a tiny Linux computer to a few peripherals  perhaps youre building a reasonably custom Pi-powered device  its rightfully tempting to use something like an STM32 for all your low-level tasks, from power management to reading keyboard events.\nNow, in case you were wondering how to tie the two together, consider HID over I2C, its a standardized protocol with wide software and peripheral support, easily implementable and low-power. Whats more, [benedekkupper] gives you an example STM32 project with a detailed explanation on how you too can benefit from the protocol.\nThere are several cool things about this project. For a start, its code is generic enough that it will port across the entire STM32 lineup nicely. Just change the pin definitions as needed, compile it, flash it onto your devboard and experiment away. Need to change the descriptors? The hid-rdf library used lets you define a custom descriptor super easily, none of that building a descriptor from scratch stuff, and it even does compile-time verification of the descriptor!\nThe project has been tested with a Raspberry Pi 400, and [benedekkupper] links a tutorial on quickly adding your I2C-HID device on an Linux platform; all you need is DeviceTree support. Wondering whats possible with HID? Weve seen hackers play with HID aplenty here, and hacking on the HID standard isnt just for building keyboards. It can let you automate your smartphone, reuse a laptop touchpad or even a sizeable Wacom input surface, liberate extra buttons on gamepads, or build your own touchscreen display.", "title": "STM32\u3092\u4f7f\u7528\u3057\u305fHID over I2C\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u5b9f\u88c5\u65b9\u6cd5", "body": "STM32\u3092\u4f7f\u3063\u3066Raspberry Pi \u3068HID over I2C\u3092\u7d44\u307f\u5408\u308f\u305b\u308b\u65b9\u6cd5\u3002\u4f4e\u96fb\u529b\u3067\u5b9f\u88c5\u3057\u3001\u30c7\u30d0\u30a4\u30b9\u3092\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u3059\u308b\u624b\u9806\u304c\u8a73\u7d30\u306b\u8aac\u660e\u3055\u308c\u3066\u3044\u308b\u3002HID\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u3067\u3001\u30ad\u30fc\u30dc\u30fc\u30c9\u30a4\u30d9\u30f3\u30c8\u306e\u8aad\u307f\u53d6\u308a\u306a\u3069\u306e\u4f4e\u30ec\u30d9\u30eb\u30bf\u30b9\u30af\u3092STM32\u3067\u51e6\u7406\u3067\u304d\u308b\u3002", "titles": ["STM32\u3092\u4f7f\u7528\u3057\u305fHID over I2C\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u5b9f\u88c5\u65b9\u6cd5", "\u30e9\u30ba\u30d9\u30ea\u30fc\u30d1\u30a4\u3068STM32\u306e\u7d44\u307f\u5408\u308f\u305b\u306b\u3088\u308b\u96fb\u5b50\u5de5\u4f5c\u30d7\u30ed\u30b8\u30a7\u30af\u30c8", "STM32\u3067\u306e\u30ab\u30b9\u30bf\u30e0HID\u30c7\u30d0\u30a4\u30b9\u306e\u4f5c\u6210\u65b9\u6cd5", "\u9ad8\u5ea6\u306a\u96fb\u5b50\u5de5\u4f5c\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u5411\u3051\u305fSTM32\u306e\u6d3b\u7528\u65b9\u6cd5", "HID over I2C\u3092\u4f7f\u7528\u3057\u305f\u4f4e\u6d88\u8cbb\u96fb\u529b\u30c7\u30d0\u30a4\u30b9\u306e\u69cb\u7bc9"]}