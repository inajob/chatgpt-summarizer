{"pubDate": "2026-01-09T15:00:50", "original_title": "NPAPI and the Hot-Pluggable World Wide Web", "link": "https://hackaday.com/2026/01/09/npapi-and-the-hot-pluggable-world-wide-web/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/08/SmallWeb.jpg", "original_content": "In todays Chromed-up world it can be hard to remember an era where browsers could be extended with not just extensions, but also with plugins. Although for those of us who use traditional Netscape-based browsers like Pale Moon the use of plugins has never gone away, for the rest of the WWWs users their choice has been limited to increasingly more restrictive browser extensions, with Googles Manifest V3 taking the cake.\nAlthough most browsers stopped supporting plugins due to security concerns, this did nothing to address the need for executing code in the browser faster than the sedate snails pace possible with JavaScript, or the convenience of not having to port native code to JavaScript in the first place. This led to various approaches that ultimately have culminated in the WebAssembly (WASM) standard, which comes with its own set of issues and security criticisms.\nOther than Netscapes Plugin API (NPAPI) being great for making even 1990s browsers ready for 2026, there are also very practical reasons why WASM and JavaScript-based approaches simply cannot do certain basic things.\n\nIts A JavaScript World\nOne of the Achilles heels of the plugin-less WWW is that while TCP connections are easy and straightforward, things go south once you wish to do anything with UDP datagrams. Although there are ugly ways of abusing WebRTC for UDP traffic with WASM, ultimately you are stuck inside a JavaScript bubble inside a browser, which really doesnt want you to employ any advanced network functionality.\nTechnically there is the WASI Sockets proposal that may become part of WASM before long, but this proposal comes with a plethora of asterisks and limitations attached to it, and even if it does work for your purposes, you are limited to whatever browsers happen to implement it. Meanwhile with NPAPI you are only limited by what the operating system can provide.\nNPAPI plugin rendering YouTube videos in a Netscape 4.5 browser on Windows 98. (Credit: Throaty Mumbo, YouTube)\nWith NPAPI plugins you can even use the traditional method of directly rendering to a part of the screen, removing any need for difficult setup and configuration beyond an HTML page with an embed tag that set up said rendering surface. This is what Macromedia Flash and the VLC media player plugin use, for example.\nThese limitations of a plugin-less browser are a major concern when youd like to have, say, a client running in the browser that wishes to use UDP for something like service discovery or communication with UDP-based services. This was a WASM deal breaker with a project of mine, as UDP-based service discovery is essential unless I wish to manually mash IP addresses into an input field. Even the WASI Sockets dont help much, as retrieving local adapter information and the like are crucial, as is UDP broadcast.\nMeanwhile the NPAPI version is just the existing client dynamic library, with a few NPAPI-specific export functions tagged onto it. This really rubs in just how straightforward browser plugins are.\nImplementing It\nWith ones mind set on implementing an NPAPI plugin, and ignoring that Pale Moon is only one of a small handful of modern browsers to support it, the next question is where to start. Sadly, Mozilla decided to completely obliterate every single last trace of NPAPI-related documentation from its servers. This leaves just the web.archive.org backup as the last authoritative source.\nFor me, this provided also a bit of an obstacle, as I had originally planned to first do a quick NPAPI plugin adaptation of the libnymphcast client library project, along with a basic front-end using the scriptable interface and possibly also direct rendering of a Qt-based GUI. Instead, I would spend a lot of time piecing back together the scraps of documentation and sample projects that existed when I implemented my last NPAPI plugin back in about 2015 or 2016, back when Mozillas MDN hadnt yet carried out the purge.\nOne of the better NPAPI tutorials, over on the ColonelPanic blog, had also been wiped, leaving me again with no other discourse than to dive into the archives. Fortunately I was still able to get my hands on the Mozilla NPAPI SDK, containing the npruntime headers. I also found a pretty good and simple sample plugin called npsimple (forked from the original) that provides a good starting point for a scriptable NPAPI plugin.\nStarting With The Basics\nAt its core an NPAPI plugin is little more than a shared library that happens to export a handful of required and optional functions. The required ones pertain to setting up and tearing down the plugin, as well as querying its functionality. These functions all have specific prefixes, with the NP_ prefixed functions being not part of any API, but simply used for the basic initialization and clean-up. These are:\n\nNP_GetEntryPoints (not on Linux)\nNP_Initialize\nNP_Shutdown\n\nDuring the initialization phase the browser simply loads the plugin and reads its MIME type(s) along with the resources exported by it. After destroying the last instance, the shutdown function is called to give the plugin a chance to clean up all resources before its unloaded. These functions are directly exported, unlike the NPP_ functions that are assigned to function pointers.\nThe NPP_ prefixed functions are part of the plugin (NP Plugin), with the following being required:\n\nNPP_New\nNPP_Destroy\nNPP_GetValue\n\nEach instance of the plugin (e.g. per page) has its own NPP_New called, with an accompanying NPP_Destroy when the page is closed again. These are set in an NPPluginFuncs struct instance which is provided to the browser via the appropriate NP_ function, depending on the OS.\nFinally, there are NPN_ prefixed functions, which are part of the browser and can be called from the plugin on the browser object that is passed upon initialization. These we will need for example when we set up a scriptable interface which can be called from e.g. JavaScript in the browser.\nWhen the browser calls NPP_GetValue with as variable an instance of NPPVpluginScriptableNPObject, we can use these NPP_ functions to create a new NPP instance and retain it by calling the appropriate functions on the browser interface instance which we got upon initialization.\nRegistration of the MIME type unfortunately differs per OS , along with the typical differences of how the final shared library is produced on Windows, Linux/BSD and MacOS. These differences continue with where the plugin is registered, with on Windows the registry being preferred (e.g. HKLM/Software/MozillaPlugins/plugin-identifier), while on Linux and MacOS the plugin is copied to specific folders.\nSoftware Archaeology\nIts somewhat tragic that a straightforward technology like NPAPI-based browser plugins was maligned and mostly erased, as it clearly holds many advantages over APIs that were later integrated into browsers, thus adding to their size and complexity. With for example the VLC browser plugin, part of the VLC installation until version 4, you would be able to play back any video and audio format supported by VLC in any browser that supports NPAPI, meaning since about Netscape 2.x.\nAlthough I do not really see mainstream browsers like the Chromium-based ones returning to plugins with their push towards a locked-down ecosystem, I do think that it is important that everything pertaining to NPAPI is preserved. Currently it is disheartening to see how much of the documentation and source code has already been erased in a mere decade. Without snapshots from archive.org and kin much it likely would already be gone forever.\nIn the next article I will hopefully show off a working NPAPI plugin or two in Pale Moon, both to demonstrate how cool the technology is, as well as how overblown the security concerns are. After all, how much desktop software in use today doesnt use shared libraries in some fashion?", "title": "NPAPI\u30d7\u30e9\u30b0\u30a4\u30f3\u306e\u5fa9\u6d3b\uff1a\u53e4\u304d\u826f\u304d\u30d6\u30e9\u30a6\u30b6\u6280\u8853\u306e\u518d\u8a55\u4fa1", "body": "NPAPI\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u30d6\u30e9\u30a6\u30b6\u62e1\u5f35\u306b\u304a\u3044\u3066\u4fbf\u5229\u3060\u304c\u6587\u66f8\u306f\u6d88\u5931\u3002WASM\u306e\u5236\u7d04\u304c\u5f71\u97ff\u3002", "titles": ["NPAPI\u30d7\u30e9\u30b0\u30a4\u30f3\u306e\u5fa9\u6d3b\uff1a\u53e4\u304d\u826f\u304d\u30d6\u30e9\u30a6\u30b6\u6280\u8853\u306e\u518d\u8a55\u4fa1", "WASM\u3068JavaScript\u306e\u9650\u754c\uff1a\u30d7\u30e9\u30b0\u30a4\u30f3\u306a\u3057\u3067\u306f\u3067\u304d\u306a\u3044\u3053\u3068", "NPAPI\u30d7\u30e9\u30b0\u30a4\u30f3\u306e\u5b9f\u88c5\u30ac\u30a4\u30c9\uff1a\u57fa\u672c\u304b\u3089\u59cb\u3081\u308b\u65b9\u6cd5", "\u30d6\u30e9\u30a6\u30b6\u306e\u9032\u5316\u3068NPAPI\u306e\u6d88\u5931\uff1a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u8003\u53e4\u5b66", "Pale Moon\u3067\u306eNPAPI\u30d7\u30e9\u30b0\u30a4\u30f3\u958b\u767a\uff1a\u904e\u53bb\u306e\u6280\u8853\u3092\u53d6\u308a\u623b\u3059\u65c5"]}