{"pubDate": "2024-03-29T05:00:25", "original_title": "The Intel 8088 and 8086 Processor\u2019s Instruction Prefetch Circuitry", "link": "https://hackaday.com/2024/03/28/the-intel-8088-and-8086-processors-instruction-prefetch-circuitry/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/03/8088_prefetch-die.jpg", "original_content": "The 8088 die under a microscope, with main functional blocks labeled. This photo shows the chips single metal layer; the polysilicon and silicon are underneath. (Credit: Ken Shirriff)\nCache prefetching is what allows processors to have data and/or instructions ready for use in a fast local cache rather than having to wait for a fetch request to trickle through to system RAM and back again. The Intel 8088\u00a0 (and its big brother 8086) processor was among the first microprocessors to implement (instruction) prefetching in hardware, which [Ken Shirriff] has analyzed based on die images of this famous processor. This follows last years deep-dive into the 8086s prefetching hardware, with (unsurprisingly) many similarities between these two microprocessors, as well as a few differences that are mostly due to the 8088s cut-down 8-bit data bus.\nWhile the 8086 has 3 16-bit slots in the instruction prefetcher the 8088 gets 4 slots, each 8-bit. The prefetching hardware is part of the Bus Interface Unit (BIU), which effectively decouples the actual processor (Execution Unit, or EU) from the system RAM. While previous MPUs would be fully deterministic, with instructions being loaded from RAM and subsequently executed, the 8086 and 8088s prefetching meant that such assumptions no longer were true. The added features in the BIU also meant that the instruction pointer (IP) and related registers moved to the BIU, while the ringbuffer logic around the queue had to somehow keep the queueing and pointer offsets into RAM working correctly.\nEven though these days CPUs have much more complicated, multi-level caches that are measured in kilobytes and megabytes, its fascinating to see where it all began, with just a few bytes and relatively straight-forward hardware logic that you easily follow under a microscope."}