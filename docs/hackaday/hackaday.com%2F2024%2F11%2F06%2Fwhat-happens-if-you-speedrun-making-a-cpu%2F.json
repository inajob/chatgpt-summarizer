{"pubDate": "2024-11-06T15:00:48", "original_title": "What Happens If You Speedrun Making A CPU?", "link": "https://hackaday.com/2024/11/06/what-happens-if-you-speedrun-making-a-cpu/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/10/Speedrun.jpg", "original_content": "Usually, designing a CPU is a lengthy process, especially so if youre making a new ISA too. This is something that can take months or even years before you first get code to run. But what if it wasnt? What if one were to try to make a CPU as fast as humanly possible? Thats what I asked myself a couple weeks ago.\nRelative ROM size. Left: Stovepipe, center: [Ben Eater]s, right: GR8CPU Rev. 2Enter the Stovepipe CPU (I dont have an explanation for that name other than that I needed one). Stovepipes hardware was made in under 4 hours, excluding a couple small bugfixes. I started by designing the ISA, which is the simplest ISA I ever made. Instead of continuously adding things to make it more useful, I removed things that werent strictly necessary until I was satisfied. Eventually, all that was left were 8 major opcodes and a mere 512 bits to represent it all. That is far less than GR8CPU (8192 bit), my previous in this class of CPU, and still less than [Ben Eater]s breadboard CPU (2048 bit), which is actually less flexible than Stovepipe. All that while taking orders of magnitude less time to create than either larger CPU. How does that compare to other CPUs? And: How is that possible?\n\nStovepipe was made at break-neck speeds\nLike I said earlier, Stovepipes hardware was finished after a mere 4 hours. Add another 2 total hours for the assembler I made afterwards, for a total of 6 including the programs, spread over one week. I estimate GR8CPU was originally designed in just over a year, including tooling, in occasional afternoons after school spent designing. That timespan is notably over 50 times longer than the week that Stovepipe was spread over. In a similar light, Boa\u00b3\u00b2s minimum viable product (RV32I) was completed in almost exactly two months, or 8-ish weeks. Still, 8 times as long as Stovepipe took to make. I have no concrete numbers of course but I believe that the real time spent in hours to be even worse for both GR8CPU and Boa\u00b3\u00b2; almost certainly more than 50x and 8x the hours (so 300 and 48 at the very bare minimum) respectively. How is that possible?\nBecause it is a simple CPU\nPart of it is, of course, experience. GR8CPU, which has appeared on Hackaday long before I was a writer, was my second ever microarchitecture and [Ben Eater] didnt exactly start studying CPUs immediately after his YouTube series like I did. However, Stovepipe is also an exercise in minimalism; unlike both GR8CPU and [Ben Eater]s, the only user-accessibe register is the accumulator and every calculation with a second operand has to deal with memory. It has 256 bytes of RAM, on par with GR8CPU, but no I/O ports of any kind; all I/O must be memory-mapped. Stovepipe instructions take 1 cycle to fetch and 1-3 to run (except NOP, which takes 0 cycles to run). On par with both GR8CPU and [Ben Eater]s, it has a carry out flag and zero flag.\nCompare this to my most recent previous CPU, Boa\u00b3\u00b2 (a RISC-V implementation), which is larger by a seemingly extreme amount despite being only about as powerful as modern microcontrollers. Its 32-bit, has 31 general-purpose registers, 3 of which are usually used for special purposes, a full 4GiB address space, 512KiB of which contains RAM, hardware multiply/divide and atomics, etc. And most importantly, is pipelined and has separate address and data busses, unlike Stovepipe, GR8CPU and [Ben Eater]s, all of which are multi-cycle single-bus architectures with a dedicated address register.\nBut how does it perform?\nLets compare two programs: Computing the fibonacci sequence and multiplying an 8-bit number; across three CPUs: Stovepipe, GR8CPU and Boa\u00b3\u00b2. I will write it in assembly for all three, ignoring Boa\u00b3\u00b2s hardware multiply to keep it fair. Lets dust off the old projects for a short moment, shall we?\n\n\n\nCPU\nMultiply set-up\nMultiply loop\nFibonacci set-up\nFibonacci loop\n\n\n\n\nGR8CPU\n27\n22-38\n24\n40\n\n\nBoa\u00b3\u00b2\n2\n7-8\n3\n8\n\n\nStovepipe\n18\n22-29\n15\n27\n\n\n\nTo my surprise, GR8CPU actually performs significantly worse than Stovepipe, mainly due to it needing 3 cycles to load an instruction compared to Stovepipes 1. On the other hand, to absolutely nobodys surprise, Boa\u00b3\u00b2 wipes the floor with both Stovepipe and GR8CPU because of its 32 registers and pipelined nature. It executes most instructions in a single cycle spread over its 5-stage pipeline.\nConclusion\nTrying to speedrun making a CPU was clearly a success given the scope; in merely 4 total hours, I made a CPU that outperforms my old 8-bit CPU while being much smaller. The whole exercise shows that simpler is sometimes better, though not always, because the speed-optimized Boa\u00b3\u00b2 easily beats the size-optimized Stovepipe in a landslide performance victory. Stovepipe, however, completely demolishes most CPUs I know in terms of size; [Ben Eater]s, GR8CPU and better-known CPUs like the 8086, 6502, z80, etc. are all easily defeated by Stovepipe in this respect. Thats not a world record, though; I believe that [olofk]s SERV CPU is smaller than Stovepipe, though I cannot make a direct comparison due to Stovepipe existing only in a logic simulator.\nBy the way: If I do ever do a Stovepipe 2, Ill record the entire time with an actual speedrun timer ;)\nA screenshot of Stovepipe, because you all (rightly) asked for one.", "title": "- 4\u6642\u9593\u3067\u5b8c\u6210\u3057\u305f\u30df\u30cb\u30de\u30eb\u306aCPU\u300cStovepipe\u300d\u306e\u8a2d\u8a08", "body": "\u65b0\u3057\u3044CPU\u300cStovepipe\u300d\u306f4\u6642\u9593\u3067\u8a2d\u8a08\u30fb\u88fd\u9020\u3055\u308c\u3001\u5f93\u6765\u306eCPU\u3088\u308a\u5c0f\u578b\u3067\u9ad8\u6027\u80fd\u3002\u30b7\u30f3\u30d7\u30eb\u3055\u304c\u6210\u529f\u306e\u9375\u3002", "titles": ["- 4\u6642\u9593\u3067\u5b8c\u6210\u3057\u305f\u30df\u30cb\u30de\u30eb\u306aCPU\u300cStovepipe\u300d\u306e\u8a2d\u8a08", "- Stovepipe CPU\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3068\u4ed6CPU\u3068\u306e\u6bd4\u8f03", "- \u30b7\u30f3\u30d7\u30eb\u306aISA\u304c\u3082\u305f\u3089\u3059\u8a2d\u8a08\u306e\u30b9\u30d4\u30fc\u30c9", "- GR8CPU\u3092\u8d85\u3048\u308b\uff01Stovepipe\u306e\u512a\u308c\u305f\u30b5\u30a4\u30ba\u6027\u80fd", "- \u30b7\u30f3\u30d7\u30eb\u3055\u304c\u6210\u529f\u3092\u5c0e\u3044\u305f\uff01CPU\u8a2d\u8a08\u306e\u65b0\u305f\u306a\u30a2\u30d7\u30ed\u30fc\u30c1"]}