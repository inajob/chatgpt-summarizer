{"pubDate": "2023-11-13T19:30:21", "original_title": "Vectorscope KiCad Redrawing Project", "link": "https://hackaday.com/2023/11/13/vectorscope-kicad-redrawing-project/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/11/vector-feature.png", "original_content": "When I saw this year\u2019s Supercon Vectorscope badge, I decided that I had to build one for myself. Since I couldn\u2019t attend in-person, I immediately got the PCBs and parts on order. Noting that the GitHub repository only had the KiCad PCB file and not the associated schematics and project file, I assumed this was because everyone was in a rush during the days leading up to Supercon weekend. I later learned, however, that there really wasn\u2019t a KiCad project \u2014 the original design was done in Circuit Maker and the PCB was converted into KiCad. I thought, \u201chow hard can this be?\u201d and decided to try my hand at completing the KiCad project.\nFortunately I didn\u2019t have to start from scratch. The PCB schematics were provided, although only as image files. They are nicely laid out and fortunately don\u2019t suffer the scourge of many schematics these days \u2014 \u201cvisual net lists\u201d that are neither good schematics nor useful net lists. To the contrary, these schematics, while having a slightly unorthodox top to bottom flow, are an example of good schematic design.\nGraphical Lines to PCB Traces\nThe first thing I took a look at was the features on the PCB file, since I was hoping to extract the net names from the traces. Unfortuantely, when I looked at the traces, they were just graphical lines. I knew from previous digging on the KiCad user forums that going backwards from a PCB to a schematic is an unnatural workflow. But I was surprised that there in recent versions of KiCad ( I am using v7 ) there is a feature to convert graphical lines into traces.\n\n\n\n\nOne non-obvious quirk to be aware of  this operation duplicates the selected the graphical lines before converting them into traces, resulting overlapping elements. This can be confusing, because the newly-created trace is presented by PCBNEW as being underneath the original graphical line, making it appear that the conversion failed. The solution is to immediately delete the selected items, and the converted tracks will remain. You can do this on an entire board at once by disabling everything except graphical items in the selection filter and just select an entire layer for conversion.\nPart Footprints\nWhen designing a PCB, the task of mapping the schematic symbols into their corresponding physical footprints can be tedious. Most modern CAD tools with their corresponding parts management schemes make this process easier than ever, but it can still be a headache when you are using parts not in the libraries. Were going backwards in this design, so I wasnt quite sure what problems might exist. But a quick glance at the PCB file shows that the parts on the board are really footprints. This seems promising, so lets move on to making schematics.\nAutomatic Schematic Generation?\nThe usual design flow is from schematics to PCB, whether youre using a CAD tool or doing everything by hand. Changes to a schematic are reflected on the PCB layout. Modern PCB CAD tools can update a PCB design automatically from the schematics, updating the net list and adding and/or removing parts as needed. These tools even take a stab at placing any new parts for you. Even if this is only a jumbled cluster of footprints, its easier than adding each part manually. But can you go the other direction?\nThere are also long-established processes for going the other direction, from PCB to the schematics, which have been around longer than computerized CAD tools. Perhaps the most common of these is called back annotation. Once the layout is substantially complete, the designer will re-sequence the reference designators on the board so that they appear in some order and are easy to find by people working on the PCB. We often skip this step for the kinds of small boards people make today, but if youre making a 9U Eurocard design that is some 350 mm square, you really need to re-sequence the reference designators and back annotate the schematic.\nExamples of Multiple Gates and Inputs\nAnother example of this backwards flow is gate swapping, so-named because it was very common in old designs using 74-series TTL logic chips. These chips have multiple gates per chip, single logic gates with multiple inputs, or both. Fortunately, CAD tools such as KiCad have provisions for these as well.\nBut we have the complete opposite of the normal have a schematic and want to populate a new blank PCB situation. Can I get KiCad to similarly populate a schematic from an existing PCB, no matter how ugly and disorganized it would be? Conceptually it doesnt seem far fetched, given the existing KiCad capabilities. But in practice, the answer is no.\nMake Schematics\nNot unexpectedly, I needed to re-draw these schematics from scratch. Fortunately, this project doesnt have a lot of parts and many of those parts are standard and found in KiCad or my own libraries. Equipped with the original documentation, I proceeded to draw the schematics in KiCad. Rather than making an exact duplicate of the existing schematics, I decided to rearrange the flow of the circuit into the more familiar left-to-right direction.\nI started with just the main chips and components, ignoring connections and discrete components at first. Some of the parts werent in my libraries and had to be constructed in the KiCad symbol editor. I normally start with a large schematic sheet, realizing the page can always be resized later if needed ( I guessed A3, which turned out to be correct ). With all the chips on the page, you have to move things around until the visual flow on the page describes the actual logical flow of the design. Similar to placing components on a new PCB layout, there is no clear-cut process to place schematic symbols on a blank page. But here are some general concepts that Ive learned over the years that I find helpful:\n\nTake a step back from circuitry, and consider the inputs, outputs, and functionality of the overall design as if it were a black box.\nFlow goes from left to right, inputs on left, outputs on right.\nConnectors go on the sheet edges, or for large designs, put all connectors on page 1.\nGroup circuits together by function on the page, or for large designs, into hierarchical sheets.\nAvoid signal-name-only hidden connections (those without a wire) when possible  try to arrange the parts so all pins can be connected by wires.\nUse signal buses when applicable and when it helps the visual flow of the circuit.\n\nThere are many exceptions and contradictions within these guidelines. And the quality of the results can be subjective  give the same circuit, two different engineers could both preapre two different but good schematics.\nKnow Your Tools, Tweak Your Symbols\nIf youve ever sketched a circuit on paper, you usually make chips starting from an empty rectangle and then add signals where they are needed to make things flow. For many chips, like an 8-bit latch, the logical arrangement for your circuit matches up with the standard symbol diagrams provided by the manufacturer and/or your CAD tool libraries. But this is far from universal, especially when it comes to complex chips like microprocessors or FPGAs.\nPico Schematic Symbol Tweaking\nDont be afraid to tweak the schematic symbols to match your needs if necessary (being sure to use a local project-specific copy of the symbol). Remember the multiple-gates-per-IC feature of your EDA tool, like a hex inverter or a quad comparator package. This can be used to break up large chips into smaller manageable chunks. This is often used to separate the power supply pins of large chips into a separate symbols. But you can be further subdivide the chip into smaller symbols as needed by the overall signal flow of your design.\nBut probably the most helpful tweak is to simply rearrange the location of pins on the symbol and its size to better match your circuit. Consider the schematic symbol of a Raspberry Pi Pico module, which is arranged in a familiar pattern by GPIO number. Following that is the same Pico module after being tweaked to fit into the redrawn Vectorscope schematics.\nWrapup\nThere were a few issues between the original schematics and the PCB layout, but those have been sorted out. Some of the part footprints on the PCB are not footprints after all. Instead, they appear as a bunch of independent pads. And some parts have a discrepancy between the PCB pattern and the parts purchased from the BOM.\nJust a few of the nets on the original schematic have names, and the rest are just blank. In the schematics, I tried to pick reasonable net names for the nets. I think this will be helpful when I eventually make the connection between the schematics the PCB.\nAt this point, Ive completed what I wanted to in the beginning  make a KiCad schematic for the Vectorscope project. The KiCad project is not 100% consistent, but I have dug into the few missing pieces and solving those issues is not going to be a huge effort. These issues are explained in the readme of the projects GitHub repository.\n\n\n", "title": "\"\u81ea\u4f5c\u3067\u304d\u308b\uff01\u30b9\u30fc\u30d1\u30fc\u30b3\u30f3\u30d9\u30af\u30bf\u30fc\u30b9\u30b3\u30fc\u30d7\u30d0\u30c3\u30b8\u306e\u4f5c\u308a\u65b9\"", "body": "\u81ea\u4f5c\u306eSupercon Vectorscope\u30d0\u30c3\u30b8\u3092\u4f5c\u308a\u305f\u304f\u3066\u3001KiCad\u3092\u4f7f\u3063\u3066PCB\u3092\u4f5c\u6210\u3057\u307e\u3057\u305f\u3002\u30b0\u30e9\u30d5\u30a3\u30ab\u30eb\u306a\u7dda\u3092\u30c8\u30ec\u30fc\u30b9\u306b\u5909\u63db\u3059\u308b\u6a5f\u80fd\u304c\u3042\u308b\u3053\u3068\u306b\u9a5a\u304d\u307e\u3057\u305f\u3002\u90e8\u54c1\u306e\u30d5\u30c3\u30c8\u30d7\u30ea\u30f3\u30c8\u306f\u3059\u3067\u306bPCB\u306b\u3042\u3063\u305f\u306e\u3067\u3001\u7d20\u65e9\u304f\u30b9\u30ad\u30fc\u30de\u3092\u4f5c\u6210\u3057\u307e\u3057\u305f\u3002\u81ea\u52d5\u7684\u306b\u30b9\u30ad\u30fc\u30de\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u304c\u3001CAD\u30c4\u30fc\u30eb\u3092\u4f7f\u3063\u3066\u30b7\u30f3\u30dc\u30eb\u306e\u30c1\u30e5\u30fc\u30f3\u30ca\u30c3\u30d7\u304c\u3067\u304d\u307e\u3059\u3002\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30b9\u30ad\u30fc\u30de\u3068PCB\u306e\u914d\u7f6e\u306b\u306f\u3044\u304f\u3064\u304b\u306e\u9055\u3044\u304c\u3042\u308a\u307e\u3059\u304c\u3001\u554f\u984c\u306f\u89e3\u6c7a\u3067\u304d\u308b\u3068\u601d\u3044\u307e\u3059\u3002", "titles": ["\"\u81ea\u4f5c\u3067\u304d\u308b\uff01\u30b9\u30fc\u30d1\u30fc\u30b3\u30f3\u30d9\u30af\u30bf\u30fc\u30b9\u30b3\u30fc\u30d7\u30d0\u30c3\u30b8\u306e\u4f5c\u308a\u65b9\"", "\"KiCad\u3092\u4f7f\u7528\u3057\u3066\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3092\u8a2d\u8a08\u3059\u308b\u65b9\u6cd5\"", "\"PCB\u304b\u3089\u56de\u8def\u56f3\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5\"", "\"\u90e8\u54c1\u306e\u30de\u30c3\u30d4\u30f3\u30b0\u304c\u7c21\u5358\u306b\uff01KiCad\u3092\u4f7f\u3063\u305f\u30d5\u30c3\u30c8\u30d7\u30ea\u30f3\u30c8\u306e\u8a2d\u8a08\"", "\"\u96fb\u5b50\u56de\u8def\u8a2d\u8a08\u306e\u305f\u3081\u306e\u30d2\u30f3\u30c8\u3068\u30c8\u30ea\u30c3\u30af\""]}