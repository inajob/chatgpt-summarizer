{"pubDate": "2024-06-07T15:30:43", "original_title": "Comparing x86 and 68000 in an FPGA", "link": "https://hackaday.com/2024/06/07/comparing-x86-and-68000-in-an-fpga/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/06/micro_x86_68k-featured.png", "original_content": "[Michael Kohn] started programming on the Motorola 68000 architecture and then, for work reasons, moved over to the Intel x86 and was not exactly pleased by the latter chips perceived shortcomings. In the 80s, the 68000 was a very popular chip, powering everything from personal computers to arcade machines, and looking at its architecture and ease of programming, you can see why this was.\nFast-forward a few years, and [Mikael] decided to implement both cores in an FPGA to compare real applications, you know, for science. As an extra bonus, [Mike] also compares the performance of a minimal RISC-V implementation on the same hardware, taken from an earlier RISC-V project (which you should also check out !)\nUtilizing their Java Grinder application (also pretty awesome, especially the retro console support), a simple Mandelbrot fractal generator was used as a non-trivial workload to produce binaries for each architecture, and the result was timed. Unsurprisingly, for CISC architectures, the 68000 and x86 code sizes were practically identical and significantly smaller than the equivalent RISC-V. Still, looking at the execution times, the 68000 beat the x86 hands down, with the newer RISC-V speeding along to take pole position. [Mike] admits that these implementations are minimal, with no pipelining, so they could be sped up a little.\nAlso, its not a totally fair race. As youll note from the RISC-V implementation, there was a custom RISC-V instruction implemented to perform the Mandelbrot generators iterator. This computes the complex operation Z = Z2 + C, which, as fellow fractal nerds will know, is where a Mandelbrot generator spends nearly all the compute time. We suspect thats the real reason RISC-V came out on top.\nIf actual hardware is more your cup of tea, you could build a minimal 68k system pretty easily, provided you can find the chips. The current ubiquitous x86 architecture, as odd as it started out, is here to stay for the foreseeable future, so youd just better get comfortable with it!\n\n", "title": "\u30de\u30a4\u30b1\u30eb\u30fb\u30b3\u30fc\u30f3: FPGA\u3067\u5b9f\u88c5\u3057\u305f68000\u3068x86\u306e\u6bd4\u8f03", "body": "80\u5e74\u4ee3\u300168000\u306f\u4eba\u6c17\u306e\u3042\u308b\u30c1\u30c3\u30d7\u3067\u3001\u30d1\u30fc\u30bd\u30ca\u30eb\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3084\u30a2\u30fc\u30b1\u30fc\u30c9\u30de\u30b7\u30f3\u3092\u52d5\u304b\u3059\u305f\u3081\u306b\u4f7f\u7528\u3055\u308c\u305f\u3002\u6700\u65b0\u306eRISC-V\u306f\u9ad8\u901f\u6027\u304c\u3042\u308a\u300168000\u3088\u308a\u512a\u308c\u3066\u3044\u308b\u3002\u8a18\u4e8b\u3067\u306f\u305d\u308c\u3089\u306e\u5b9f\u88c5\u3092\u6bd4\u8f03\u3057\u3001RISC-V\u304c\u512a\u4f4d\u3067\u3042\u308b\u7406\u7531\u3092\u8ff0\u3079\u3066\u3044\u308b\u3002", "titles": ["\u30de\u30a4\u30b1\u30eb\u30fb\u30b3\u30fc\u30f3: FPGA\u3067\u5b9f\u88c5\u3057\u305f68000\u3068x86\u306e\u6bd4\u8f03", "Java Grinder\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u4f7f\u7528\u3057\u305fMandelbrot\u30d5\u30e9\u30af\u30bf\u30eb\u30b8\u30a7\u30cd\u30ec\u30fc\u30bf\u30fc", "CISC\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u306e\u6bd4\u8f03\uff1a68000 vs x86 vs RISC-V", "\u672a\u6765\u306e\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\uff1ax86\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u306e\u9032\u5316", "\u5b9f\u969b\u306e\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u69cb\u7bc9: 68k\u30b7\u30b9\u30c6\u30e0\u306e\u69cb\u7bc9"]}