{"pubDate": "2023-08-04T17:00:30", "original_title": "A Cycle-Accurate Sega Genesis with FPGA", "link": "https://hackaday.com/2023/08/04/a-cycle-accurate-sega-genesis-with-fpga/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/08/chips-main.png", "original_content": "The Field-Programmable Gate Array (FPGA) is a powerful tool that is becoming more common across all kinds of different projects. They are effectively programmable hardware devices, capable of creating specific digital circuits and custom logic for a wide range of applications and can be much more versatile and powerful than a generic microcontroller. While theyre often used for rapid prototyping, they can also recreate specific integrated circuits, and are especially useful for retrocomputing. [nukeykt] has been developing a Sega Genesis clone using them, with some impressive results.\nThe Sega Genesis (or Mega Drive) was based around the fairly common Motorola 68000 processor, but this wasnt the only processor in the console. There were a number of coprocessors including a Z80 and several chips from Yamaha to process audio. This project reproduces a number of these chips which are cycle-accurate using Verilog. The chips were recreated using images of de-capped original hardware, and although it doesnt cover every chip from every version of the Genesis yet, it does have a version of the 68000, a Z80, and the combined Yamaha processor working and capable of playing plenty of games.\nThe project is still ongoing and eventually hopes to recreate the rest of the chipset using FPGAs. Theres also ongoing testing of the currently working chips, as some of them do still have a few bugs to work out. If you prefer to take a more purist approach to recreating 90s consoles, though, we recently featured a project which reproduced a Genesis development kit using original hardware.\nThanks to [Anonymous] for the tip!", "title": "\u300cFPGA\u3092\u4f7f\u3063\u305f\u30bb\u30ac\u30b8\u30a7\u30cd\u30b7\u30b9\u306e\u30af\u30ed\u30fc\u30f3\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u300d", "body": "FPGA\u3092\u4f7f\u7528\u3057\u3066\u30bb\u30ac\u30b8\u30a7\u30cd\u30b7\u30b9\u306e\u30c1\u30c3\u30d7\u3092\u518d\u73fe\u3059\u308b\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3002CPU\u3084Z80\u3001Yamaha\u306e\u30c1\u30c3\u30d7\u306a\u3069\u3092\u518d\u73fe\u3057\u3001\u30b2\u30fc\u30e0\u304c\u30d7\u30ec\u30a4\u53ef\u80fd\u3002\u30c1\u30c3\u30d7\u30bb\u30c3\u30c8\u306e\u518d\u73fe\u306f\u9032\u884c\u4e2d\u3067\u3001\u30d0\u30b0\u4fee\u6b63\u3082\u884c\u308f\u308c\u3066\u3044\u308b\u3002", "titles": ["\u300cFPGA\u3092\u4f7f\u3063\u305f\u30bb\u30ac\u30b8\u30a7\u30cd\u30b7\u30b9\u306e\u30af\u30ed\u30fc\u30f3\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u300d", "\u300cVerilog\u3092\u4f7f\u7528\u3057\u305f\u6b63\u78ba\u306a\u518d\u73fe\u5ea6\u3092\u6301\u3064\u30bb\u30ac\u30b8\u30a7\u30cd\u30b7\u30b9\u30c1\u30c3\u30d7\u306e\u518d\u73fe\u300d", "\u300cFPGA\u3092\u4f7f\u7528\u3057\u305f\u30c1\u30c3\u30d7\u30bb\u30c3\u30c8\u518d\u73fe\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u9032\u6357\u72b6\u6cc1\u300d", "\u300c\u30bb\u30ac\u30b8\u30a7\u30cd\u30b7\u30b9\u306e\u97f3\u58f0\u51e6\u7406\u7528\u30c1\u30c3\u30d7\u3092\u518d\u73fe\u3059\u308b\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u300d", "\u300c90\u5e74\u4ee3\u306e\u30b2\u30fc\u30e0\u6a5f\u518d\u73fe\u306b\u8208\u5473\u304c\u3042\u308b\u306a\u3089\u3001\u30aa\u30ea\u30b8\u30ca\u30eb\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3092\u4f7f\u7528\u3057\u305f\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u300d"]}