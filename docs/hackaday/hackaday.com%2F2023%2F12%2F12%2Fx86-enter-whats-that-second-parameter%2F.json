{"pubDate": "2023-12-13T03:00:59", "original_title": "x86 ENTER: What\u2019s that Second Parameter?", "link": "https://hackaday.com/2023/12/12/x86-enter-whats-that-second-parameter/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/12/x86.png", "original_content": "[Raymond Chen] wondered why the x86 ENTER instruction had a strange second parameter that seems to always be set to zero. If youve ever wondered, [Raymond] explains what he learned in a recent blog post.\nIf youve ever taken apart the output a C compiler or written assembly programs,\u00a0 you probably know that ENTER is supposed to set up a new stack frame. Presumably, you are a subroutine and some arguments were pushed on the stack for you. The instruction puts the pointer to those arguments in EBP and then adjusts the stack pointer to account for your local variables. That local variable size is the first argument to ENTER.\nThe reason you rarely see it set to a non-zero value is that the final argument is made for other languages that are not as frequently seen these days. In a simple way of thinking, C functions live at a global scope. Sure, there are namespaces and methods for classes and instances. But you dont normally have a C compiler that allows a function to define another function, right?\nTurns out, gcc does support this as an extension (but not g++). However, looking at the output code shows it doesnt use this feature, but it could. The idea is that a nested function can see any local variables that belong to the enclosing function. This works, for example, if you allow gcc to use its extensions:\n[CODE language=C]\n#include \nvoid test()\n{\n   int a=10;\n/* nested function */\n   void testloop(int n)\n      {\n      while (n) printf(%d\\n,a);\n      }\n   testloop(3);\n   printf(Again\\n);\n   testloop(2);\n   printf(and now\\n);\n   a=33;\n   testloop(5);\n}\nvoid main(int argc, char *argv[])\n{\n   test();\n}\n[/CODE]\nYou can see that the testloop function has access to its argument, a local variable, and also a local variable that belongs to the test function. We arent saying this is a good idea, but it is possible, and it is common in certain other languages like Pascal, for example.\nIn some cases, this situation is handled by providing a linked list of stack frames. However, the Intel designers decided to do it differently. When you provide a non-zero second argument to ENTER, it copies an array of stack pointers into your local variable space. This makes your code potentially more efficient as it executes but exacts a penalty on function calls for nested functions.\nAs [Raymond] points out, though, it may be that no one uses this feature. Certainly, gcc doesnt. If you want to make sure, try these commands with the above program in nest.c to check out 32-bit x86:\ngcc -m32 -g -o nest nest.c\u00a0\u00a0 gcc -m32 -s -c nest.c# now look at nest.s and/or disassemble nest using gdb\nOf course, if you write your own assembly, you could use the feature as you see fit. The x86 has some crazy instructions. If youve ever wondered if you should learn assembly language, our commenters would like a word with you."}