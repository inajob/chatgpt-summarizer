{"pubDate": "2025-07-01T17:00:21", "original_title": "C++ Encounters of the Rusty Zig Kind", "link": "https://hackaday.com/2025/07/01/c-encounters-of-the-rusty-zig-kind/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2015/12/rust.jpg", "original_content": "There comes a time in any software developers life when they look at their achievements, the lines of code written and the programming languages they have relied on, before wondering whether there may be more out there. A programming language and its associated toolchains begin to feel like familiar, well-used tools after you use them for years, but that is no excuse to remain rusted in place.\nWhile some developers like to zigzag from one language and toolset to another, others are more conservative. My own journey took me from a childhood with QuickBasic and VisualBasic to C++ with a bit of Java, PHP, JavaScript, D and others along the way. Although I have now for years focused on C++, Im currently getting the hang of Ada in particular, both of which tickle my inner developer in different ways.\nAlthough Java and D never quite reached their lofty promises, there are always new languages to investigate, with both Rust and Zig in particular getting a lot of attention these days. Might they be the salvation that was promised to us C-afflicted developers, and do they make you want to zigzag or ferrously oxidize?\n\nSolving Problems\nAs hilarious it is to make new programming languages for the fun of it, there has to be some purpose to them if they want to be more than a gag. Thats why Whitespace and Brainf*ck are great for having some (educational) fun with, while Forth is a serious and very much commercially successful language. Meanwhile theres still an ongoing debate about whether Python may or may not be an esoteric language, mostly on account of it granting whitespace so much relevance that would make the Whitespace developers proud.\nThis contrasts heavily with languages like C and consequently C++ where whitespace is not relevant and you can write everything on a single line if thats your kink. Meanwhile in Ada, COBOL and others case sensitivity doesnt exist, because their developers failed to see the point of adding this feature. This leads us to another distinguishing feature of languages: weakly- versus strongly-typed and super-strongly typed languages.\nIf one accepts that a type system is there to prevent errors, then logically the stronger the type system is, the better. This is one reason why I personally prefer TypeScript over JavaScript, why Java reflection and Objective-C messaging drove me up various walls, why my favorite scripting language is AngelScript, why I love the type system in Ada and also why I loathe whoever approved using the auto keyword in C++ outside of templates.\nWith those lines marked, lets see what problems Rust and Zig will solve for me.\nGetting Ziggy\nThe Zig language is pretty new, having only been released in early 2016. This makes it four years younger than Rust, while also claiming to be a better C. Much of this is supposed to come from improved memory safety, which is a topic that I have addressed previously, both in the context of another improved C language called TrapC, as well as from a security red herring point of view. Here again having a very strong type system is crucial, as this allows for the compiler as well as static and dynamic analysis tools to pick up any issues.\nThere is also the wrinkle that C++ is already an improved C, and the C11 standard in particular addresses a lot of undefined behavior, which makes it a pretty tall order to do better than either. Fortunately Zig claims to be a practically drop-in solution for existing C and C++ code, so it should be pretty gentle to get started with.\nUnfortunately, this is the part where things rapidly fell apart for me. I had the idea to quickly put together a crude port of my ncurses-based UE1 emulator project, but the first surprise came after installing the toolchain. My default development environment on Windows is the Linux-like MSYS2 environment, with the Zig toolchain available via pacman.\nA feeling of dread began to set in while glancing at the Getting Started page, but I figured that Id throw together a quick ncurses project based on some two-year old code that someone said had worked for them:\nconst std = @import(\"std\");\nconst c = @cImport({\n    @cInclude(\"curses.h\");\n});\n\npub fn main() !void {\n    var e = c.initscr();\n    e = c.printw(\"Hello World !!!\");\n    e = c.refresh();\n    e = c.getch();\n    e = c.endwin();\n}\nDespite the symbol soup and chronic fear of fully writing out English words, its not too hard to understand what this code is supposed to do. The @cImport() block allows you to include C headers, which in this case allows us to import the standard ncurses header, requiring us to only link against the system ncurses library later on. Whats not inspiring much confidence is that its clear at this point already that Zig is a weakly-typed language, bringing back highly unwanted embedded JavaScript flashbacks.\nWhile prodding at writing a standard Makefile to compile this code, the reality of the Zig build system began to hit. You can only use the zig command, which requires a special build file written in Zig, so you have to compile Zig to compile Zig, instead of using Make, CMake, Ninja, meson, etc. as is typical. Worse is that Zigs API is being changed constantly, so that the sample build.zig code that I had copied no longer worked and had to be updated to get the following:\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n  \u00a0 const target = b.standardTargetOptions(.{});\n  \u00a0 const optimize = b.standardOptimizeOption(.{});\n  \u00a0 const exe = b.addExecutable(.{\n  \u00a0 \u00a0 \u00a0 .name = \"ncurses\",\n  \u00a0 \u00a0 \u00a0 .root_source_file = b.path(\"main.zig\"),\n  \u00a0 \u00a0 \u00a0 .target = target,\n  \u00a0 \u00a0 \u00a0 .optimize = optimize,\n  \u00a0 });\n\nexe.linkSystemLibrary(\"c\");\n  \u00a0 exe.linkSystemLibrary(\"ncurses\");\n  \u00a0 b.installArtifact(exe);\n}\nWith this change in place, I no longer got compile errors for the build file, but even after deleting the .zig-cache folder that the toolchain creates I kept getting the same linker errors:\n\n\n\nWhile Im sure that all of this is solvable, I was looking for a solution to my problems, not to get new problems. Instead I got a lack of strong typing, an oddly verbose syntax, ever-shifting APIs, being strong-armed into giving up the build tools of ones choosing and finally some weird linker errors that probably require constant nuking of caches as one has to already suffer through with CMake and Gradle.\nIt is time to zigzag out of dodge to the next language.\nRusted Expectations\nAs mentioned earlier, Rust is a few years older than Zig, and in addition it has seen a lot more support from developers and companies. Its vibrant community is sure to remind you of these facts at any opportunity they get, along with how Rust cures all ills. Ignoring the obvious memory safety red herring, what problems can Rust solve for us?\nFollowing the same pattern as with Zig, we first have to set up a development environment with the Rust toolchain and the ability to use ncurses. Unlike with Zig, we apparently cannot use C (or C++) code directly, so the recommendation is to use a wrapper. From its code we can worryingly tell that it is also a weakly-typed language by the use of type inference, and the fact that the unsafe keyword is required to cooperate with C interfaces gives even great cause for concern. Ideally youd not do the equivalent of hammering in raw assembly when writing C either, as this bypasses so many checks.\nRegardless, the task is to figure out how to use this ncurses-rs wrapper, despite it already being EOL-ed. Rather than dealing with this cargo remote repository utility and reliving traumatic memories of remote artefact repositories with NodeJS, Java, etc., well just copy the .rs files of the wrapper directly into the source folder of the project. Its generally preferred to have dependencies in the source tree for security reasons unless you have some level of guarantee that the remote source will be available and always trustworthy.\nAlthough you can use the rustc compiler directly, it provides an extremely limited interface compared to e.g. Clang and GCC. After trying to understand and massage dependency paths for the included files (modules) for a while, the sad result is always another fresh series of errors, like:\nThe frustrating end to trying out Rust.\nAt this point any enthusiasm for doing more with Rust has already rapidly oxidized and decayed into sad shards of ferrous oxide.\nWorkflow Expectations\nMost of my exposure to Rust and Zig prior to this experience had been from a theoretical and highly academical perspective, but actually trying to use a language is when you really begin to develop feelings that tell you whether the language is something youre interested in. In my case these feelings were for both languages primarily frustration, mixed with an urge to get away from the whole thing as soon as possible.\nThis contrasts heavily with my recent experiences with COBOL, which saw me working for days on code and figuring out the language, but with a feeling of almost giddy joy at grasping yet another concept or mechanism. What helped a lot here is that the COBOL toolchains are just typical GCC compilers with the whole feature set, which means that you can use them with any build system of your choice.\nEven with the Ada toolchain and its multi-step process of module dependency resolving, compiling and linking you can use these tools any way you like. Its this kind of freedom that is at least in my view an essential part of a good development environment, as it gives the developer the choice of how to integrate these into their workflow.\nThe workflow with Zig and Rust reminds me mostly of the harrowing struggle with Android development and its Gradle-based environment. You get similar struggles with just getting the basic thing off the ground, are always dealing with baffling errors that may or may not be related to a component thats a few versions too old or new, and basically its just a gigantic waste of time.\nEven ignoring whether Zig and Rust are or can become good languages, it is this complete disregard for individual workflow preferences thats probably the most off-putting to me, and reason to avoid these ecosystems at all cost. Something which I wish I could do with Gradle as well, but I digress.\nIn the end I think Ill be sticking with C++, with a bit of C and an increasing amount of Ada and Fortran on the side. Unless youre being paid big bucks, there is no reason to put yourself through the suffering of a workflow you loathe.\n", "title": "\u65b0\u3057\u3044\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u8a00\u8a9e\u3092\u63a2\u6c42\u3059\u308b\u697d\u3057\u307f\u3068\u82e6\u60a9", "body": "\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u958b\u767a\u8005\u306f\u65b0\u3057\u3044\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u8a00\u8a9e\u3092\u63a2\u6c42\u3057\u3001Zig\u3084Rust\u3092\u8a66\u3059\u304c\u3001\u7279\u306b\u4f7f\u3044\u306b\u304f\u3055\u306b\u82e6\u52b4\u3057\u3066\u3044\u308b\u3002", "titles": ["\u65b0\u3057\u3044\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u8a00\u8a9e\u3092\u63a2\u6c42\u3059\u308b\u697d\u3057\u307f\u3068\u82e6\u60a9", "Rust\u3068Zig\uff1aC++\u958b\u767a\u8005\u306e\u30b8\u30ec\u30f3\u30de", "\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u8a00\u8a9e\u306e\u9078\u629e\u80a2\uff1a\u4fa1\u5024\u3068\u554f\u984c\u3092\u63a2\u308b", "Zig\u306e\u958b\u767a\u74b0\u5883\u306b\u304a\u3051\u308b\u82e6\u52b4\u3068\u671f\u5f85", "C++\u3068\u306e\u4ed8\u304d\u5408\u3044\uff1a\u65b0\u3057\u3044\u8a00\u8a9e\u3078\u306e\u79fb\u884c\u306e\u96e3\u3057\u3055"]}