{"pubDate": "2025-12-08T18:00:12", "original_title": "Linux Fu: The SSD Super Cache", "link": "https://hackaday.com/2025/12/08/linux-fu-the-ssd-super-cache/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "NVMe solid state disk drives have become inexpensive unless you want the very largest sizes. But how do you get the most out of one? There are two basic strategies: you can use the drive as a fast drive for things you use a lot, or you can use it to cache a slower drive.\nEach method has advantages and disadvantages. If you have an existing system, moving high-traffic directories over to SSD requires a bind mount or, at least, a symbolic link. If your main filesystem uses RAID, for example, then those files are no longer protected.\nCaching sounds good, in theory, but there are at least two issues. You generally have to choose whether your cache writes through, which means that writes will be slow because you have to write to the cache and the underlying disk each time, or whether you will write back, allowing the cache to flush to disk occasionally. The problem is, if the system crashes or the cache fails between writes, you will lose data.\nCompromise\nFor some time, Ive adopted a hybrid approach. I have an LVM cache for most of my SSD that hides the terrible performance of my root drives RAID array. However, I have some selected high-traffic, low-importance files in specific SSD directories that I either bind-mount or symlink into the main directory tree. In addition, I have as much as I can in tmpfs, a RAM drive, so things like /tmp dont hit the disks at all.\nThere are plenty of ways to get SSD caching on Linux, and I wont explain any particular one. Ive used several, but Ive wound up on the LVM caching because it requires the least odd stuff and seems to work well enough.\nThis arrangement worked just fine and gives you the best of both worlds. Things like /var/log and /var/spool are super fast and dont bog down the main disk. Yet the main disk is secure and much faster thanks to the cache setup. Thats been going on for a number of years until recently.\n\nThe Upgrade Issue\nI recently decided to give up using KDE Neon on my main desktop computer and switch to OpenSUSE Tumbleweed, which is a story in itself. The hybrid caching scheme seemed to work, but in reality, it was subtly broken. The reason? SELinux.\nTumbleweed uses SELinux as a second level of access protection. On vanilla Linux, you have a user and a group. Files have permissions for a specific user, a specific group, and everyone else. Permission, in general, means if a given user or group member can read, write, or execute the file.\nSELinux adds much more granularity to protection. You can create rules that, for example, allow certain processes to write to a directory but not read from it. This post, though, isnt about SELinux fundamentals. If you want a detailed deep dive from Red Hat, check out the video below.\n\nThe Problem\nThe problem is that when you put files in SSD and then overlay them, they live in two different places. If you tell SELinux to relabel files  that is, put them back to their system-defined permissions, there is a chance it will see something like /SSD/var/log/syslog and not realize that this is really the same file as /var/log. Once you get the wrong label on a system file like that, bad, unpredictable things happen.\nThere is a way to set up an equivalence rule in SELinux, but theres a catch. At first, I had the SSD mounted at /usr/local/FAST. So, for example, I would have /usr/local/FAST/var/log. When you try to equate /usr/local/FAST/var to /usr/var, you run into a problem. There is already a rule that /usr and /usr/local are the same. So you have difficulties getting it to understand that throws a wrench in the works.\nThere are probably several ways to solve this, but I took the easy way out: I remounted to /FAST. Then it was easy enough to create rules for /var/log to /FAST/var/log, and so on. To create an equivalence, you enter:\n\n\nsemanage fcontext -a -e /var/log /FAST/var/log\n\n\nThe Final Answer\nSo what did I wind up with? Heres my current /etc/fstab:\n\n\nUUID=6baad408-2979-2222-1010-9e65151e07be / \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ext4 \u00a0\u00a0\u00a0defaults,lazytime,commit=300 0 1\ntmpfs \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/tmp \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmpfs \u00a0\u00a0mode=1777,nosuid,nodev 0 0\nUUID=cec30235-3a3a-4705-885e-a699e9ed3064 /boot \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ext4 \u00a0\u00a0\u00a0defaults,lazytime,commit=300,inode_readahead_blks=64 0 2\nUUID=ABE5-BDA4 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/boot/efi \u00a0\u00a0\u00a0\u00a0\u00a0vfat \u00a0\u00a0\u00a0defaults,lazytime 0 2\ntmpfs \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/var/tmp \u00a0\u00a0\u00a0tmpfs \u00a0rw,nosuid,nodev,noexec,mode=1777 0 0\n\nh1NVMe fast tiers/h1\n\nUUID=c71ad166-c251-47dd-804a-05feb57e37f1 /FAST \u00a0ext4 \u00a0defaults,noatime,lazytime \u00a00 \u00a02\n/FAST/var/log /var/log \u00a0none \u00a0bind,x-systemd.requires-mounts-for=/FAST 0 0\n/FAST/usr/lib/sysimage/rpm /usr/lib/sysimage/rpm none bind,x-systemd.requires-mounts-for=/FAST 0 0\n/FAST/var/spool /var/spool \u00a0none \u00a0bind,x-systemd.requires-mounts-for=/FAST 0 0\n\nAs for the SELinux rules:\n\n\n/FAST/var/log = /var/log\n/FAST/var/spool = /var/spool\n/FAST/alw/.cache = /home/alw/.cache\n/FAST/usr/lib/sysimage/rpm = /usr/lib/sysimage/rpm\n/FAST/alw/.config = /home/alw/.config\n/FAST/alw/.zen = /home/alw/.zen\n\n\nNote that some of these dont appear in /etc/fstab because they are symlinks.\nA good rule of thumb is that if you ask SELinux to relabel the tree in the real location, it shouldnt change anything (once everything is set up). If you see many changes, you probably have a problem:\n\n\nrestorecon -Rv /FAST/var/log\n\n\nWorth It?\nWas it worth it? I can certainly feel the difference in the system when I dont have this setup, especially without the cache. The noisy drives quiet down nicely when most of the normal working set is wholly enclosed in the cache.\nThis setup has worked well for many years, and the only really big issue was the introduction of SELinux. Of course, for my purposes, I could probably just disable SELinux. But it does make sense to keep it on if you can manage it.\nIf you have recently switched on SELinux, it is useful to keep an eye on:\n\n\nausearch -m AVC -ts recent\n\n\nThat shows you if SELinux denied any access recently. Another useful command:\n\n\nsystemctl status setroubleshootd.service\n\n\nAnother good systemd stupid trick. Often, any mysterious issues will show up in one of those two places. If you are on a single-user desktop, it isnt a bad idea to retry any strange anomalies with SELinux turned off as a test: setenforce 0. If the problem goes away, it is a sure bet that something is wrong with the SELinux system.\nOf course, every situation is different. If you dont need RAID or a huge amount of storage, maybe just use an SSD as your root system and be done with it. That would certainly be easier. But, in typical Linux fashion, you can make of it whatever you want. We like that.", "title": "NVMe SSD\u306e\u6700\u9069\u306a\u6d3b\u7528\u6cd5\u3068\u306f\uff1f", "body": "NVMe SSD\u306e\u6d3b\u7528\u6cd5\u3068\u3057\u3066\u3001\u30ad\u30e3\u30c3\u30b7\u30e5\u5229\u7528\u3084\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u79fb\u52d5\u304c\u3042\u308b\u3002SELinux\u304c\u5f71\u97ff\u3057\u3001SSD\u3068\u306e\u6574\u5408\u6027\u554f\u984c\u304c\u751f\u3058\u305f\u3002", "titles": ["NVMe SSD\u306e\u6700\u9069\u306a\u6d3b\u7528\u6cd5\u3068\u306f\uff1f", "\u30cf\u30a4\u30d6\u30ea\u30c3\u30c9\u30ad\u30e3\u30c3\u30b7\u30e5\u306e\u30e1\u30ea\u30c3\u30c8\u3068\u30c7\u30e1\u30ea\u30c3\u30c8", "SELinux\u5c0e\u5165\u3067\u5931\u6557\u3057\u305fSSD\u904b\u7528\u306e\u6559\u8a13", "\u52b9\u7387\u7684\u306aLinux\u306eSSD\u30ad\u30e3\u30c3\u30b7\u30f3\u30b0\u624b\u6cd5", "SELinux\u8a2d\u5b9a\u3067SSD\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u5411\u4e0a\u3055\u305b\u308b\u65b9\u6cd5"]}