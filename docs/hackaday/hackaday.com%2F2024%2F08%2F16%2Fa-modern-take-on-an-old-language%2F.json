{"pubDate": "2024-08-16T14:00:28", "original_title": "A Modern Take on an Old Language", "link": "https://hackaday.com/2024/08/16/a-modern-take-on-an-old-language/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/08/bqagw8jbta751.jpg", "original_content": "Some old computer languages are destined to never die. They do, however, evolve. For example, Fortran, among the oldest of computer languages, still has adherents, not to mention a ton of legacy code to maintain. But it doesnt force you to pretend you are using punched cards anymore. In the 1970s, if you wanted to crunch numbers, Fortran was a good choice. But there was another very peculiar language: APL. Turns out, APL is alive and well and has a thriving community that still uses it.\nAPL has a lot going for it if you are crunching serious numbers. The main data type is a multidimensional array. In fact, you could argue that a lot of modern ideas like a REPL, list types, and even functional programming entered the mainstream through APL. But it did have one strange thing that made it difficult to use and learn.\n[Kenneth E. Iverson] was at Harvard in 1957 and started working out a mathematical notation for dealing with arrays. By 1960, hed moved to IBM and a few years later wrote a book entitled A Programming Language. Thats where the name comes from  it is actually an acronym for the books title. Being a mathematician, [Iverson] used symbols instead of words. For example, to create an array with the numbers 1 to 5 in it and then print it, youd write:\n\u2395\u2190\u23735\nSince modern APL has a REPL (read-eval-print loop), you could remove the box and the arrow today.\nWhat Key Was That?\nWait. Where are all those keys on your keyboard? Ah, youve discovered the one strange thing. In 1963, CRTs were not very common. While punched cards were king, IBM also had a number of Selectric terminals. These were essentially computer-controlled typewriters that had type balls instead of bars that were easy to replace.\n\nWith the right type ball, you could have 26 upper-case letters, 10 digits, a few control characters, and then a large number of weird characters. But it is actually worse than that. The available symbols were still not numerous enough for APLs appetite. So some symbols required you to type part of the symbol, press backspace, then type more of the symbols, sometimes repeating the process several times. On a printing terminal, that works fine. For the CRTs that would soon take over, this was tough to do.\nFor example, a comment (like a REM in Basic or a // in C++) is represented by a thumbnail (\u235d). In other words, this would be an APL comment:\n\u235d This is a comment\nTo make that character, youd type the arch part, backspace, then the dot part. Not very speedy. Not very practical on old CRT terminals, either.\nThe characters arent the only strange thing. For example, APL evaluates math right to left.\nThat is, 3\u00d72+5 is 21 because the 2+5 happens first. You just have to get used to that.\nA Solution\nOf course, modern screens can handle this easily and most people use an APL keyboard mapping that looks like your normal keyboard, but inserts special symbols when you use the right Alt key (with or without the shift modifier). This allows the keyboard to directly enter every possible symbol.\nOf course, your keyboards keycaps probably dont have those symbols etched in, so youll probably want a cheat sheet. You can buy APL keycaps or even entire keyboards if you really get into it.\nWhats GNU With You?\nWhile there have been many versions of APL over the years, GNU APL is certainly the easiest to setup, at least for Linux. According to the website, the project has more than 100,000 lines of C++ code! It also has many modern things like XML parsers.\nA US APL keyboard layout\nThe real trick is making your keyboard work with the stranger characters. If you are just playing around, you can consider doing nothing. You can see the keyboard layout by issuing the ]KEYBD command at the APL prompt. That will give you something like the adjacent keyboard layout image.\nFrom that image, you can copy and paste odd characters. Thats a pain, though. I had good luck with this command line:\nsetxkbmap -layout us,apl -variant ,dyalog -option grp:switch\nWith this setup, I can use the right alt key to get most APL characters. I never figured out how to get the shifted alternate characters, though. If you want to try harder, or if you use a different environment than I do, you might read the APL Wiki.\nAn Example\nRather than do a full tutorial, heres my usual binary search high low game. The computer asks you to think of a number, and then it guesses it. Not the best use of APLs advanced math capabilities, but it will give you an idea of what it can do.\nHeres a survival guide. The upside-down triangle is the start or end of a function. You already know the thumbnail is a comment. A left-pointing arrow is an assignment statement. A right-pointing arrow is a goto (this was created in the 1960s; modern APL has better control structures, but they can vary between implementations).\u00a0 Square boxes are for I/O, and the diamond separates multiple statements on a single line.\n\n\n\u2207 BinarySearchGame\n\u235d Initialize variables\nlower \u2190 1\nupper \u2190 1024\nturns \u2190 0\ncheating \u2190 0\n\n\u235d Start the game\nThink of a number between 1 and 1024. \u22c4 \u2395 \u2190 \n\nLoop:\nturns \u2190 turns + 1\nguess \u2190 \u230a(lower + upper) \u00f7 2 \u235d Make a guess using binary search\n\n\u235e \u2190 Is your number , \u2355 guess, ? (h for high, l for low, c for correct): \nresponse \u2190 \u235e\n\n\u2192 (response = c)/Finish \u235d Jump to Finish if correct\n\u2192 (response = h)/TooHigh \u235d Jump to TooHigh if too high\n\u2192 (response = l)/TooLow \u235d Jump to TooLow if too low\n\u2192 InvalidInput \u235d Invalid input\n\nTooHigh:\nupper \u2190 guess - 1\n\u2192 (lower gt; upper)/CheatingDetected \u235d Detect cheating\n\u2192 Loop\n\nTooLow:\nlower \u2190 guess + 1\n\u2192 (lower gt; upper)/CheatingDetected \u235d Detect cheating\n\u2192 Loop\n\nInvalidInput:\n\u235e \u2190 Invalid input. Please enter h, l, or c. \u22c4 \u2395 \u2190 \nturns \u2190 turns - 1 \u235d Invalid input doesnt count as a turn\n\u2192 Loop\n\nCheatingDetected:\n\u235e \u2190 Hmm... Something doesnt add up. Did you make a mistake? \u22c4 \u2395 \u2190 \ncheating \u2190 1\n\u2192 Finish\n\nFinish:\n\u2192 (cheating = 0)/Continue \u235d If no cheating, continue\n\u2192 EndGame\n\nContinue:\n\u235e \u2190 Great! The number is , \u2355 guess, . It took , \u2355 turns,  turns to guess it. \u22c4 \u2395 \u2190 \n\nEndGame:\n\u235e \u2190 Would you like to play again? (y/n): \nrestart \u2190 \u235e\n\u2192 (restart = y)/Restart \u235d Restart the game if y\n\u2192 Exit \u235d Exit the game otherwise\n\nRestart:\nBinarySearchGame \u235d Restart the game\n\nExit:\n\u235e \u2190 Thank you for playing! \u22c4 \u2395 \u2190  \u235d Exit message\n\u2207\n\n\nWhats Next?\nIf you want to get an idea of how APLs special handling of data make some programs easier, the APL Wiki has a good page for that. If you dont want to install anything, you can run APL in your browser (although it is the Dyalog version, a very common choice for modern APL).\nIf you dont want to read the documentation, check out [phoebes] video below. We always wanted the IBM computer that had the big switch to go from Basic to APL.\n\nAPL Keyboard image via Reddit", "title": "\u53e4\u3044\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u8a00\u8a9e\uff1a\u9032\u5316\u3092\u7d9a\u3051\u308bFortran\u3068APL", "body": "\u53e4\u3044\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u8a00\u8a9e\u306e\u4e2d\u306b\u306f\u3001\u6d88\u3048\u308b\u3053\u3068\u306a\u304f\u9032\u5316\u3059\u308b\u3082\u306e\u304c\u3042\u308b\u3002Fortran\u3084\u6700\u53e4\u306e\u4e00\u3064\u3067\u3042\u308bFortran\u306f\u4eca\u3067\u3082\u652f\u6301\u3092\u5f97\u3066\u304a\u308a\u3001APL\u3068\u3044\u3046\u975e\u5e38\u306b\u7279\u7570\u306a\u8a00\u8a9e\u3082\u73fe\u5f79\u3067\u4f7f\u308f\u308c\u3066\u3044\u308b\u3002APL\u306f\u9ad8\u5ea6\u306a\u6570\u5024\u8a08\u7b97\u306b\u5411\u3044\u3066\u304a\u308a\u3001\u7570\u306a\u308b\u7279\u5fb4\u3092\u6301\u3064\u3002", "titles": ["\u53e4\u3044\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u8a00\u8a9e\uff1a\u9032\u5316\u3092\u7d9a\u3051\u308bFortran\u3068APL", "APL\uff1a\u591a\u6b21\u5143\u914d\u5217\u3092\u6d3b\u7528\u3059\u308b\u6570\u5024\u51e6\u7406\u306b\u9069\u3057\u305f\u8a00\u8a9e", "APL\uff1a\u7279\u6b8a\u30ad\u30fc\u30dc\u30fc\u30c9\u304b\u3089\u8fd1\u4ee3\u7684\u306a\u30b7\u30b9\u30c6\u30e0\u3078", "GNU APL\uff1a\u6700\u3082\u7c21\u5358\u306b\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\u3067\u304d\u308bAPL", "APL\u3092\u901a\u3058\u3066\u57fa\u672c\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u4f5c\u6210\u3092\u5b66\u307c\u3046"]}