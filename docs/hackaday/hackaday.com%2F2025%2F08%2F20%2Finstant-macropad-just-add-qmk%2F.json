{"pubDate": "2025-08-20T17:00:42", "original_title": "Instant Macropad: Just Add QMK", "link": "https://hackaday.com/2025/08/20/instant-macropad-just-add-qmk/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/10/PXL_20231020_202412670.jpg", "original_content": "I recently picked up one of those cheap macropads (and wrote about it, of course). It is surprisingly handy and quite inexpensive. But I felt bad about buying it. Something like that should be easy to build yourself. People build keyboards all the time now, and with a small number of keys, you dont even have to scan a matrix. Just use an I/O pin per switch.\nThe macropad had some wacky software on it that, luckily, people have replaced with open-source alternatives. But if I were going to roll my own, it would be smart to use something like QMK, just like a big keyboard. But that made me wonder, how much trouble it would be to set up QMK for a simple project. Spoiler: It was pretty easy.\nThe Hardware\nSimple badge or prototype macropad? Why not both?\nSince I just wanted to experiment, I was tempted to jam some switches in a breadboard along with a Raspberry Pi Pico. But then I remembered the simple badge project I had up on a nearby shelf. It is simplicity itself: an RP2040-Plus (you could just use a regular Pi Pico) and a small add-on board with a switch joystick, four buttons, and a small display. You dont really need the Plus for this project since, unlike the badge, it doesnt need a battery. The USB cable will power the device and carry keyboard (or even mouse) commands back to the computer.\nPractical? No. But it would be easy enough to wire up any kind of switches you like. I didnt use the display, so there would be no reason to wire one up if you were trying to make a useful copy of this project.\n\nThe Software\nThere are several keyboard firmware choices out there, but QMK is probably the most common. It supports the Pico, and its well supported. It is also modular, offering a wide range of features.\nThe first thing I did was clone the Git repository and start my own branch to work in. There are a number of source files, but you wont need to do very much with most of them.\nThere is a directory called keyboards. Inside that are directories for different types of keyboards (generally, brands of keyboards). However, theres also a directory called handwired for custom keyboards with a number of directories inside.\nThere is one particular directory of interest: onekey. This is sort of a Hello World for QMK firmware. Inside, there are directories for different CPUs, including the RP2040 I planned to use. There are many other choices, though, if you prefer something else.\nSurprise!\nQuick guide to the files of interest.\nSo, that directory probably has a mess of files in it, right? Not really. There are five files, including a readme, and thats it. Of those, there are only two I was going to change: config.h and keyboard.json. In addition, there are a few files that may be important in the parent directory: config.h, onekey.c, and info.json.\nI didnt want to interfere with the stock options, so I created a directory at ~/qmk_firmware/keyboards/handwired/hackaday. I copied the files from onekey to this directory, along with the rp2040 and keymap directories (that one is important). I renamed onekey.c to hackaday.c.\nIt seems confusing at first, but maybe the diagram will help. This document will help, too. The good news is that most of these files you wont even need to change. Essentially, info.json is for any processor, keyboard.json is for a specific processor, and keymap.json goes with a particular keymap.\nChanges\nThe root directory config.h didnt need any changes, although you can disable certain features here if you care. The hackaday.c file had some debugging options set to true, but since I wanted to keep it simple, I set them all to false.\nThe info.json file was the most interesting. You can do things like set the keyboard name and USB IDs there. I didnt change the rest, even though the diode_direction key in this file wont be used for this project. For that matter, the locking section is only needed if you have physical keys that actually lock, but I left it in since it doesnt hurt anything.\nIn the rp2040 directory, there are more changes. The config.h file allows you to set pin numbers for various things, and I also put some mouse parameters there (more on that later). I didnt actually use any of these things (SPI and the display), so I could have deleted most of this.\nBut the big change is in the keyboard.json file. Here you set the processor type. But the big thing is you set up keys and some feature flags. Usually, you describe how your keyboard rows and columns are configured, but this simple device just has direct connections. You still set up fake rows and columns. In this case, I elected to make two rows of five columns. The first row is the four buttons (and a dead position). The second row is the joystick buttons. You can see that in the matrix_pins section of the file.\nThe layouts section is very simple and gives a name to each key. I also set up some options to allow for fake mouse keys and media keys (mousekey and extrakey set to true). Heres the file:\n\n{\n    keyboard_name: RP2040_Plus_Pad,\n    processor: RP2040,\n    bootloader: rp2040,\n    matrix_pins: {\n        direct: \n            GP15, GP17, GP19, GP21, NO_PIN],\n            GP2, GP18, GP16, GP20, GP3]\n        ]\n    },\n    features: {\n        mousekey: true,\n        extrakey: true,\n        nkro: false, \n        bootmagic: false\n    },\n    layouts: {\n        LAYOUT: {\n            layout: \n                { label:K00, matrix: 0, 0], x: 0, y: 0 },\n                { label: K01, matrix: 0, 1], x: 1, y: 0 },\n                { label: K02, matrix: 0, 2], x: 2, y: 0 },\n                { label: K03, matrix: 0, 3], x: 3, y: 0 },\n                { label: K10, matrix: 1, 0], x: 0, y: 1 },\n                { label: K11, matrix: 1, 1], x: 1, y: 1 },\n                { label: K12, matrix: 1, 2], x: 2, y: 1 },\n                { label: K13, matrix: 1, 3], x: 3, y: 1 },\n                { label: K14, matrix: 1, 4], x: 4, y: 1 }\n            ]\n        }\n    }\n}\n\nThe Keymap\nIt still seems like there is something missing. The keycodes that each key produces. Thats in the ../hackaday/keymaps/default directory. Theres a json file you dont need to change and a C file:\n\n#include QMK_KEYBOARD_H\n\nconst uint16_t PROGMEM keymaps]MATRIX_ROWS]MATRIX_COLS] = {\n    0] = LAYOUT(\n        // 4 buttons\n        KC_KB_VOLUME_UP, KC_KB_MUTE, KC_KB_VOLUME_DOWN, KC_MEDIA_PLAY_PAUSE,\n        // Mouse\n        QK_MOUSE_CURSOR_UP, QK_MOUSE_CURSOR_DOWN, \n        QK_MOUSE_CURSOR_LEFT, QK_MOUSE_CURSOR_RIGHT,\n        QK_MOUSE_BUTTON_1 \n    ),\n};\n. . .\n\nMousing Around\nI didnt add the mouse commands until later. When I did, they didnt seem to work. Of course, I had to enable the mouse commands, but it still wasnt working. What bit me several times was that the QMK flash script (see below) doesnt wait for the Pi Pico to finish downloading. So you sometimes think its done, but it isnt. There are a few ways of solving that, as youll see.\nMiscellaneous and Building\nInstalling QMK is simple, but varies depending on your computer type. The documentation is your friend. Meanwhile, Ive left my fork of the official firmware for you. Be sure to switch to the rp2040 branch, or you wont see any differences from the official repo.\nThere are some build options you can add to rules.mk files in the different directories. There are plenty of APIs built into QMK if you want to play with, say, the display. You can also add code to your keymap.c (among other places) to run code on startup, for example. You can find out more about whats possible in the documentation. For example, if you wanted to try an OLED display, there are drivers ready to go.\nThe first time you flash, youll want to put your Pico in bootloader mode and then try this:\nqmk flash -kb handwired/hackaday/rp2040 -km default\nIf you arent ready to flash, try the compile command. You can also use clean to wipe out all the binaries. The binaries wind up in qmk_firmware/.build.\nOnce the bootloader is installed the first time (assuming you didnt change the setup), you can get back in bootloader mode by double-tapping the reset button. The onboard LED will light so you know it is in bootloader mode.\nIt is important to wait for the Pi to disconnect, or it may not finish programming. Adding a sync command to the end of your flash command isnt a bad idea. Or just be patient and wait for the Pi to disconnect itself.\nUsually, the device will reset and become a keyboard automatically. If not, reset it yourself or unplug it and plug it back in.\u00a0 Then youll be able to use the four buttons to adjust the volume and mute your audio. The joystick fakes being a mouse. Dont like that? Change it in keymap.c.\nTheres a lot more, of course, but this will get you started. Keeping it all straight can be a bit confusing at first, but once youve done it once, youll see theres not much you have to change. If you browse the documentation, youll see theres plenty of support for different kinds of hardware.\nWhat about debugging? Running some user code? Ill save that for next time.\nNow you can build your dream macropad or keyboard, or even use this to make fake keyboard devices that feed data from something other than user input. Just remember to drop us a note with your creations."}