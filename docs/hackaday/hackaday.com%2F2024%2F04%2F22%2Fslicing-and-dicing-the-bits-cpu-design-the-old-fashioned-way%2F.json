{"pubDate": "2024-04-22T17:00:38", "original_title": "Slicing and Dicing the Bits: CPU Design the Old Fashioned Way", "link": "https://hackaday.com/2024/04/22/slicing-and-dicing-the-bits-cpu-design-the-old-fashioned-way/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/04/am2901.png", "original_content": "Writing for Hackaday can be somewhat hazardous. Sure, we dont often have to hide from angry spies or corporate thugs. But we do often write about something and then want to buy it. Expensive? Hard to find? Not needed? Doesnt really matter. My latest experience with this effect was due to a recent article I wrote about the AM2900 bitslice family of chips. Many vintage computers and video games have them inside, and, as I explained before, they are like a building block you use to build a CPU with the capabilities you need. I had read about these back in the 1970s but never had a chance to work with them.\nAs I was writing, I wondered if there was anything left for sale with these chips. Turns out you can still get the chips  most of them  pretty readily. But I also found an eBay listing for an AM2900 learning and evaluation kit. How many people would want such a thing? Apparently enough that I had to bid a fair bit of coin to take possession of it, but I did. The board looked like it was probably never used. It had the warranty card and all the paperwork. It looked in pristine condition. Powering it up, it seemed to work well.\nWhat Is It?\nThe board hardly looks at least 40\u00a0 years old.\nThe board is a bit larger than a letter-sized sheet of paper. Along the top, there are three banks of four LEDs. The bottom edge has three banks of switches. One bank has three switches, and the other two each have four switches. Two more switches control the boards operation, and two momentary pushbutton switches.\nThe heart of the device, though, is the AM2901, a 4-bit slice. It isnt quite a CPU but more just the ALU for a CPU. Theres also an AM2909, which controls the microcode memory. In addition, theres a small amount of memory spread out over several chips.\nA real computer would probably have many slices that work together. It would also have a lot more microprogram memory and then more memory to store the actual program. Microcode is a very simple program that knows how to execute instructions for the CPU.\nFor example, suppose you wanted an instruction that added the A register to the B register and left the result in the A register. An imaginary microcode program might look like this:\n\nGate register A onto internal bus X\nGate register B onto internal bus Y\nSet ALU to compute X+Y\nGate ALU output to register A\n\nThe microcode would normally also fetch the next instruction, too.\nThe kit lacks any program memory and only has 16 memory slots for microprogram steps. So, in reality, you can probably fake a single instruction and see how it works. But thats about it. The example Ill show you is a simple microprogram that converts an 8-bit BCD number into the equivalent binary number. That is, 2 and 8 will convert to 1 and C (since everything is 4-bit). Even this takes all the memory the device has. So dont expect to emulate a VAX 11/730 (which did, incidentally, use 8 AM2901s).\nHow it Works\nThe board doesnt have a microcontroller, so everything is ordinary logic. It is set up to work with 4-bit numbers and a 32-bit microcode word. Since board space and LEDs were expensive then, everything works with 4 bits at a time. The right-hand bank of switches (the mux select) lets you put a binary number from 000 to 111 (0-7), and that controls which 4-bit part you are working with at any given time.\nThe LEDs on the left show a data display. Exactly what this means depends on the position of the mux select switches. For example, when the switches are at 001, the data LEDs show the output of the ALU. When the switches are at 010, the ALUs flags (for example, carry and zero) appear.\nThe other LEDs show four bits of the pipeline register  the instruction the board is about to execute  and the contents of the microprogram memory (again, the selected four bits).\n\nWhen the Run/Load switch is set to the load position, you can enter an address on the left-hand switches, and data bits on the middle switches. Then you press Memory Load. That means to completely enter a 32-bit microinstruction, you have to flip the mux switches 8 times and then enter each 4-bit value, one at a time.\nIf you flip to run, you can use the single step button to execute an instruction, or you can hook up an external clock and use that.\nThis is all confusing to read about, but the video below will help you see how this old hardware works.\n\nInternals\nInternally, you can see that the microprogram memory feeds the pipeline register. The address is from a multiplexer that can select an address from several sources. The pipeline register provides 32 bits that control everything from what the next address is to what the ALU does.\nBlock diagram of the board\nThere is a small PROM that serves as a lookup table to control the sequencer. This allows the instruction to use a small number of bits to control the AM2909 sequencer so that you can select the next address, have conditional jumps, or even push or pop the stack internal to the device.\nEssentially, the sequencer decides what word to execute, the AM2901 does most of the execution, and the rest is just memory and a little glue logic.\nIn a real system, you have to account for things like the carry flags and detecting a zero result. However, having only one slice makes things easier. The carry input is part of the microinstruction so you decide when theres a carry and when there isnt.\nMicroinstructions\nA scan of the manuals microcode instruction reference\nIn a real design, the microinstruction size and format were totally up to you. However, since we are using the evaluation board, you must use that format (see the figure below). Each instruction had several major parts: a way to specify what instruction would happen next, a source, and a destination along with an operation. In addition, there were two register fields and a data field (all, of course, four bits). Not all fields are used in every case.\nThis is a very flexible arrangement because you can, for example, do adding, shifting, and a conditional jump all in one instruction. However, it can take some getting used to. For example, loading a register is usually done by using a logical OR instruction with a constant zero.\nThe other thing that is strange is the pipelining. Because everything is set up at the start, a conditional jump doesnt apply to the line it is on but the line before. For example (in pseudo-code):\n\nGoto next, set Q to A+1\nIf zero goto bump, set B to B+1\n\nThe if in the second line will trigger on the addition done in the first line.\nAssembler\nA small excerpt of the assembler spreadsheet\nIf you watch the video, youll see that entering a full program is tedious and error-prone. To help, I created an assembler using Google Sheets. You can use symbols for addresses, registers, and constants. In most places, you can use a drop-down to pick among options. Theres a place for comments, too.\nOnce it is filled in, you can hide the source code using Control+Alt+Shift+2. That gives you a handy piece to read or print for putting the data into the board. Control+Alt+Shift+1 will restore the display.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAddress\nBranch\nNext\nMUX\nDEST\nSRC\nCARRY\nALU\nA\nB\nD\n\n\n0\n\nCONTINUE\n\nF-RAM (F)\nD 0\n\nR OR S\n\n!ILSD\n#Digit0\n\n\n1\n\nCONTINUE\n\nF-RAM (F)\nD 0\n\nR OR S\n\n!IMSD\n#Digit1\n\n\n2\n\nCONTINUE\n\nF-Q\nD 0\n\nR OR S\n\n\n0\n\n\n3\n\nCONTINUE\n2  Double\n2F, 2Q-RAM,Q\n0 B\n\nR OR S\n\n!RES0\n\n\n\n\nConsider the excerpt from the demo program above. The branch column could contain the next address to execute, but since each line has a continue, the address can be blank. The system will ignore it anyway.\nTo the right are the A, B, and D columns. The A and B columns are numbers from 0 to 15 signifying one of the ALUs internal registers. Here, we dont use A, so it is blank. The D field is for a four-bit constant if you need it.\nThe ALU column holds the operation to execute and the SRC column is what the inputs to that function are. In the first line, for example, we take D and OR it with zero. At address 3, however, the OR is between a zero and the contents of the B register.\nThe DEST column tells where the ALU result goes. In most of these lines, it goes to RAM, which is the register named in B. However, at address 2, the result goes to the Q register, which is internal to the AM2901. The destination for address 3 stores the result after doing a double (that is, 8-bit) shift to the left.\nObviously, a lot is going on here. If you want to know all about it, youll need to read the datasheets and the board manual. Ive left those for you over on Hackaday.io. Youll also find links to the assembler and some other material there.\nDont have a board? No problem. Ill make an emulator  also spreadsheet-based  available in the next installment along with more about the chips internals. If you missed the post that started me down this path, you can go back and read more about the internals and the devices history. There are plenty of emulators for machines that used the AM2901, although they probably mimic the behavior, not the circuit.\n"}