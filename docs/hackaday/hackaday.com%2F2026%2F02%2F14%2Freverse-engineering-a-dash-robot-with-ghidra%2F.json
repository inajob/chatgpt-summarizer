{"pubDate": "2026-02-15T00:00:50", "original_title": "Reverse Engineering a Dash Robot with Ghidra", "link": "https://hackaday.com/2026/02/14/reverse-engineering-a-dash-robot-with-ghidra/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2026/02/dash_reverse_engineering.png", "original_content": "\nOne of the joys of browsing secondhand shops is the possibility of finding old, perhaps restorable or hackable, electronics at low prices. Admittedly, they usually seem to be old flat-screen TVs, cheap speakers, and Blu-ray players, but sometimes you find something like the Dash, an educational toy robot. When [Jonathan] came across one of these, he decided to use it as a turtle robot. However, he found the available Python libraries insufficient, and improving on them required some reverse-engineering.\n\nWhile [Jonathan] was rather impressed with the robot as it was \u2013 it had a good set of features, and thought had clearly been put into the design \u2013 he wanted a more open way to control it. There was already a quite useful, official Python program to control the robot over a BLE connection, but it only worked with Python 2 on OS X ([Jonathan] theorizes that it might have been written as a development tool, open-sourced, and not diligently supported afterwards). There were also a few third-party libraries ported to Python 3, but they all seemed to be missing some important features.\nAll the newer libraries were limited because the official library passed commands to an OS X binary, which handled the actual communication, so anyone wanting to do everything in Python would have to reverse-engineer the communications protocol. [Jonathan] therefore used Ghidra to decompile the binary. He first found the JSON structure used for message data, followed by a function that reads command information and sets up packets, and a mapping between Python command names and command IDs. Once he found the section that creates packets from data, he was able to port the program to Python 3. Interestingly, examining the binary revealed some previously unknown commands that appear to be capable of defining autonomous behavior.\nWe\u2019ve previously seen Ghidra used on devices ranging from a camera to a router; if you\u2019d like to learn more, there\u2019s a HackadayU course on it.", "title": "\u4e2d\u53e4\u96fb\u5b50\u6a5f\u5668\u306e\u6398\u308a\u51fa\u3057\u7269\uff1a\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u30a2\u30bb\u30f3\u30d6\u30eb\u306b\u6311\u6226  ", "body": "\u4e2d\u53e4\u30b7\u30e7\u30c3\u30d7\u3067\u898b\u3064\u3051\u305f\u30ed\u30dc\u30c3\u30c8\u3092\u6539\u9020\u3057\u3001Python 3\u306b\u79fb\u690d\u3057\u305f\u8a71\u3002", "titles": ["\u4e2d\u53e4\u96fb\u5b50\u6a5f\u5668\u306e\u6398\u308a\u51fa\u3057\u7269\uff1a\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u30a2\u30bb\u30f3\u30d6\u30eb\u306b\u6311\u6226  ", "\u6559\u80b2\u7528\u30ed\u30dc\u30c3\u30c8\u3092\u6539\u9020\u305b\u3088\uff1aPython\u3067\u306e\u5236\u5fa1\u3092\u76ee\u6307\u3057\u3066  ", "Ghidra\u3092\u4f7f\u3063\u305f\u9006\u89e3\u6790\uff1a\u30ed\u30dc\u30c3\u30c8\u901a\u4fe1\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u89e3\u660e  ", "Python 3\u3078\u306e\u79fb\u690d\uff1a\u53e4\u3044\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u9650\u754c\u3092\u7a81\u7834  ", "\u81ea\u5f8b\u884c\u52d5\u3092\u5f15\u304d\u51fa\u3059\uff1a\u30ed\u30dc\u30c3\u30c8\u306e\u96a0\u308c\u305f\u6a5f\u80fd\u3092\u767a\u898b"]}