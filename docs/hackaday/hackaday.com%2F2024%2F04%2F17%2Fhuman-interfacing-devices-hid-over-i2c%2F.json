{"pubDate": "2024-04-17T14:30:40", "original_title": "Human-Interfacing Devices: HID over I2C", "link": "https://hackaday.com/2024/04/17/human-interfacing-devices-hid-over-i2c/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/05/Logic.jpg", "original_content": "In the previous two HID articles, we talked about stealing HID descriptors, learned about a number of cool tools you can use for HID hacking on Linux, and created a touchscreen device. This time, lets talk about an underappreciated HID standard, but one that you might be using right now as youre reading this article  I2C-HID, or HID over I2C.\nHID as a protocol can be tunneled over many different channels. If youve used a Bluetooth keyboard, for instance, youve used tunneled HID. For about ten years now, I2C-HID has been heavily present in laptop space, it was initially used in touchpads, later in touchscreens, and now also in sensor hubs. Yes, you can expose sensor data over HID, and if you have a clamshell (foldable) laptop, thats how the rotation-determining accelerometer exposes its data to your OS.\nThis capacitive touchscreen controller is not I2C-HID, even though it is I2C. By [Raymond Spekking], CC-BY-SA 4.0Not every I2C-connected input device is I2C-HID. For instance, if youve seen older tablets with I2C-connected touchscreens, dont get your hopes up, as they likely dont use HID  its just a complex-ish I2C device, with enough proprietary registers and commands to drive you crazy even if your logic analysis skills are on point. I2C-HID is nowhere near that, and its also way better than PS/2 we used before  an x86-only interface with limited capabilities, already almost extinct from even x86 boards, and further threatened in this increasingly RISCy world. I2C-HID is low-power, especially compared to USB, as capable as HID goes, compatible with existing HID software, and ubiquitous enough that you surely already have an I2C port available on your SBC.\nIn modern world of input devices, I2C-HID is spreading, and the coolest thing is that its standardized. The standardization means a lot of great things for us hackers. For one, unlike all of those I2C touchscreen controllers, HID-I2C devices are easier to reuse; as much as information on them might be lacking at the moment, thats what were combating right now as we speak! If you are using a recent laptop, the touchpad is most likely I2C-HID. Today, lets take a look at converting one of those touchpads to USB HID.\nA Hackable Platform\n\nTwo years ago, I developed a Framework laptop input cover controller board. Back then, I knew some things about I2C-HID, but not too much, and it kinda intimidated me. Still, I wired up the I2C pins to an I2C port on an RP2040, wired up the INT pin to a GPIO, successfully detected an I2C device on those I2C pins with a single line of MicroPython code, and left sitting on my desk out of dread over converting touchpad data into mouse events  as it turns out, it was way simpler than I thought.\nTheres a specification from Microsoft, and it might be your first jumping point. I tried reading the specification, but I didnt understand HID at the time either, so that didnt help much. Looking back, the specification is pretty hard to read, regardless. Heres the deal in the real world.\nIf you want to get the HID descriptor from an I2C-HID device, you only need to read a block of data from its registers. Receiving reports (HID event packets) is simple, too. When the INT pin goes low, read a block of data from the device  you will receive a HID report. If theres an RST pin, you will want to bring it down upon bootup for a few hundred milliseconds to reset the device, and you can use it in case your I2C-HID device malfunctions, too.\nNow, there are malfunctions, and there definitely will be quirks. Since HID is ubiquitous, there are myriad ways for manufacturers to abuse it. For instance, touchpads are so ubiquitous that Chrome OS has entire layers dealing with their quirks. But here we are, and I have an I2C device connected to an RP2040, previous MicroPython I2C work in hand, some LA captures between the touchpad and the original system stashed away, and Im ready to send it all commands it needs.\nPoking And Probing\nTo read the descriptor, you can read a block from register 0x20, where the first four bytes define the descriptor version and the descriptor length  counting these four bytes in. When we put this descriptor into the decoder, we will get something like this:\n[...]\n0x05, 0x0D,        // Usage Page (Digitizer)\n0x09, 0x05,        // Usage (Touch Pad)\n0xA1, 0x01,        // Collection (Application)\n0x85, 0x01,        //   Report ID (1)\n0x05, 0x0D,        //   Usage Page (Digitizer)\n0x09, 0x22,        //   Usage (Finger)\n0xA1, 0x02,        //   Collection (Logical)\n0x09, 0x47,        //     Usage (Confidence)\n0x09, 0x42,        //     Usage (Tip Switch)\n0x15, 0x00,        //     Logical Minimum (0)\n0x25, 0x01,        //     Logical Maximum (1)\n[...]\nThat is a HID descriptor for a touchpad alright! Save this descriptor somewhere  while getting it dynamically is tempting, hardcoding it into your firmware also might be a viable decision, depending on which kind of firmware youll be adding I2C-HID support into, and, youll really want to have it handy as a reference. Put this descriptor into our favourite decoder website, and off we go! Oh, and if you cant extract the descriptor from the touchpad for whatever reason, you can get it from inside a running OS like Ive done in the last article  thats what I ended up doing, because I couldnt make MicroPython fetch the descriptor properly.\nFor some reason, Microsoft decided to distribute this spec as a .docx file, something that I immediately abused as a way of stress relief\nTake a look at the report IDs  they can be helpful later. All reports coming from the touchpad will have their report ID attached, and its good to know just which kinds of events you can actually expect. Also, heres a challenge  try to spot the reports used for BIOS simple mouse functionality, firmware update, touchpad calibration, and any proprietary features!\nNow, all thats left is getting the reports. This is simple too  you dont even need to read a block from a register, just a block of data from the touchpad. First, you read a single byte, which tells you how many more bytes you need to read to get the actual packet. Then you read a byte once INT is asserted (set low). That means the touchpad has data for you. If your INT doesnt work for some reason, as it was on my board, you could continuously poll the touchpad in a loop instead, reading a single byte each time, and reading out a full packet when the first byte isnt 0x00. Then, its the usual deal  first byte is the report ID, and all other bytes are the actual report contents. For I2C code of the kind that our last article uses, reading a report works like this:\n\nwhile True:\n    try:\n    l = i2c.readfrom(0x2c, 1)[0]\n    if l:\n        d = i2c.readfrom(0x2c, l)\n        if d[2] != 0x01:\n            # only forward packets with a specific report ID, discard all others\n            print(WARNING)\n            print(l, d)\n            print(WARNING)\n        else:\n            d = d[3:]\n            print(l, len(d), d)\n            usb_hid.report(usb_hid.MOUSE_ABS, d)\n    except OSError:\n    # touchpad unplugged? retry in a bit\n    sleep(0.01)\n\nNow, touch the touchpad, and see. Got a report? Wonderful! Havent received anything yet? There are a few things to check. First, your touchpad might require a TP_EN pin to be asserted low or high. Also, if your touchpad has a TP_RST pin, you might need to pull it low on startup for a couple hundred milliseconds. Other than that, if your touchpad is from a reasonably popular laptop, see if theres any references for its quirks in the Linux kernel, or any of the open firmwares out there.\nFurther Integration\nTheoretically, you could write a pretty universal I2C-HID to USB-HID converter seriously easily  that would allow things like USB-connected touchpads on the cheap, just like some people have been doing with PS/2 in the good old days. For me, theres an interesting question  how do you actually integrate this into a keyboard firmware? There are a few options. For instance, you could write a QMK module for dealing with any sort of I2C-HID device, thatd pass through reports from the touchpad and generate its own reports for keyboard reports. That is a viable option for most of you; for me, C++ is not my friend as much as Id like it to be.\nTheres the MicroPython option weve explored last article, and thats what Im using for forwarding at the moment. This option needs the descriptor translated into TUSB macros, which took a bit of time, but I could make it work. Soon, USB device support will be added into the new MicroPython release, which will make my translation work obsolete in all the best ways, but it isnt merged just yet. More importantly, however, theres no stock keyboard code I could find thats compatible with this firmware, and as much as it could be educational, Im not looking into writing my own keyboard scanning code.\nCurrently, Im looking into a third option, KMK. A CircuitPython-based keyboard firmware, it should allow things like dynamic descriptor definitions, which lets us save a fair bit of time when iterating on descriptor hacking, especially compared to the MicroPython fork.\nAll of these options need you to merge keyboard and touchpad descriptors into one, which makes sense. The only caveat is the question of conflicting report IDs between the stock firmware keyboard descriptor and the stock touchpad descriptor. For fixing that, youd want to rewrite report IDs on the fly  not that its complicated, just a single byte substitution, but its a good caveat to keep in mind! My touchpad code already does this because the library does automatic report ID insertion, but if yours doesnt, make sure theyre changed.\nEven Easier Reuse\nNow, all of this was about tunneling I2C-HID-obtained HID events into USB. Are you using something like a Raspberry Pi? Good news! Theres i2c-hid support in Linux kernel, which only really wants the IRQ GPIO and the I2C address of your I2C device. Basically, all you need to do is to add a device tree fragment and some very minimal data. I dont have a tutorial for this, but theres some initial documentation in the kernel tree, and grepping the device tree directory for the overlay name alone should give you a wonderful start.\nThis article isnt long, and thats because of just how easy I2C-HID is to work with. Now, of course, there are quirks  just check out this file for some examples. Still, its nothing that you couldnt figure out with a logic analyzer, and now you can see just how easy this is. I hope that this can help you on your hacking forays, so whenever you next see a laptop touchpad, you know just how easy they can be to wire up, no matter if youre using a microcontroller or a Raspberry Pi."}