{"pubDate": "2024-07-11T14:00:24", "original_title": "Embedded Python: MicroPython Is Amazing", "link": "https://hackaday.com/2024/07/11/embedded-python-micropython-is-amazing/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/06/Python.jpg", "original_content": "In case you havent heard, about a month ago MicroPython has celebrated its 11th birthday. I was lucky that I was able to start hacking with it soon after pyboards have shipped  the first tech talk I remember giving was about MicroPython, and that talk was how I got into the hackerspace I subsequently spent years in. Since then, MicroPython been a staple in my projects, workshops, and hacking forays.\nIf youre friends with Python or youre willing to learn, you might just enjoy it a lot too. Whats more, MicroPython is an invaluable addition to a hackers toolkit, and Id like to show you why.\nHacking At Keypress Speed\nGot a MicroPython-capable chip? Chances are, MicroPython will serve you well in a number of ways that you wouldnt expect. Heres a shining example of what you can do. Flash MicroPython onto your board  Ill use a RP2040 board like a Pi Pico. For a Pico, connect an I2C device to your board with SDA on pin 0 and SCL on pin 1, open a serial terminal of your choice and type this in:\n\n from machine import I2C, Pin\n i2c = I2C(0, sda=Pin(0), scl=Pin(1))\n i2c.scan()\n\nThis interactivity is known as REPL  Read, Evaluate, Print, Loop. The REPL alone makes MicroPython amazing for board bringup, building devices quickly, reverse-engineering, debugging device library problems and code, prototyping code snippets, writing test code and a good few other things. You can explore your MCU and its peripherals at lightning speed, from inside the MCU.\nWhen I get a new I2C device to play with, the first thing I tend to do is wiring it up to a MicroPython-powered board, and poking at its registers. Its as simple as this:\n\n for i in range(16):\n     # read out registers 0-15\n     # print address value for each\n     print(hex(i), i2c.readfrom_mem(0x22, i))\n # write something to a second (0x01) register\n i2c.writeto_mem(0x22, 0x01, bytes([0x01]) )\n\nThat i2c.scan() line alone replaces an I2C scanner program youd otherwise have to upload into your MCU of choice, and you can run it within three to five seconds. Got Micropython running? Use serial terminal, Ctrl+C, and that will drop you into a REPL, just type i2c.scan() and press Enter. Whats more, you can inspect your codes variables from the REPL, and if you structure your code well, even restart your code from where it left off! This is simply amazing for debugging code crashes, rare problems, and bugs like it stops running after 20 days of uptime. In many important ways, this removes the need for a debugger  you can now use your MCU to debug your code from the inside.\nOh, again, that i2c.scan()? You can quickly modify it if you need to add features on the fly. Want addresses printed in hex? (hex(addr) for addr in i2c.scan()). Want to scan your bus while youre poking your cabling looking for a faulty wire? Put the scan into a while True: and Ctrl+C when youre done. When using a typical compiled language, this sort of tinkering requires an edit-compile-flash-connect-repeat cycle, taking about a dozen seconds each time you make a tiny change. MicroPython lets you hack at the speed of your keyboard typing. Confused the pins? Press the `up` button, edit the line and run the i2c =  line anew.\nTo be clear, all of code is running on your microcontroller, you just type it into your chips RAM and it is executed by your MCU. Heres how you check GPIOs on your Pi Pico, in case youre worried that some of them have burnt out:\n\n from machine import Pin\n from time import sleep\n pin_nums = range(30) # 0 to 29\n # all pins by default - remove the ones connected to something else if needed\n pins = [Pin(num, Pin.OUT) for num in pin_nums]\n \n while True:\n   # turn all pins on\n   for i in range(len(pins)):\n     pins[i].value(True)\n   sleep(1)\n   # turn all pins off\n   for i in range(len(pins)):\n     pins[i].value(False)\n   sleep(1)\n   # probe each pin with your multimeter and check that each pin changes its state\n\nTheres many things that make MicroPython a killer interpreter for your MCU. Its not just the hardware abstraction layer (HAL), but its also the HAL because moving your code from board to board is generally as simple as changing pin definitions. But its all the other libraries that you get for free that make Python awesome on a microcontroller.\nBatteries Included\nIt really is about the batteries  all the libraries that the stock interpreter brings you, and many more that you can download. Only an import away are time, socket, json, requests, select, re and many more, and overwhelmingly, they work the same as CPython. You can do the same r = requests.get(\"https://retro.hackaday.com\"); print(r.text)[:1024] as you would do on desktop Python, as long as you got a network connection going on. There will be a few changes  for instance, time.time() is an integer, not a float, so if you need to keep track of time very granularly, there are different functions you can use.\nSay, you want to parse JSON from a web endpoint. If youre doing that in an Arduino environment, chances are, you will be limited in what you can do, and you will get triangle bracket errors if you mis-use the JSON library constructs because somehow the library uses templates; runtime error messages are up to you to implement. If you parse JSON on MicroPython and you expect a dict but get a list in runtime, it prints a readable error message. If you run out of memory, you get a very readable MemoryError printed out, you can expect it and protect yourself from it, even fix things from REPL and re-run the code if needed.\nThe user-supplied code is pretty good, too. If you want PIO or USB-HID on the RP2040, or ESP-CPU-specific functions on the ESP family, they are exposed in handy libraries. If you want a library to drive a display, it likely already has been implemented by someone and put on GitHub. And, if that doesnt exist, you port one from Arduino and publish it; chances are, it will be shorter and easier to read. Of course, MicroPython has problems. In fact, Ive encountered a good few problems myself, and I would be amiss not mentioning them.\nMind The Scope\nIn my experience, the single biggest problem with MicroPython is that writing out `MicroPython` requires more of my attention span than I can afford. I personally shorten it to uPy or just upy, informally. Another problem is that the new, modernized MicroPython logo has no sources or high-res images available, so I cant print my own stickers of it, and MicroPython didnt visit FOSDEM this year, so I couldnt replenish my sticker stock.\nOn a more serious note, MicroPython as a language has a wide scope of where you can use it; sometimes, it wont work for you. An ATMega328P cant handle it  but an ESP8266 or ESP32 will easily, without a worry in the world, and you get WiFi for free. If you want to exactly control what your hardware does, counting clock cycles or hitting performance issues, MicroPython might not work for you  unless you write some Viper code.\nIf you want to have an extremely-low-power MCU that runs off something like energy harvesting, MicroPython might not work  probably. If you need your code run instantly once your MCU gets power, mind the interpreter takes a small bit of time to initialize  about one second, in my experience. If you want to do HDMI output on a RP2040, perhaps stick to C  though you can still do PIO code, there are some nice libraries for it.\nSome amount of clock cycles will be spent on niceties that Python brings. Need more performance? There are things you can do. For instance, if you have a color display connected over SPI and you want to reduce frame rendering time, you might want to drop down to C, but you dont have to ditch MicroPython  just put more of your intensive code into C-written device drivers or modules you compile, and, prototype it in MicroPython before you write it.\nAs Seen On Hackaday\nIf youve followed the USB-C PD talking series, you mustve seen that the code was written in MicroPython, and Ive added features like PD sniffing, DisplayPort handling and PSU mode as if effortlessly; it was just that easy to add them and more. I started with the REPL, a FUSB302 connected to a RP2040, poking at registers and reading the datasheet, and while I needed outside help, the REPL work was so so much fun!\nTheres something immensely satisfying about poking at a piece of technology interactively and trying to squeeze features out of it, much more if it ends up working, which it didnt, but it did many other times! Ive been hacking on that PD stack, and now Im slowly reformatting it from a bundle of functions into object-based code  Python makes that a breeze.\nRemember the Sony Vaio board? Its EC (embedded controller) is a RP2040, always powered on as long as batteries are inserted, and its going to be running MicroPython. The EC tasks include power management, being a HID over I2C peripheral, button and LED control, and possibly forwarding keyboard and trackpoint events to save a USB port from the second RP2040, which will run QMK and server as a keyboard controller. MicroPython allows me to make the firmware quickly, adorn it with a dozen features while I do it, and keep the codebase expandable on a whim. The firmware implementation will be a fun journey, and I hope I can tell about it at some point.\nHave you used MicroPython in your projects? What did it bring to your party?"}