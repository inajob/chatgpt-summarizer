{"pubDate": "2024-11-26T18:00:46", "original_title": "Linux Fu: Audio Network Pipes", "link": "https://hackaday.com/2024/11/26/linux-fu-audio-network-pipes/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "Life was simpler when everything your computer did was text-based. It is easy enough to shove data into one end of a pipe and take it out of the other. Sure, if the pipe extends across the network, you might have to call it a socket and take some special care. But how do you pipe all the data we care about these days? In particular, I found I wanted to transport audio from the output of one program to the input of another. Like most things in Linux, there are many ways you can get this done and  like most things in Linux  only some of those ways will work depending on your setup.\nWhy?\nThere are many reasons you might want to take an audio output and process it through a program that expects audio input. In my case, it was ham radio software. Ive been working on making it possible to operate my station remotely. If all you want to do is talk, it is easy to find software that will connect you over the network.\nHowever, if you want to do digital modes like PSK31, RTTY, or FT8, you may have a problem. The software to handle those modes all expect audio from a soundcard. They also want to send audio to a soundcard. But, in this case, the data is coming from a program.\nOf course, one answer is to remote desktop into the computer directly connected to the radio. However, most remote desktop solutions arent made for high-fidelity and low-latency audio. Plus, it is nice to have apps running directly on your computer.\nIll talk about how Ive remoted my station in a future post, but for right now, just assume we want to get a programs audio output into another programs audio input.\nSound System Overview\nSomeone once said, The nice thing about standards is there are so many of them. This is true for Linux sound, too. The most common way to access a soundcard is via ALSA, also known as Advanced Linux Sound Architecture. There are other methods, but this is somewhat the lowest common denominator on most modern systems.\nHowever, most modern systems add one or more layers so you can do things like easily redirect sound from a speaker to a headphone, for example. Or ship audio over the network.\nThe most common layer over ALSA is PulseAudio, and for many years, it was the most common standard. These days, you see many distros moving to PipeWire.\nPipeWire is newer and has a lot of features but perhaps the best one is that it is easy to set it up to look like PulseAudio. So software that understands PipeWire can use it. Programs that dont understand it can pretend it is PulseAudio.\nThere are other systems, too, and they all interoperate in some way. While OSS is not as common as it once was, JACK is still found in certain applications. Many choices!\nOne Way\nThere are many ways you can accomplish what I was after. Since I am running PipeWire, I elected to use qpwgraph, which is a GUI that shows you all the sound devices on the system and lets you drag lines between them.\nIt is super powerful but also super cranky. As things change, it tends to want to redraw the graph, and it often does it in a strange and ugly way. If you name a block to help you remember what it is and then disconnect it, the name usually goes back to the default. But these are small problems, and you can work around them.\nIn theory, you should be able to just grab the output and wire it to the other programs input. In fact, that works, but there is one small problem. Both PipeWire and PulseAudio will show when a program is making sound, and then, when it stops, the source vanishes.\nThis makes it very hard to set up what I wanted. I wound up using a loopback device so there was something for the receiver to connect to and the transient sending device.\nHeres the graph I wound up with:\nA partial display of the PipeWire configuration\nI omitted some of the devices and streams that didnt matter, so it looks pretty simple. The box near the bottom right represents my main speakers. Note that the radio speaker device (far left) has outputs to the speaker and to the JTDX in box.\nThis lets me hear the audio from the radio and allows JTDX to decode the FT8 traffic. Sending is a little more complicated.\nThe radio-in boxes are the loopback device. You can see it hooked to the\u00a0 JTDX out box because when I took the screenshot, I was transmitting. If I were not transmitting, the out box would vanish, and only the pipe would be there.\nEverything that goes to the pipes input also shows up as the pipes output and thats connected directly to the radio input. I left that box marked with the default name instead of renaming it so you can see why it is worth renaming these boxes! If you hover over the box, youll see the full name which does have the application name in it.\nThat means JTDX has to be set to listen and send to the streams in question. The radio also has to be set to the correct input and output. Usually, setting them to Pulse will work, although you might have better luck with the actual pipe or sink/source name.\nIn order to make this work, though, I had to create the loopback device:\npw-loopback -n radio-in -m '[FL FR]' --capture-props='[media.class=Audio/Sink]' --playback-props='[media.class=Audio/Source]' \nThis creates the device as a sink with stereo channels that connect to nothing by default. Sometimes, I only connect the left channels since thats all I need, but you may need something different.\nOther Ways\nThere are many ways to accomplish this, including using the pw-link utility or setting up special configurations. The PipeWire documentation has a page that covers at least most of the scenarios.\nYou can also create this kind of virtual device and wiring with PulseAudio. If you need to do that, investigate the pactl command and use it to load the module-loopback module.\nIt is even possible to use the snd-aloop module to create loopback devices. However, PipeWire seems to be the future, so unless you are on an older system, it is probably better to stick to that method.\nSound Off!\nWhats your favorite way to route audio? Why do you do it? What will you do with it? Ill have a post detailing how this works to allow remote access to a ham transceiver, although this is just a part of the equation. It would be easy enough to use something like this and socat to stream audio around the network in fun ways.\nWeve talked about PipeWire for audio and video before. Of course, connecting blocks for audio processing makes us want to do more GNU Radio."}