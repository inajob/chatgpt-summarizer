{"pubDate": "2025-01-20T15:00:29", "original_title": "Time-of-Flight Sensors: How Do They Work?", "link": "https://hackaday.com/2025/01/20/time-of-flight-sensors-how-do-they-work/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/01/tof.png", "original_content": "With the right conditions, this tiny sensor can measure 12 meters\nIf you need to measure a distance, it is tempting to reach for the ubiquitous ultrasonic module like an HC-SR04. These work well, and they are reasonably easy to use. However, they arent without their problems. So maybe try an IR time of flight sensor. These also work well, are reasonably easy to use, and have a different set of problems. I recently had a project where I needed such a sensor, and I picked up a TF-MiniS, which is a popular IR distance sensor. They arent very expensive, and they work serial or I2C. So how did it do?\nThe unit itself is tiny and has good specifications. You can fit the 42 x 15 x 16 mm module anywhere. It only weighs about five grams  as the manufacturer points out, less than two ping-pong balls. It needs 5 V but communicates using 3.3 V, so integration isnt much of a problem.\nAt first glance, the range is impressive. You can read things as close as 10 cm and as far away as 12 m. I found this was a bit optimistic, though. Although the product sometimes gets the name of LiDAR, it doesnt use a laser. It just uses an IR LED and some fancy optics.\n\nHow it Works\nThe simple explanation for how these sensors work is that they bounce light off a target and measure how long it takes to see the reflection. This is oversimplified, but one thing to keep in mind is that light is fast. To measure a millimeter, you need to measure a difference of less than 7 picoseconds. Light travels 1 mm in 3.3 picoseconds, and then the return flight doubles that.\nHow time of flight works (from the TFmini-S Product Guide)\nBecause of practical considerations, there are typically a few specialized techniques used. A pulsed sensor turns the illumination on and off and samples pixels to determine the ratio of the overlap in the outbound beam and the reflected light.\nIt is also possible to sample four measurements on each cycle (that is, four measurements 90 degrees apart) and compute the distance with some fancy trigonometry. TI has a paper that goes into some detail. Or, if you prefer video, they have a video on the topic, too, which you can see below.\n\nPractical Concerns\nOf course, you cant measure infinitesimally small times, so the sensors are typically blind when you get too close. This sensor claims to be able to read as little as 10 cm. However, if you read closely, youll see that if the total distance is under 6 meters, the sensor is only accurate to within plus or minus 6 cm. So at 10 cm, you might read 4 cm to 16 cm, which is a pretty big difference.\nAmbient light can affect measurements, too. One thing you might not think about is that it also matters how reflective the target item is. All of these things can reduce the 12-meter range.\nYou really want a flat target (image from the TFmini-S product manual)\nYou also have to think about the field of view. The further away something is, the larger it needs to be. At 12 meters, for example, the target has to be at least 42 cm on a side to present a big enough target. At 1 meter, a 3.5 cm side will suffice.\nThe target must also be fairly flat in the field of view. If the sensor sees a partial reflection at one distance and more reflection at a further distance, youll get an inaccurate reading. None of these things are insurmountable, of course.\nConnecting isnt hard. You use the red/black wires for 5 V power. A 3.3 V serial port is on the white and green wires: white is the line the unit receives data on. Weve read that if you hook these up backwards or overvolt them, theyll die. We didnt test that.\nCode\nIt is pretty easy to write some MicroPython code to get some readings. You can download the code to try it out. The heart of it is very simple:\n\nwhile True:\n   total_distance = 0\n   valid_samples = 0\n   for _ in range(NUM_SAMPLES):\n      distance, strength, _ = get_lidar_data()\n      if distance = 0 and strength = 100:  # throw out weak values or errors\n         total_distance += distance\n         valid_samples += 1                  # only count good values\n   if valid_samples  0:\n      print(total_distance / valid_samples)\n\nBy default, the device sends data out frequently. If you want to change things, you can and you can even save your setup so that it will continue to operate to your last settings.\nThe output is two 0x59 bytes followed by the distance (two bytes), the strength (two bytes, LSB), a device temperature (two bytes), and a checksum. All the two-byte values are least-significant byte first.\nCommands all start with 0x5A and the length of the packet. Then theres a command code, any data the command needs, and a checksum. Many of the commands are fixed, so the checksum is already computed in the documentation for you.\nSpeaking of documentation, if you want to write your own code, you dont really need the datasheet. You do want the Product Manual from the Benewake website. The commands are all in that document. You can switch to a readout in millimeters or centimeters. You can set how often the system sends data. You can also put it in a polling mode. The slowest you can get data is once per second.\nIn Use\nA simple but effective test setup.\nSo how did it work? Some informal testing on the bench wasnt too bad. The error at near distances was within range but pretty bad at about 3 cm. However, it looked relatively constant, so you can account for it in your code. We dont know if different materials or different sensors would require different offsets, but wed guess they do.\nThere was some very small noise in the sensor output, but, honestly, not much. There were no wild results to filter out. Averaging didnt buy much because the output was pretty stable already.\nConclusion\nLike most things, this is a good solution if you need it, but there are other options, and you have to weigh the pros and cons of each method. Of course, you can build your own, which might help you optimize. Sometimes, the ultrasonic sensors are just fine.", "title": "- \u8d85\u5c0f\u578bIR\u8ddd\u96e2\u30bb\u30f3\u30b5\u30fcTF-MiniS\u306e\u6027\u80fd\u3068\u4ed5\u69d8", "body": "IR\u8ddd\u96e2\u30bb\u30f3\u30b5\u30fcTF-MiniS\u306f\u3001\u5c0f\u578b\u3067\u6700\u592712\u30e1\u30fc\u30c8\u30eb\u6e2c\u5b9a\u53ef\u80fd\u3002\u305f\u3060\u3057\u3001\u8fd1\u8ddd\u96e2\u3067\u7cbe\u5ea6\u304c\u4f4e\u4e0b\u3059\u308b\u3002", "titles": ["- \u8d85\u5c0f\u578bIR\u8ddd\u96e2\u30bb\u30f3\u30b5\u30fcTF-MiniS\u306e\u6027\u80fd\u3068\u4ed5\u69d8", "- \u8ddd\u96e2\u6e2c\u5b9a\u306b\u304a\u3051\u308bTF-MiniS\u306e\u5229\u70b9\u3068\u6b20\u70b9", "- IR\u30bf\u30a4\u30e0\u30aa\u30d6\u30d5\u30e9\u30a4\u30c8\u30bb\u30f3\u30b5\u30fc\u306e\u52d5\u4f5c\u539f\u7406\u3092\u89e3\u8aac", "- TF-MiniS\u3092\u4f7f\u7528\u3057\u305f\u8ddd\u96e2\u6e2c\u5b9a\u306e\u5b9f\u7528\u7684\u306a\u8003\u616e\u4e8b\u9805", "- MicroPython\u3092\u4f7f\u7528\u3057\u305fTF-MiniS\u306e\u8aad\u307f\u53d6\u308a\u30b3\u30fc\u30c9\u306e\u89e3\u8aac"]}