{"pubDate": "2025-05-05T08:00:10", "original_title": "The Convoluted Way Intel\u2019s 386 Implemented its Registers", "link": "https://hackaday.com/2025/05/05/the-convoluted-way-intels-386-implemented-its-registers/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/05/80386_ken_shirriff_registers-labeled.jpg", "original_content": "The fact that modern-day x86 processors still pretty much support the same operating systems and software as their ancestors did is quite a feat. Much of this effort had already been accomplished with the release of the 80386 (later 386) CPU in 1985, which was not only the first 32-bit x86 CPU, but was also backwards compatible with 8- and 16-bit software dating back to the 1970s. Making this work transparently was anything but straightforward, as [Ken Shirriff]s recent analysis of the 80386s main register file shows.\nLabelled Intel 80386 die shot. (Credit: Ken Shirriff)\nUsing die shots of the 386s registers and surrounding silicon, its possible to piece together how backwards compatibility was implemented. The storage cells of the registers are implemented using static memory (SRAM) as is typical, with much of the register file triple-ported (two read, one write).\nMost interestingly is the presence of different circuits (6) to support accessing the register file for 8-, 16- or 32-bit writes and reads. The shuffle network as [Ken] calls it is responsible for handling these distinct writes and reads, which also leads to the finding that the bottom 16 bits in the registers are actually interleaved to make this process work smoother.\nFortunately for Intel (and AMD) engineers, this feat wouldnt have to be repeated again with the arrival of AMD64 and x86_64 many years later, when the 386s mere 275,000 transistors on a 1 \u00b5m process would already be ancient history.\nWant to dive even deeper in to the 386? This isnt the first time [Ken] has looked at the iconic chip."}