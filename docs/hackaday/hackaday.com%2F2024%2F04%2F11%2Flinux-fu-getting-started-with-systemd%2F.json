{"pubDate": "2024-04-11T14:00:26", "original_title": "Linux Fu: Getting Started with Systemd", "link": "https://hackaday.com/2024/04/11/linux-fu-getting-started-with-systemd/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2018/06/linuxfu.jpg", "original_content": "I will confess. I started writing this post about some stupid systemd tricks. However, I wanted to explain a little about systemd first, and that wound up being longer than the tricks. So this Linux Fu will be some very fundamental systemd information. The next one will have some examples, including how to automount a Raspberry Pi Pico. Of course, by the end of this post, youll have only scratched the surface of systemd, but I did want to give you some context for reading through the rest of it.\nLike many long-time Unix users, Im not a big fan of systemd. Then again, Im also waiting for the whole windows, icon, mouse, pointer fad to die down. Like it or not, systemd is here and probably here to stay for the foreseeable future. I dont want to get into a flame war over systemd. Love it or hate it, it is a fact of life. I will say that it does have some interesting features. I will also say that the documentation has gotten better over time. But I will also say that it made many changes that perhaps didnt need to be made and made some simple things more complicated than they needed to be.\nIn the old days, we used init scripts, and you can still do so if you are really motivated. They werent well documented either, but it was pretty easy to puzzle out the shell scripts that would run, and we all know how to write shell scripts. The systemd way is to use services that are not defined by shell scripts. However, systemd tries to do lots of other things, too. It can replace cron and run things periodically. It can replace inetd, syslog, and many other traditional services. This is a benefit or a drawback, depending on your point of view.\n(Editors note: And this logging functionality was exactly what was abused in last weeks insane liblzma / ssh backdoor.)\nConfiguring systemd requires you to create files in one of several locations. In systemd lingo, they are units. For the purpose of this Linux Fu, well look at only a few kinds of units: services, mounts, and timers. Services let you run programs in response to something like system start-up. You can require that certain other services are already running or are not running and many other options. If the service dies, you can ask systemd to automatically restart it, or not. Timers can trigger a service at a particular time, much like cron does. Another unit youll run into are sockets that represent  you guessed it  a network socket.\n\nBasics\nIf you havent used systemd, the main interface to it is systemctl (not sysctl, which is something different). With it, you can enable and disable units, which are usually services. So, for example, my ssh server is a service unit. By defining a unit, someone could say, Well, if you are starting in multiuser mode, wait for networking to be available and run the ssh server. Or, sort of like inetd, run the ssh server when someone opens a connection on port 22. Not all units are services. Some are network sockets, and some are timers. There are other kinds, too. A timer is like a cron job. You can set them up to run every so often.\nSystemd maintains two sets of units. One set is for the system, and you need to be root to work with those. But it also manages user-level things. For example, your sound server, probably pulseaudio or pipewire, has a systemd service unit. Not only does it launch the service, it restarts it if it dies. If you change a unit file, you have to tell systemd to reread all the files with systemctl daemon-reload. You can enable, disable, start, and stop services and other units with the systemctl command, too. Theres also a way to mask and unmask units, which is like a super disable.\nWhile the documentation has become better over the years, the format for the units is still pretty hairy because there are so many options available. Most of the time, you only need a small subset of the many available options.\nFor Example\nHeres a fairly simple service unit:\n\n[Unit]\nDescription=OpenBSD Secure Shell server\nDocumentation=man:sshd(8) man:sshd_config(5)\nAfter=network.target auditd.service\nConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n\n[Service]\nEnvironmentFile=-/etc/default/ssh\nExecStartPre=/usr/sbin/sshd -t\nExecStart=/usr/sbin/sshd -D $SSHD_OPTS\nExecReload=/usr/sbin/sshd -t\nExecReload=/bin/kill -HUP $MAINPID\nKillMode=process\nRestart=on-failure\nRestartPreventExitStatus=255\nType=notify\nRuntimeDirectory=sshd\nRuntimeDirectoryMode=0755\n\n[Install]\nWantedBy=multi-user.target\nAlias=sshd.service\n\n\nYou can probably puzzle most of that out. Heres a very complicated service unit:\n\n[Unit]\nDescription=Entropy Daemon based on the HAVEGE algorithm\nDocumentation=man:haveged(8) http://www.issihosts.com/haveged/\nDefaultDependencies=no\nAfter=apparmor.service systemd-tmpfiles-setup.service systemd-tmpfiles-setup-dev.service\nBefore=sysinit.target shutdown.target\nConflicts=shutdown.target\n# RNDADDENTROPY ioctl requires host-level CAP_SYS_ADMIN, fails in unprivileged container\nConditionVirtualization=!container\n\n[Service]\nEnvironmentFile=-/etc/default/haveged\nExecStart=/usr/sbin/haveged --Foreground --verbose=1 $DAEMON_ARGS\nRestart=always\nSuccessExitStatus=137 143\nSecureBits=noroot-locked\nCapabilityBoundingSet=CAP_SYS_ADMIN\nPrivateTmp=true\nPrivateDevices=true\nPrivateNetwork=true\nProtectSystem=full\nProtectHome=true\nProtectHostname=true\nProtectKernelLogs=true\nProtectKernelModules=true\nRestrictNamespaces=true\nRestrictRealtime=true\n\nLockPersonality=true\nMemoryDenyWriteExecute=true\nSystemCallArchitectures=native\nSystemCallFilter=@basic-io @file-system @io-event @network-io @signal\nSystemCallFilter=arch_prctl brk ioctl mprotect sysinfo\n\n[Install]\nWantedBy=sysinit.target\n\n\n\nThis online form takes the tedium out of writing this purely fictional service (link in text).\nWhoa! Theres a lot to parse there. You can find all the documentation, of course. But many people copy some starter service and modify it. Another option is to use a wizard to help you create your unit files. For example, you can find some online. Fill out the forms on the left and observe the file on the right. Installation instructions are up top. If you dont know what a field asks for, theres a little info button to give you some help text. You can often pick things from a drop-down. Sure, you can write it all yourself, but this does make it a little easier.\nIf you want to make a timer, you need a service file and a timer file. Theres an online wizard for that, too. It isnt quite as helpful, and you need to understand how systemd represents time intervals. This is a bit more complicated than cron because you can set times relative to the timers activation, the time of system boot, or relative to the timers last activation. You can also set specific dates and times, add a random delay, or make timers persist.\nThat last option is like using anacron. Suppose you have a timer set to run at 1 AM daily on a laptop. The problem is that by 1 AM, the laptop is probably off. A persistent timer will realize that when you turn the laptop on at 8 AM that it should have run the 1 AM trigger, and then do so.\nTheres More\nA similar web page can make your timers, too.\nThere is so much more to know about units. Some of that is related to features. Some of it is related to quirks. For example, comments cant go at the end of a line  they have to be on their own line. For another example, special characters in the file names get hex escapes (this will be important later).\u00a0 To further complicate things, there are ways to make templates and add in pieces. All of that is beyond the scope of this post, but be aware, Im painting the simplest possible picture of the systemd universe.\nThe other problem is exactly where to put your unit files. They are scattered everywhere, and while there is a good reason for where they live, it is still annoying.\nThe short version is you should probably put system units in /etc/systemd/system unless you have a good reason to put it somewhere else. Units for all users can go in /etc/systemd/user. If you want a unit just for one user, try ~/.config/systemd/user. If you are looking for the location of an existing unit, usually systemctl status xxx.service will tell you. Otherwise, try systemctl show -P FragmentPath xxx.service.\nIf you want to read the actual documentation:\nSystem unit directories\nThe systemd system manager reads unit configuration from various directories. Packages that want to install unit files shall place them in the directory returned by pkg-config systemd variable=systemdsystemunitdir. Other directories checked are /usr/local/lib/systemd/system and /usr/lib/systemd/system. User configuration always takes precedence. pkg-config systemd variable=systemdsystemconfdir returns the path of the system configuration directory. Packages should alter the content of these directories only with the enable and disable commands of the systemctl(1) tool. Full list of directories is provided in systemd.unit(5).\nUser unit directories\nSimilar rules apply for the user unit directories. However, here the XDG Base Directory specification is followed to find units. Applications should place their unit files in the directory returned by pkg-config systemd variable=systemduserunitdir. Global configuration is done in the directory reported by pkg-config systemd variable=systemduserconfdir. The enable and disable commands of the systemctl(1) tool can handle both global (i.e. for all users) and private (for one user) enabling/disabling of units. Full list of directories is provided in systemd.unit(5).\nStupid Trick #0: Run Some Program on Startup\nThis isnt really a trick, but I wanted at least one example this time to show you how simple a homebrew service can be.\nIn an earlier post, I used a cheap smart display to show Hackadays RSS feed. If you want that to run on startup  or you just want the normal Python code to get the system status display  you need to run it somewhere. Sure, you could execute it by hand or put it in your startup files. But the systemd way to do it is with a unit. Heres mine:\n\n[Unit] \nDescription=[Operate Smart Display] \n\n[Service] \nType=simple \nStandardOutput=journal \nExecStart=/home/alw/apps/turing-smart-screen-python-3.1.0/service \n\n[Install] \nWantedBy=default.target\n\nThats easy enough. It defines a simple service that outputs to the journal. It starts by default. Piece of cake. Next time, well see a few more simple examples and maybe that will spur you to write your own unit files. Watch for it!", "title": "\u30b7\u30f3\u30d7\u30eb\u306asystemd\u3092\u7406\u89e3\u3059\u308b\uff1aLinux Fu\u57fa\u672c\u60c5\u5831", "body": "systemd\u306b\u3064\u3044\u3066\u57fa\u672c\u60c5\u5831\u3092\u8aac\u660e\u3057\u3001\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3084\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u77e5\u8b58\u3082\u3042\u308b\u533f\u540d\u306e\u8457\u8005\u304c\u3001\u30b7\u30b9\u30c6\u30e0\u56f3\u89e3\u3068\u3057\u3066Linux Fu\u8a18\u4e8b\u3092\u57f7\u7b46\u3002\u533f\u540d\u306e\u8457\u8005\u306f\u3001\u30b7\u30b9\u30c6\u30e0\u56f3\u89e3\u306b\u3064\u3044\u3066\u306e\u77e5\u8b58\u3092\u63d0\u4f9b\u3057\u3001\u305d\u306e\u89e3\u8aac\u3092\u4eca\u5f8c\u3082\u7d9a\u3051\u308b\u4e88\u5b9a\u3002", "titles": ["\u30b7\u30f3\u30d7\u30eb\u306asystemd\u3092\u7406\u89e3\u3059\u308b\uff1aLinux Fu\u57fa\u672c\u60c5\u5831", "\u30b7\u30a7\u30eb\u30b9\u30af\u30ea\u30d7\u30c8\u3068\u306e\u9055\u3044\uff1asystemd\u306e\u57fa\u790e\u77e5\u8b58", "systemd\u3092\u4f7f\u3063\u305f\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u306e\u8d77\u52d5\u6642\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u5b9f\u884c\u65b9\u6cd5", "systemd\u30e6\u30cb\u30c3\u30c8\u306e\u4f5c\u6210\u65b9\u6cd5\u3068\u8a2d\u5b9a\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u3064\u3044\u3066", "\u30aa\u30f3\u30e9\u30a4\u30f3\u30d5\u30a9\u30fc\u30e0\u3092\u4f7f\u7528\u3057\u305fsystemd\u30e6\u30cb\u30c3\u30c8\u306e\u4f5c\u6210\u88dc\u52a9"]}