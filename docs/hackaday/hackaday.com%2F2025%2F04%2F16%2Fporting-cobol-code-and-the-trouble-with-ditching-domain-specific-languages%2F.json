{"pubDate": "2025-04-16T14:00:01", "original_title": "Porting COBOL Code and the Trouble With Ditching Domain Specific Languages", "link": "https://hackaday.com/2025/04/16/porting-cobol-code-and-the-trouble-with-ditching-domain-specific-languages/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2022/05/COBOL.jpg", "original_content": "Whenever the topic is raised in popular media about porting a codebase written in an antiquated programming language like Fortran or COBOL, very few people tend to object to this notion. After all, what could be better than ditching decades of crusty old code in a language that only your grandparents can remember as being relevant? Surely a clean and fresh rewrite in a modern language like Java, Rust, Python, Zig, or NodeJS will fix all ailments and make future maintenance a snap?\nFor anyone who has ever had to actually port large codebases or dealt with legacy systems, their reflexive response to such announcements most likely ranges from a shaking of ones head to mad cackling as traumatic memories come flooding back. The old idiom of if it aint broke, dont fix it, purportedly coined in 1977 by Bert Lance, is a feeling that has been shared by countless individuals over millennia. Even worse, how can you fix something if you do not even fully understand the problem?\nIn the case of languages like COBOL this is doubly true, as it is a domain specific language (DSL). This is a very different category from general purpose system programming languages like the aforementioned replacements. The suggestion of porting the DSL codebase is thus to effectively reimplement all of COBOLs functionality, which should seem like a very poorly thought out idea to any rational mind.\n\nSticking To A Domain\nThe term domain specific language is pretty much what it says it is, and there are many of such DSLs around, ranging from PostScript and SQL to the shader language GLSL. Although it is definitely possible to push DSLs into doing things which they were never designed for, the primary point of a DSL is to explicitly limit its functionality to that one specific domain. GLSL, for example, is based on C and could be considered to be a very restricted version of that language, which raises the question of why one should not just write shaders in C?\nSimilarly, Fortran (Formula translating system) was designed as a DSL targeting scientific and high-performance computation. First used in 1957, it still ranks in the top 10 of the TIOBE index, and just about any code that has to do with high-performance computation (HPC) in science and engineering will be written in Fortran or strongly relies on libraries written in Fortran. The reason for this is simple: from the beginning Fortran was designed to make such computations as easy as possible, with subsequent updates to the language standard adding updates where needed.\nFortrans latest standard update was published in November 2023, joining the COBOL 2023 standard as two DSLs which are both still very much alive and very current today.\nThe strength of a DSL is often underestimated, as the whole point of a DSL is that you can teach this simpler, focused language to someone who can then become fluent in it, without requiring them to become fluent in a generic programming language and all the libraries and other luggage that entails. For those of us who already speak C, C++, or Java, it may seem appealing to write everything in that language, but not to those who have no interest in learning a whole generic language.\nThere are effectively two major reasons why a DSL is the better choice for said domain:\n\nEasy to learn and teach, because its a much smaller language\nFar fewer edge cases and simpler tooling\n\nIn the case of COBOL and Fortran this means only a fraction of the keywords (verbs for COBOL) to learn, and a language thats streamlined for a specific task, whether its to allow a physicist to do some fluid-dynamic modelling, or a staff member at a bank or the social security offices to write a data processing application that churns through database data in order to create a nicely formatted report. Surely one could force both of these people to learn C++, Java, Rust or NodeJS, but this may backfire in many ways, the resulting code quality being one of them.\nTangentially, this is also one of the amazing things in the hardware design language (HDL) domain, where rather than using (System)Verilog or VHDL, theres an amazing growth of alternative HDLs, many of them implemented in generic scripting and programming languages. That this prohibits any kind of skill and code sharing, and repeatedly, and often poorly, reinvents the wheel seems to be of little concern to many.\nNon-Broken Code\nA very nice aspect of these existing COBOL codebases is that they generally have been around for decades, during which time they have been carefully pruned, trimmed and debugged, requiring only minimal maintenance and updates while they happily keep purring along on mainframes as they process banking and government data.\nOne argument that has been made in favor of porting from COBOL to a generic programming language is ease of maintenance, pointing out that COBOL is supposedly very hard to read and write and thus maintaining it would be far too cumbersome.\nSince its easy to philosophize about such matters from a position of ignorance and/or conviction, I recently decided to take up some COBOL programming from the position of both a COBOL newbie as well as an experienced C++ (and other language) developer. Cue the Hello Business playground project.\nFor the tooling I used the GnuCOBOL transpiler, which converts the COBOL code to C before compiling it to a binary, but in a few weeks the GCC 15.1 release will bring a brand new COBOL frontend (gcobol) that Im dying to try out. As language reference I used a combination of the Wikipedia entry for COBOL, the IBM ILE COBOL language reference (PDF) and the IBM COBOL Report Writer Programmers Manual (PDF).\nMy goal for this Hello Business project was to create something that did actual practical work. I took the FileHandling.cob example from the COBOL tutorial by Armin Afazeli as starting point, which I modified and extended to read in records from a file, employees.dat, before using the standard Report Writer feature to create a report file in which the employees with their salaries are listed, with page numbering and totaling the total salary value in a report footing entry.\nMy impression was that although it takes a moment to learn the various divisions that the variables, files, I/O, and procedures are put into, its all extremely orderly and predictable. The compiler also will helpfully tell you if you did anything out of order or forgot something. While data level numbering to indicate data associations is somewhat quaint, after a while I didnt mind at all, especially since this provides a whole range of meta information that other languages do not have.\nThe lack of semi-colons everywhere is nice, with only a single period indicating the end of a scope, even if it concerns an entire loop (perform). I used the modern free style form of COBOL, which removes the need to use specific columns for parts of the code, which no doubt made things a lot easier. In total it only took me a few hours to create a semi-useful COBOL application.\nWould I opt to write a more extensive business application in C++ if I got put on a tight deadline? I dont think so. If I had to do COBOL-like things in C++, I would be hunting for various libraries, get stuck up to my gills in complex configurations and be scrambling to find replacements for things like Report Writer, or be forced to write my own. Meanwhile in COBOL everything is there already, because its what that DSL is designed for. Replacing C++ with Java or the like wouldnt help either, as you end up doing so much boilerplate work and dependencies wrangling.\nA Modern DSL\nPerhaps the funniest thing about COBOL is that since version 2002 it got a whole range of features that push it closer to generic languages like Java. Features that include object-oriented programming, bit and boolean types, heap-based memory allocation, method overloading and asynchronous messaging. Meanwhile the simple English, case-insensitive, syntax  with allowance for various spellings and acronyms  means that you can rapidly type code without adding symbol soup, and reading it is obvious even as a beginner, as the code literally does what it says it does.\nTrue, the syntax and naming feels a bit quaint at first, but that is easily explained by the fact that when COBOL appeared on the scene, ALGOL was still highly relevant and the C programming language wasnt even a glimmer in Dennis Ritchies eyes yet. If anything, COBOL has proven itself  much like Fortran and others  to be a time-tested DSL that is truly a testament to Grace Hopper and everyone else involved in its creation.", "title": "\u30ec\u30ac\u30b7\u30fc\u30b3\u30fc\u30c9\u306e\u6301\u3064\u4fa1\u5024\uff1aCOBOL\u3068Fortran\u306e\u518d\u8a55\u4fa1", "body": "\u53e4\u3044\u8a00\u8a9e\u306e\u30b3\u30fc\u30c9\u79fb\u884c\u306f\u8907\u96d1\u3067\u3001DSL\u306e\u5229\u70b9\u3092\u8a55\u4fa1\u3059\u3079\u304d\u3002", "titles": ["\u30ec\u30ac\u30b7\u30fc\u30b3\u30fc\u30c9\u306e\u6301\u3064\u4fa1\u5024\uff1aCOBOL\u3068Fortran\u306e\u518d\u8a55\u4fa1", "\u30c9\u30e1\u30a4\u30f3\u7279\u5316\u578b\u8a00\u8a9e(DSP)\u306e\u5f37\u307f\u3068\u305d\u306e\u91cd\u8981\u6027", "COBOL\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u4f53\u9a13\u8a18\uff1a\u53e4\u3044\u8a00\u8a9e\u306e\u65b0\u305f\u306a\u9b45\u529b", "\u30e2\u30c0\u30f3\u306aDSL\u306e\u9032\u5316\uff1aCOBOL\u3068\u305d\u306e\u65b0\u6a5f\u80fd", "\u30ec\u30ac\u30b7\u30fc\u30b7\u30b9\u30c6\u30e0\u306e\u79fb\u884c\u306b\u95a2\u3059\u308b\u8ab2\u984c\u3068\u60a9\u307f"]}