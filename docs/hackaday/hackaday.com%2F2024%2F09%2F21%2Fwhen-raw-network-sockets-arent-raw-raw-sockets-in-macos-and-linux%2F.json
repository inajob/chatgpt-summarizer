{"pubDate": "2024-09-21T23:00:07", "original_title": "When Raw Network Sockets Aren\u2019t Raw: Raw Sockets in MacOS and Linux", "link": "https://hackaday.com/2024/09/21/when-raw-network-sockets-arent-raw-raw-sockets-in-macos-and-linux/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/09/ipv4_packet_rfc_791_darpa.png", "original_content": "Raw network sockets are a curious beasts, as unless you have a strong urge to implement your own low-level network protocol, its a topic that is probably best left to the (well-paid) experts. That said, you can totally use raw sockets in virtually every operating system, but one should be aware of a few things, the lack of portability being one of them. This is what tripped [Swagnik] up while trying to write a low-level network ping (ICMP) utility, by reading the Linux socket documentation while testing on MacOS. Its all BSD-style sockets, after all, right?\nAs it turns out, the network stacks in Linux and MacOS have some subtle differences, which become apparent when you read the friendly manuals. For Linux, the raw(7) man entry for IPv4 sockets make it clear that the IP_HDRINCL socket option is default by default for IPPROTO_RAW sockets. This is different from MacOS, which is effectively FreeBSD with glossy makeup. Like FreeBSD, the MacOS man page makes it clear that the IP_HDRINCL option is not set by default.\nSo thats easy, right? Just fire off a setsockopt() call on the raw socket and thats done. Not quite. The Linux man page notes that it cannot receive all IP protocols, while the FreeBSD/MacOS version makes no such exceptions. There is also the issue of endianness, which is where [Swagnik]s blog post seems to err. The claim is that on MacOS the received IPv4 raw socket header is in host (little endian) order, while the documentation clearly notes that these are in network (big endian) order, which the blog post also shows.\nWhere things get really fun is when moving from IPv4 raw sockets to IPv6 raw sockets, as [Michael F. Sch\u00f6nitzer] covered for Linux back in 2018 already. IPv6 raw sockets drop IP_HDRINCL and requires a whole different approach. The endianness also changes, as IPv6 raw sockets under Linux must send and will receive data in network byte order, putting it in line with FreeBSD raw sockets.", "title": "\u30ed\u30fc\u30ec\u30d9\u30eb\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u5b9f\u88c5\u3059\u308b\u969b\u306e\u6ce8\u610f\u70b9", "body": "\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u306e\u7269\u7406\u30bd\u30b1\u30c3\u30c8\u306f\u5c02\u9580\u5bb6\u5411\u3051\u3067\u3001OS\u3054\u3068\u306e\u9055\u3044\u3084\u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\u306a\u3069\u306f\u6ce8\u610f\u304c\u5fc5\u8981\u3002IPv6\u30bd\u30b1\u30c3\u30c8\u306fIPv4\u3068\u624b\u6cd5\u304c\u7570\u306a\u308a\u3001\u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\u3082\u5909\u308f\u308b\u3002", "titles": ["\u30ed\u30fc\u30ec\u30d9\u30eb\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u5b9f\u88c5\u3059\u308b\u969b\u306e\u6ce8\u610f\u70b9", "Linux\u3068MacOS\u306e\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30b9\u30bf\u30c3\u30af\u306e\u9055\u3044", "IPv4\u30bd\u30b1\u30c3\u30c8\u3067\u306eIP_HDRINCL\u30aa\u30d7\u30b7\u30e7\u30f3\u306e\u6271\u3044", "MacOS\u306b\u304a\u3051\u308b\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30bd\u30b1\u30c3\u30c8\u30d8\u30c3\u30c0\u306e\u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\u306e\u9055\u3044", "IPv6\u30bd\u30b1\u30c3\u30c8\u3067\u306e\u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\u306e\u5909\u66f4\u3068\u7570\u306a\u308b\u30a2\u30d7\u30ed\u30fc\u30c1"]}