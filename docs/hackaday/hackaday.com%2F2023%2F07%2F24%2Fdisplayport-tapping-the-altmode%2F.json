{"pubDate": "2023-07-24T14:00:17", "original_title": "DisplayPort: Tapping The Altmode", "link": "https://hackaday.com/2023/07/24/displayport-tapping-the-altmode/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/07/Displayport.jpg", "original_content": "Really, the most modern implementation of DisplayPort is the USB-C DisplayPort altmode, synonymous with video over USB-C, and wed miss out if I were to skip it. Incidentally, our last two articles about talking USB-PD have given a few people a cool new toy to play with  people have commented on the articles, reached out to me for debugging help, and Ive even seen people build the FUSB302B into their projects! Hot on the heels of that achievement, lets reach further and conquer one more USB-C feature  one that isnt yet openly available for us to hack on, even though it deserves to be.\nFor our long-time readers, its no surprise to see mundane capabilities denied to hackers. By now, we all know that many laptops and phones let you get a DisplayPort connection out of a USB-C port. Given that the USB-C specifications are openly available, and weve previously implemented a PD sink using those specifications, youd expect that we could do DisplayPort with the same ease. Yet, the DisplayPort altmode specification is behind a VESA membership paywall, with a hefty pricetag  a practice of theirs that has been widely criticized, counter to their purpose as a standards organization and having resulted in some of their standards failing.\nNot to worry, however  we can easily find an assortment of PDFs giving a high-level overview and some details of the DisplayPort altmode, and heres my favorite! I also have a device running MicroPython with a FUSB302 chip connected, and a few DisplayPort altmode devices of mine that I can disassemble. This, turns out, is more than enough for us to reverse-engineer our way into an open-source DisplayPort altmode library!\n\nDisplayPort Over USB-C Basics\nThe USB-C port has four high-speed pairs, and one auxiliary lower-speed pair (SBU). This beautifully maps onto the DisplayPort requirements, with up to four high-speed data transfer pairs, and one AUX configuration channel. One small quirk  theres no pin for the HPD signal; instead, its status is forwarded inside of DisplayPort altmode messages over the PD channel. As a result, you can plug your device into a DisplayPort-capable USB-C, write a few magic words over PD, and get a DisplayPort signal on the USB-C TX/RX pins! No need to delve into DisplayPort internals whatsoever; the most you will need is to forward HPD as a PD message, and if your device uses a USB-C socket, have a cheap mux flip the signals according to the way your USB-C cable is plugged in.\nCaptive cable $10 dock with a DisplayPort to HDMI chip, a USB3 port, and a charging input. Two ICs total, including HDMI  no mux needed.\nAside from DisplayPort, you also get USB 2.0 on the good old USB2 pins  perfect for plugging in a keyboard and mouse alongside your monitor. Thats not all you can extract, however  if youre content with two-lane DisplayPort, you can ask the upstream device to provide you two lanes of DisplayPort on one pair of pins, and a USB3 port on another! This is how the majority of cheap USB-C docks work  they get two lanes of DisplayPort used for VGA or HDMI, USB3 for a high-speed port or a few peripherals, and USB2 for a whole bunch of other stuff, handling your power input on the side.\nJudging from the PDF we have from ST, there are seven kinds of PD messages that we need to answer if we want to build a DisplayPort device  the diagram on page 13 shows them all. In the All About USB-C: Replying Low-Level PD article, weve learned two types of messages  Source_Capabilities, which a USB-C PSU power profile advertisement, and the Request message, which weve crafted to get one of those power profiles and get a higher voltage out of a USB-C port. From two to seven  this is well within our reach!\nWhat do we need to do to reverse-engineer it, at the bare minimum? Id say, the PDF seems to contain more than enough info on its own  the communication flow, different command codes and contents are described there. However, it will be way more comfortable if we are to have packet captures to reference!\nPackets In Captivity\nUSB-C communications sniffing is an underexplored field  especially if high-speed signals are involved. For those, you need an interposer board that preserves signal integrity while letting you tap into the CC pins, and those arent quite dime a dozen. When it comes to commercial tools for USB-C sniffing, I feel like most of those are priced accounting for the fact that many people dont understand USB-C. However, theres certainly ways around it  in the comment section of the first PD talking article, [WF] has pointed us towards a way to sniff arbitrary USB-C packets with a logic analyzer and a simple extra circuit, with help of sigrok and Pulseview! We are making a device that can talk DisplayPort altmode, not just sniff it, but if youd like to tap into a device of yours as you follow alongside this article, this ought to be enough.\nThat said, there might be an even simpler solution, if youve been following along, you might just own a FUSB302B, which is a USB-C PHY IC. Since the Replying PD article got published, Ive been slowly building upon the capabilities of my personal MicroPython USB-PD stack  assortment of PD functions and code, rather, but Ill call it a stack until a more fitting name is found. First, Ive added packet listening capability  switching the FUSB302 into receive-only mode, reading its input FIFO as quickly as possible, and parsing the data on the fly. Ive also added packet information parsing, so that you can see USB-C communications in the serial console, without having to read them first.\nTheres a caveat, of course  I cant easily do passthrough capture of USB-C packets, since I didnt want to design an open-source passthrough board with CC tapping capability, and these boards arent quite available. That said, someone should do that  its a bit of a shame that the USB-C-Thru device never got funded! Instead, Ive started by disassembling captive cable devices I own, then tapping into the CC pin  since, with a captive cable device, theres only one CC pin possible. This means I dont need to autodetect rotation, which is nice because, given the time that my MicroPython code could take to figure out the rotation, the USB-PD conversation might be over by that point already. So, my boards CC1 wired to one of my USB docks CC pin, CC1 hardcoded to be the listening pin  what else?\nYoull want to disable the FUSB pullups  theyre going to be counterproductive here, as were tapping into an existing pullup/pulldown arrangement, and introducing one more pulldown will result in VBUS getting switched off. Youll also want to disable GoodCRC responses  FUSB302 does them automatically, which helps when we use it as a sink, but here theyll conflict with GoodCRC responses from both sides of the USB-C conversation; disabling the transmitter is even better. Ive also enabled SOP/ packet reception  these packets are used for emarkers, and while we dont normally need to receive them, being able to sniff them now is good.\nNow, were ready! Mind you, USB-C communications happen seriously fast. My MicroPython code isnt speedy either  I use MicroPython because I chose hackability over execution speed. However, as a consequence, I cant quite parse packets as they arrive  I will miss out on parts of the USB-C conversation if I do that, as, remember, even print statements take a bit of time. Instead, I read the input FIFO contents as quickly as possible, store packets in RAM, and parse them afterwards. On the upside, having packet captures in RAM also means that I end up with PD conversation recordings I can easily store and replay later, and you get a few of these captures as well!\nTheres downsides to using this method of packet capture, of course  I might still not be able to capture communications that happen too fast, I only capture packets with valid CRC and will miss out on any garbled packets, and I dont have timestamps for the packets received; using a logic analyzer would negate all of these. However, for our DisplayPort RE purposes, its more than good enough, and any parsing code I write, will be super helpful when building a library. CC pin wired up, code running and ready, lets go!\nThis Is VDM Turf\nHere you can see a power profile negotiation happening  Source_Capabilities, Request, Accept and PS_RDY, things weve already done before. These are required if you are to talk PD for any purpose, so its not much of a surprise. However, theres also a whole bunch of Vendor_Defined messages, and these might put you on edge. Do not be afraid, though  be grateful to the USB-C standard instead, because, with the way it tells vendors to implement vendor-specific communications, these messages are better documented than youd expect!\nFull communications from my sniffer code, partially parsed\nVDMs, or Vendor-Defined Messages, are responsible for any altmode summoning that goes beyond the regular USB3, USB2 and PD things you can get  you can use VDMs for anything that falls outside the standard, from custom altmodes to firmware updates. You can have them unstructured or structured  unstructured messages are basically freeform, while structured messages are kind of a template for a typical conversation that a vendor might actually want to implement. DisplayPort negotiation uses structured messages, and out of the seven commands involved in setting up the DisplayPort altmode, five of them are commands already defined in the USB-C standard! As for the two remaining ones, the PDF we have, very helpfully mentions their codes on page 8, and describes them in more detail on page 10-12.\nThese commands are a bit special  its not just that a GoodCRC response is required, the FUSB302B will take care of it for us, anyway. Its also that every command can be either a request or a response, and either of the directions can carry extra data, depending on the specific command being used! Thankfully, all of this optional data is described in the PDF  which has been proving more and more helpful the deeper we go.\nAll in all, we wont need to reverse-engineer that much, specifically  the main problem, in my assessment, would be the bitfields. Also, since we dont have the full specification, we might make a crucial mistake or two  for instance, we dont know how quickly we must answer these commands, or the specifics of handling the DisplayPort HPD signal properly. We can figure these out however, and Ive got quite a variety of USB-C DisplayPort devices to get packet captures from!\nReplay Works  Proper Implementation Time\nWell, now we have DisplayPort conversation commands, captured from a real-life device  if we wanted to make a DisplayPort sink right now, we can just replay them, only adjusting small things like message ID! In fact, heres a piece of code which does just that  sends back the commands that we captured, and Ive successfully made it summon the DisplayPort altmode on my own laptop! Now, I didnt verify the high-speed DisplayPort output, but I got voltage on SBU pins, which means that the AUX diffpair has been wired up to those  something that only happens after the DisplayPort altmode has been successfully summoned.\nThe fundamental part of the replay code is the request-response loop, which does rely on our parsing code to answer incoming messages. This is great for us  well need exactly this kind of loop once we can actually construct our own replies, just that well need a bit more sophisticated one. Until then, this is enough to get me by when it comes to a personal project of mine.\nThe next tasks are to actually make sense of these commands and implement a meaningful DisplayPort library! Well go through the seven commands required, explain each one of them, parse the ones well receive, and implement the ones well have to send back. Afterwards, well tie them all together into the already existing loop, figure out USB-C high-speed lane rotation handling, and well be ready to build open-source DisplayPort handling devices for any capable USB-C port in sight. After all, these days, even a PinePhone can do DisplayPort!", "title": "USB-C\u306b\u3088\u308bDisplayPort\u57fa\u672c\u6a5f\u80fd", "body": "DisplayPort\u306fUSB-C\u30dd\u30fc\u30c8\u304b\u3089\u306eDisplayPort\u63a5\u7d9a\u304c\u53ef\u80fd\u3067\u3042\u308a\u3001USB-C\u4ed5\u69d8\u3092\u4f7f\u7528\u3057\u3066DisplayPort\u3092\u884c\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002VESA\u30e1\u30f3\u30d0\u30fc\u30b7\u30c3\u30d7\u306e\u652f\u6255\u3044\u304c\u5fc5\u8981\u306a\u305f\u3081\u3001\u516c\u958b\u3055\u308c\u3066\u3044\u306a\u3044\u304c\u3001\u9006\u5de5\u5b66\u306b\u3088\u3063\u3066\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u306eDisplayPort altmode\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u901a\u4fe1\u30ad\u30e3\u30d7\u30c1\u30e3\u3092\u53d6\u5f97\u3057\u3001\u30b3\u30fc\u30c9\u3092\u89e3\u6790\u3057\u3066\u518d\u751f\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\u3053\u308c\u306b\u3088\u308a\u3001DisplayPort\u306e\u5b9f\u88c5\u304c\u53ef\u80fd\u306b\u306a\u308a\u307e\u3059\u3002", "titles": ["USB-C\u306b\u3088\u308bDisplayPort\u57fa\u672c\u6a5f\u80fd", "\u30d1\u30b1\u30c3\u30c8\u30ad\u30e3\u30d7\u30c1\u30e3\u3092\u4f7f\u7528\u3057\u305fUSB-C\u901a\u4fe1\u306e\u30b9\u30cb\u30c3\u30d5\u30a3\u30f3\u30b0", "DisplayPort\u306eVDM\u30e1\u30c3\u30bb\u30fc\u30b8\uff1a\u30d9\u30f3\u30c0\u30fc\u5b9a\u7fa9\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u6d3b\u7528\u65b9\u6cd5", "\u30d1\u30b1\u30c3\u30c8\u518d\u751f\u306b\u3088\u308bDisplayPort altmode\u306e\u5b9f\u88c5", "\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9DisplayPort\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u69cb\u7bc9\u3068USB-C\u9ad8\u901f\u30ec\u30fc\u30f3\u306e\u51e6\u7406"]}