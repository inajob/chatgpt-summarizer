{"pubDate": "2025-06-01T02:00:00", "original_title": "Can We Replace a Program Counter with a Linear-Feedback Shift Register? Yes We Can!", "link": "https://hackaday.com/2025/05/31/can-we-replace-a-program-counter-with-a-linear-feedback-shift-register-yes-we-can/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/05/LFSR-F16.svg-banner_d6cb93.png", "original_content": "Today we heard from [Richard James Howe] about his new CPU. This new 16-bit CPU is implemented in VHDL for an FPGA.\nThe really cool thing about this CPU is that it eschews the typical program counter (PC) and replaces it with a linear-feedback shift register (LFSR). Apparently an LFSR can be implemented in hardware with fewer transistors than are required by an adder.\nUsually the program counter in your CPU increments by one, each time indicating the location of the next instruction to fetch and execute. When you replace your program counter with an LFSR it still does the same thing, indicating the next instruction to fetch and execute, but now those instructions are scattered pseudo-randomly throughout your address space!\n\nWhen the instructions for your program are distributed pseudo-randomly throughout your address space you find yourself in need of a special compiler which can arrange for this to work, and thats what this is for.\nOf course all of this is shenanigans and is just for fun. This isnt the first time weve heard from [Richard], we have seen his Bit-Serial CPU and Forth System-On-Chip in recent history. Glad to see hes still at it!\nThanks to [Richard James Howe] for letting us know about this latest development.", "title": "- \u65b0\u3057\u304416\u30d3\u30c3\u30c8CPU\u306e\u8a95\u751f\uff1aLFSR\u306b\u3088\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u30ab\u30a6\u30f3\u30bf\u306e\u9769\u65b0", "body": "\u65b0\u3057\u304416\u30d3\u30c3\u30c8CPU\u306f\u3001\u30d7\u30ed\u30b0\u30e9\u30e0\u30ab\u30a6\u30f3\u30bf\u3092LFSR\u306b\u7f6e\u304d\u63db\u3048\u305f\u3082\u306e\u3067\u3001\u6307\u793a\u3092\u30e9\u30f3\u30c0\u30e0\u306b\u53d6\u5f97\u3057\u307e\u3059\u3002", "titles": ["- \u65b0\u3057\u304416\u30d3\u30c3\u30c8CPU\u306e\u8a95\u751f\uff1aLFSR\u306b\u3088\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u30ab\u30a6\u30f3\u30bf\u306e\u9769\u65b0", "- FPGA\u3067\u5b9f\u88c5\u3055\u308c\u305f\u30e6\u30cb\u30fc\u30af\u306aCPU\uff1a\u30d7\u30ed\u30b0\u30e9\u30e0\u30ab\u30a6\u30f3\u30bf\u3092\u7f6e\u304d\u63db\u3048\u305fLFSR", "- \u547d\u4ee4\u3092\u6563\u767a\u7684\u306b\u914d\u7f6e\u3059\u308b\u65b0\u3057\u3044\u547d\u4ee4\u30bb\u30c3\u30c8\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u306e\u8003\u5bdf", "- \u30ea\u30c1\u30e3\u30fc\u30c9\u30fb\u30b8\u30a7\u30fc\u30e0\u30ba\u30fb\u30cf\u30a6\u6c0f\u304c\u8a9e\u308b\u6700\u65b0\u306e\u96fb\u5b50\u5de5\u4f5c\u30d7\u30ed\u30b8\u30a7\u30af\u30c8", "- \u697d\u3057\u307f\u306a\u304c\u3089\u5b66\u3076\u96fb\u5b50\u5de5\u4f5c\uff1a\u65b0\u3057\u3044CPU\u3068\u7279\u5225\u306a\u30b3\u30f3\u30d1\u30a4\u30e9\u306e\u53ef\u80fd\u6027"]}