{"pubDate": "2024-02-06T18:00:15", "original_title": "Human-Interfacing Devices: Packing for the Descriptor Heist", "link": "https://hackaday.com/2024/02/06/human-interfacing-devices-packing-for-the-descriptor-heist/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2018/07/usb.jpg", "original_content": "We started with figuring out HID descriptors a week ago, and Ive shown you how to send raw HID packets using a MicroPython fork. We do still have the task in front of us  making a touchscreen device. For that, lets give you the tools to capture an existing descriptor from a touchscreen, then show you how to tweak it and how it turns out in the end.\nPacking For The Heist\nWhen it comes to this kind of adventure, we cant go without tools and weapons  it could be dangerous! Without them, you could even abandon your project halfway! Heres enough high-precision tools and ammunition to last you through whatever obstacles you might encounter. Except for the web-based tools, these tools are for Linux, but please remember that you can always use a virtual machine or a Raspberry Pi. Nobody would use Windows for a heist anyway, whats with all the telemetry and such.\nThe first tool is for reading descriptors  we need one to learn from, its just like a keycard you can flash to a security guard and scan at the vault entry. Of course, with RFID, you want to have enough examples, compare bits between a few cards and all. For now, HID descriptors dont have authenticity checks, but it looks like that might just change in the future. Leave it to Apple and Microsoft to add them, as usual. On Linux, seeing descriptors is simple  as root, go into /sys/bus/usb/devices/, find your device by its lsusb device tree path, then follow the directory with the VID/PID in it. That directory will contain a report_descriptor file  hexdump it. The entire command could look like this:\nsudo hexdump -v -e '/1 \"%02X \"' /sys/bus/usb/devices/3-6.2/3-6.2\\:1.1/0003\\:0C40\\:8000.0022/report_descriptor`\nAgain, you might need root to even find this path, so use sudo -i if you must. The format string in the hexdump command gives you parser-friendly output. Specifically, for parsing, I use this webpage  its wonderful, even adding tabs that delineate different sections of the descriptor, making its output all that more readable! You can also save this webpage locally, its a very neat tool. Other than that, you can try other local tools like this one!\n\nNow, you got a descriptor for a device whose behaviour you want to imitate, and you can parse it to see what makes it tick. Wonderful! But not something you can understand at a glance, not just yet? The descriptor alone doesnt lend itself to building a mental map, it might contain multiple report IDs, and some descriptors will be generic enough to be confusing. For instance, many devices have descriptors that are actually endpoints for firmware updates instead, so you might be spending time figuring when the descriptor is actually never used. Lets take a look at what our device actually sends when we interact with it, which report ID we should learn from  and most importantly, how a Linux OS interprets it.\nFor that, we only need VID and PID. As root yet again, go to /sys/kernel/debug/hid/, find a directory with your VID and PID, then cat its events file. In there, you will find a pretty-printed human readable description of every event you get from your device, as soon as it appears. Sometimes the printing process glitches out and stops mid-event  it might be something with the way its being cated, but its usually no big loss. This is a wonderful way to see what actually happens when your HID device has activity. The first byte is the report ID, then the packet is printed in the way its received, and after that, we see the parsing results from the OS. Its simply an amazing tool to have! Heres an example commandline:\nsudo cat /sys/kernel/debug/hid/0003\\:2E8A\\:0005.0029/events\nLast but not least, youll want a way to see events as your OSs input layers actually interpret them. Yes, thats different  if a packet arrives, its not necessarily converted to an OS-level input event, sometimes its discarded because it doesnt fulfill a certain condition. For instance, at some point, my touchscreen packets were being discarded because I was only sending coordinates, and omitted a crucial bit telling the OS that a touchscreen is currently conveying a valid touch event as opposed to a spurious touch. That bit is front and center in the Microsofts appnotes on digitizer building, and seeing that my OS didnt take in my constructed events was the push I needed to peek into the appnote and check what my packet might be missing.\nFor this, I have my own little Python script that prints out events as they are received by the input library layers, and this script has served me for like a decade now. Simply download it and run it  you will need to install the Python `evdev` library, but its available from both Debian/Ubuntu repositories and `pip` alike. You also need to run this one as root, but that happens when you run it as `./listen_keys.py` automatically.\n\nI prefer running all those different commands in tmux, different small panes for different ongoing tasks  heres my workspace when I was developing and debugging the touchscreen code, where a) shows raw HID event printing, b) shows HID descriptor printing, and c) shows the input event display code.\nA Perfect Disguise\nWith these tools, building a touchscreen was an evenings work. I had coordinates from the XPT2046 library I was using, so all I had to do was to build a descriptor. Initially, I thought to reuse the absolute position mouse descriptor helpfully provided by [] with the code, but the input event printing script has shown me that even the mouse button presses from that script werent picked up by UI  and while MOUSE_ABS events did show up, they did not affect my desktop in any way.\nDebugging the mouse descriptor work didnt sound fun, especially given I dont even have a working absolute mouse to learn from! Instead, I decided to rebuild the absolute mouse descriptor into a digitizer descriptor, since I have both digitizer descriptor and packets! The absolute mouse descriptor was helpfully exposed in the MicroPython sources separately, and ripe for tweaking, too! Changing the USAGE and USAGE_PAGE categories alone to those of USB touchscreens descriptor made my OS recognize my RP2040 board as a digitizer.\nThe actual changes were not tricky  the XPT2046 library provided two integer coordinates, so I copied a structure from a descriptor that described one X and one Y value, each 16 bits long and therefore split into two bytes each, just like my USB touchscreen. With help of the HID packet debug print mechanism, I could quickly notice when my upper and lower byte were swapped, because my OS was not interpreting the coordinates correctly. Having fixed that, my packets would get parsed correctly but werent appearing among the input events, and comparing the factory-made USB touchscreen packets to the hand-constructed packets of my DIY touchscreen, I could notice that a valid touch bit was missing. Adding that made the device behave like a touchscreen for all intents and purposes!\nNow, I have a DIY USB-connected touchscreen, and all it took was stealing a HID descriptor from a different touchscreen, then imitating it closely enough. Plus, whenever I want, I can switch my touchscreen into touchpad mode by having it send packets with a different report ID that corresponds to the mouse descriptor of the firmware  it only lacks two mouse buttons to be a complete laptop touchpad! Given that Im using this to prototype a wearable display, it will be immensely helpful.\nIn And Out, We Secured The Goods\nAs-is, the newly christened USB touchscreen needs some filtering and calibration, but those are tiny fixes  could probably steal some filtering algorithms from Linux XPT2046 drivers, too! Its plugplay, its easy to use, and its hackable  no longer the SPI touchscreen it was meant to be. Most of all, its a great example that, if you want to build a slightly wacky HID device, its nowhere near hard to do so, and Linux offers you a powerful toolkit that helps you notice any HID problems no matter how far you want to go.\nTheres tons of things you can do if you understand HID. For instance, you can build a Braille display thats cross-compatible, without struggling with USB-UART serial numbers. Over on Hackaday Discord, [mupf] has been hacking on an XBox Adaptive Controller-compatible device that uses a magnetometer and gyro to send the OS, with the HID descriptor heavily informed by a dumped descriptor of an original Xbox Adaptive Controller. The HID specification describes a large number of things, even USB-connected character displays, and things like  you can send quaternions with help of HID, of all things!\nSupporting HID makes your input device friendly and helps it better interact within the software world. HID is, at its core, a language understood by all of the mainstay operating systems, and giving your device a HID interface lets you avoid adding a layer of proprietary language between your device and any sort of software you wish to interact with. And, of course, HID is a great hacker tool  this smartphone automation tool alone will testify!\nNext time, Id like to show you more about I2C HID  sending HID packets and descriptors over I2C, without requiring a USB port at all and only using a I2C connection, which by now is pretty ubiquitous! In that context, I will show you how to reuse a Framework laptop touchpad, which uses I2C-HID for its communications. Im hoping to modify QMK so that we can practice adding I2C touchpads to any QMK-controlled keyboards, but we might just settle on modding KMK, which is QMKs equivalent but in CircuitPython. I will also show you how you can quickly connect an I2C-HID device to a Linux SBC of yours  its easier than you might imagine! And, if stars align and I2C peripheral mode support in RP2040 MicroPython turns out to be stable enough, we could even build our own RP2040-powered I2C HID peripheral as a dessert.", "title": "\"HID\u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u3092\u8aad\u307f\u53d6\u308a\u3001\u30bf\u30c3\u30c1\u30b9\u30af\u30ea\u30fc\u30f3\u30c7\u30d0\u30a4\u30b9\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5\"", "body": "HID\u8a18\u8ff0\u5b50\u3092\u7406\u89e3\u3057\u3001MicroPython\u3067\u751fHID\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u65b9\u6cd5\u3092\u7d39\u4ecb\u3057\u307e\u3057\u305f\u3002\n\u30bf\u30c3\u30c1\u30b9\u30af\u30ea\u30fc\u30f3\u30c7\u30d0\u30a4\u30b9\u306e\u4f5c\u6210\u306b\u3082\u53d6\u308a\u7d44\u3093\u3067\u304a\u308a\u3001\u73fe\u5728\u306f\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\u3092\u30ad\u30e3\u30d7\u30c1\u30e3\u3057\u3001\u8abf\u6574\u3057\u3001Linux OS\u3067\u306e\u89e3\u91c8\u3092\u78ba\u8a8d\u3059\u308b\u65b9\u6cd5\u3092\u8aac\u660e\u3057\u3066\u3044\u307e\u3059\u3002", "titles": ["\"HID\u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u3092\u8aad\u307f\u53d6\u308a\u3001\u30bf\u30c3\u30c1\u30b9\u30af\u30ea\u30fc\u30f3\u30c7\u30d0\u30a4\u30b9\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5\"", "\"Linux\u3067HID\u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u3092\u89e3\u6790\u3059\u308b\u305f\u3081\u306e\u30c4\u30fc\u30eb\"", "\"\u30bf\u30c3\u30c1\u30b9\u30af\u30ea\u30fc\u30f3\u30c7\u30d0\u30a4\u30b9\u306e\u52d5\u4f5c\u3092\u30c6\u30b9\u30c8\u3059\u308b\u65b9\u6cd5\"", "\"Linux\u306e\u5165\u529b\u30a4\u30d9\u30f3\u30c8\u5c64\u3067\u30a4\u30d9\u30f3\u30c8\u3092\u8868\u793a\u3059\u308b\u65b9\u6cd5\"", "\"USB\u63a5\u7d9a\u306e\u30bf\u30c3\u30c1\u30b9\u30af\u30ea\u30fc\u30f3\u3092\u4f5c\u6210\u3059\u308b\u624b\u9806\""]}