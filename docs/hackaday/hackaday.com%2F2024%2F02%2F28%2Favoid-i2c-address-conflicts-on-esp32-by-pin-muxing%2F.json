{"pubDate": "2024-02-28T12:00:27", "original_title": "Avoid I2C Address Conflicts On ESP32 By Pin Muxing", "link": "https://hackaday.com/2024/02/28/avoid-i2c-address-conflicts-on-esp32-by-pin-muxing/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/02/hadimg_esp32_i2cmux_feat.jpg", "original_content": "Using hardware I2C on an ESP32? Do you need to connect multiple I2C devices with the same address? Normally, you wouldnt be able to do that without extra parts, but on the ESP32, [BastelBaus] has found a nice hack  just connect your devices to different pins and slightly abuse the ESP32 GPIO muxing, no extra hardware required!\nInitially, they tried separating SDA and SCL completely, and after a bit of tinkering, thats worked out wonders! For this method, [BastelBaus] provides example Arduino code you could easily integrate into your project, and shows logic analyzer captures that demonstrate theres barely any overhead. Later, theyve also found out that you could multiplex only one of the pins, specifically, SDA, having the SCL line be common! As far as we see, this could also work out with split SCL, but do let us know if that doesnt sound right.\nTypically, such a problem is solved with an I2C multiplexer, and weve highlighted projects with them before. However, this simple method could also work on chips like the RP2040 or even the Raspberry Pi 4  just a bit more limited, since the GPIO muxing for I2C has less available ports! Also, if youre not using a chip with such a comfortable GPIO mux and you must use devices with overlapping addresses, check out the comment section under our I2C ecosystem article  theres a fair few other methods you can use. And, if this method ever malfunctions for you, theres a bunch of very straightforward ways you could debug your bus!", "title": "ESP32\u3092\u4f7f\u3063\u305f\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2I2C\u306e\u6d3b\u7528\u65b9\u6cd5", "body": "ESP32\u3092\u4f7f\u3063\u305f\u5834\u5408\u3001\u7570\u306a\u308b\u30d4\u30f3\u306b\u63a5\u7d9a\u3059\u308b\u3053\u3068\u3067\u540c\u3058I2C\u30c7\u30d0\u30a4\u30b9\u306e\u63a5\u7d9a\u304c\u53ef\u80fd\u306b\u306a\u308b\u30cf\u30c3\u30af\u304c\u78ba\u8a8d\u3055\u308c\u3001\u8ffd\u52a0\u306e\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u306f\u4e0d\u8981\u3002Arduino\u30b3\u30fc\u30c9\u306e\u63d0\u4f9b\u3084\u30ed\u30b8\u30c3\u30af\u30a2\u30ca\u30e9\u30a4\u30b6\u30fc\u30ad\u30e3\u30d7\u30c1\u30e3\u306e\u30c7\u30e2\u3082\u884c\u308f\u308c\u3001RP2040\u3084Raspberry Pi 4\u3067\u3082\u540c\u69d8\u306b\u52d5\u4f5c\u53ef\u80fd\u3002", "titles": ["ESP32\u3092\u4f7f\u3063\u305f\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2I2C\u306e\u6d3b\u7528\u65b9\u6cd5", "ESP32\u3067\u540c\u3058\u30a2\u30c9\u30ec\u30b9\u306e\u8907\u6570\u306eI2C\u30c7\u30d0\u30a4\u30b9\u3092\u63a5\u7d9a\u3059\u308b\u65b9\u6cd5", "ESP32\u306eGPIO\u30de\u30eb\u30c1\u30d7\u30ec\u30af\u30b7\u30f3\u30b0\u3092\u6d3b\u7528\u3057\u305fI2C\u30c7\u30d0\u30a4\u30b9\u306e\u63a5\u7d9a\u65b9\u6cd5", "Arduino\u30b3\u30fc\u30c9\u3067\u5b9f\u88c5\u3059\u308bESP32\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2I2C\u306e\u6d3b\u7528\u65b9\u6cd5", "I2C\u30de\u30eb\u30c1\u30d7\u30ec\u30af\u30b5\u30fc\u4e0d\u8981\uff01ESP32\u3067\u306e\u7c21\u5358\u306a\u63a5\u7d9a\u65b9\u6cd5"]}