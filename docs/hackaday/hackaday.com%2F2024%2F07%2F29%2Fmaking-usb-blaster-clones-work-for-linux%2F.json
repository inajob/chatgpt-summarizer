{"pubDate": "2024-07-29T08:00:59", "original_title": "Making USB Blaster Clones Work For Linux", "link": "https://hackaday.com/2024/07/29/making-usb-blaster-clones-work-for-linux/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/07/blast.png", "original_content": "The last time we checked in with [Downtown Doug Brown], he had some cheap Altera USB Blaster clones that didnt want to work under Linux. The trick at that time was to change the devices 24 MHz clock to 12 MHz. This month, hes found some different ones that dont work, but now the clock change doesnt work. Whats the problem?\nHe also picked up a Terasic clone, which does work on Linux and is considered, according to [Doug], the best of the clones. The units were superficially similar. So what follows is a lot of USB tracing and dumping of the CPLD chips configuration.\n\nThe problem is that even though CPLDs are relatively simple, relative is a  well  relative word. It is still a lot of work to reverse engineer a CPLD bitstream. However, he did find some public VHDL source code that acted the same so he presumed it shared a common problem with the original configuration.\nInspecting the code, he realized that there was no delay between a critical part of the protocol. For some reason, Windows didnt seem to care, but it was enough to upset the Linux driver. At least, that was the theory.\nTheory, in this case, translated to practice. As a bonus, the new code even made the original units work at full speed. Although it isnt technically accurate, you can think of CPLDs as little FPGAs, and sometimes, they are more approachable for beginners. They are also great when you dont need a full-blown FPGA.", "title": "Linux\u5bfe\u5fdc\u306eUSB Blaster\u30af\u30ed\u30fc\u30f3\u306e\u30af\u30ed\u30c3\u30af\u5909\u66f4\u30c8\u30e9\u30d6\u30eb", "body": "\u30a2\u30eb\u30c6\u30e9USB Blaster\u30af\u30ed\u30fc\u30f3\u306e\u554f\u984c\u3092\u89e3\u6c7a\u3057\u3066\u3044\u305f[Downtown Doug Brown]\u306b\u3064\u3044\u3066\u300224MHz\u6642\u8a08\u304b\u308912MHz\u306b\u5909\u66f4\u3059\u308b\u30c8\u30ea\u30c3\u30af\u3092\u7d39\u4ecb\u3002\u65b0\u305f\u306a\u30af\u30ed\u30fc\u30f3\u306b\u3088\u308b\u554f\u984c\u3068Windows\u3068Linux\u306e\u5bfe\u5fdc\u306e\u9055\u3044\u306b\u3064\u3044\u3066\u5831\u544a\u3002CPLD\u306e\u9006\u8a2d\u8a08\u4f5c\u696d\u3068VHDL\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u8abf\u67fb\u3002", "titles": ["Linux\u5bfe\u5fdc\u306eUSB Blaster\u30af\u30ed\u30fc\u30f3\u306e\u30af\u30ed\u30c3\u30af\u5909\u66f4\u30c8\u30e9\u30d6\u30eb", "Terasic\u30af\u30ed\u30fc\u30f3\u306eUSB Blaster\u306e\u8abf\u67fb\u3068\u89e3\u6790", "CPLD\u30d3\u30c3\u30c8\u30b9\u30c8\u30ea\u30fc\u30e0\u306e\u30ea\u30d0\u30fc\u30b9\u30a8\u30f3\u30b8\u30cb\u30a2\u30ea\u30f3\u30b0", "VHDL\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u554f\u984c\u3068Linux\u30c9\u30e9\u30a4\u30d0\u3078\u306e\u5f71\u97ff", "CPLD\u3068FPGA\u306e\u9055\u3044\u3001\u521d\u5fc3\u8005\u306b\u304a\u3059\u3059\u3081"]}