{"pubDate": "2023-10-17T17:01:19", "original_title": "Linux Fu: Deep Git Rebasing", "link": "https://hackaday.com/2023/10/17/linux-fu-deep-git-rebasing/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "If you spend much time helping people with word processor programs, youll find that many people dont really use much of the product. They type, change fonts, save, and print. But cross-references? Indexing? Largely, those parts of the program go unused. Ive noticed the same thing with Git. We all use it constantly. But do we? You clone a repo. Work on it. Maybe switch branches and create a pull request. Thats about 80% of what you want to do under normal circumstances. But what if you want to do something out of the ordinary? Git is very flexible, but you do have to know the magic incantations.\nFor example, suppose you mess up a commit message  we never do that, of course, but just pretend. Or you accidentally added a file you didnt want in the commit. Git has some very useful ways to deal with situations like this, especially the interactive rebase.\n\nIdentify a Commit\nIf you havent realized it, every version of your project in Git boils down to a commit. Branches and tags are just pointers to commits. In addition, commits point to their parent commit. So, suppose you have the following sequence of commands:\nmkdir project\ncd project\ngit init\ntouch readme.md\ngit add readme.md\ngit commit -a -m \"First Commit\"\nSo far, this is pretty standard stuff. Next, we are going to make our first change, and well simulate an emacs backup file. This will be the first change we will commit.\ntouch hackaday.txt\ntouch hackaday.txt~\ngit add hackaday*\ngit commit -a -m \"Add hackaday.text\"\nOops. We have two problems here, but for the sake of the example, suppose we only noticed the typo in the commit message (text instead of txt).\nIf any of this doesnt make sense, you might want to review the basics of Git before you keep going. The video below can help, although there are plenty of other options. If youd rather read, theres also the Pro Git book.\n\nQuick Fix\nIf you need to fix the last commit, it is pretty easy. It helps to notice what the ID of each commit is. Theres a long ID string, but Git can show you the first few characters of it. Yours will be different, but when I did this, that last commit was 86d63c3. You can use these ids or tags like HEAD (the current commit) to go further up the git commit graph.\nIf you ask git to show you whats going on with git log you can see that the original first commit was 51a18eb. In addition, you can see that HEAD, the pointer to the tip of the commit graph, is pointing to 86d63c3. But since were just changing the last commit, you dont need to know that. In this case, heres what you can do:\ngit commit --amend -m \"Add hackaday.txt\"\nIf you do a git log now, youll see the commit message changed. However, since this is a new commit, the ID number changes also (for me, 9b0125c). That means if you have already pushed the commit to a remote repo, you shouldnt do the amend.\nThere are still only two commits, the original one and our new one with the corrected message. One problem solved, but we still have that backup file. Unfortunately, we dont notice it until later.\nA New Commit\nNext, we are going to get a Jolly Wrencher graphic in and commit again.\ncp ~/assets/wrencher.png .\ngit add wrencher.png\ngit commit -am 'Add logo'\nThis is fine, and we now have three commits in our current branch. The problem is we need to fix the second one now. We now have three commits. The original initial commit was (for me) 51a18eb. The updated second commit is 9b0125c. The last commit with the logo is 3451549.\nTo fix the commit, we will rebase the last commit. Remember that the last commit is based on the previous commit, which is based on the commit before that, and so on. To change our commit, we need to rebase to one commit beyond the one we want to change. One way to do that is to specify 51a183b. We can do that interactively with:\ngit rebase -i 51a18eb\nThis opens an editor with a script:\npick 9b0125c Add Hackaday.txt\npick 3451549 Add logo\n\n# Rebase 51a18eb..3451549 onto 51a18eb (2 commands)\n#\n# Commands:\n# p, pick commit = use commit\n# r, reword commit = use commit, but edit the commit message\n# e, edit commit = use commit, but stop for amending\n# s, squash commit = use commit, but meld into previous commit\n# f, fixup [-C | -c] commit = like \"squash\" but keep only the previous\n# commit's log message, unless -C is used, in which case\n# keep only this commit's message; -c is same as -C but\n# opens the editor\n# x, exec command = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop commit = remove commit\n# l, label label = label current HEAD with a name\n# t, reset label = reset HEAD to a label\n# m, merge [-C commit | -c commit] label [# oneline]\n# . create a merge commit using the original merge commit's\n# . message (or the oneline, if no original merge commit was\n# . specified); use -c commit to reword the commit message\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\nThe comments are helpful. By default, all the commits use the pick command which just keeps them. You can also do things like drop them or use reword to change a commit message. We want to do an edit, so you can change the first pick command to an edit command:\nedit 9b0125c Add Hackaday.txt\npick 3451549 Add logo\nWhen you exit your editor, you get a helpful message:\nStopped at 9b0125c... \u00a0Add Hackaday.txt \nYou can amend the commit now, with \n\n\u00a0git commit --amend \u00a0\n\nOnce you are satisfied with your changes, run \n\n\u00a0git rebase --continue\n\n\nLooking around now, youll see everything is as it was for that commit. That is, theres no PNG file, and you have both hackaday.txt files. Lets fix it:\ngit rm hackaday.txt~\ngit commit --amend\ngit rebase --continue\nYou can always use a git status to see what git thinks you need to do next.\u00a0 After these commands, you still have three commits, but the accidental add of hackaday.txt~ has vanished.\nAs you can see, there are other commands, too. You can merge multiple commits together. You can also squash them or fix them up. These essentially turn one commit into two. The difference is a squash gives you a chance to keep or change the commit message, while fixup keeps only one of the original messages. Remember that these are both different from a merge, which creates a new commit from multiple parent commits. A squash or a fixup converts multiple commits into a single commit. You can also hit the panic button with git rebase abort.\nPicking Your Commit\nRember that each commit has an ID, but you also have tags and even relative indexing available. You could also use the notation HEAD~2 (in this case). This tells git to start at the HEAD and go back two generations. If you are familiar with merge commits, this assumes you are going back in the same branch. When a merge commit gives you a choice of parents, you can also use the notation HEAD^ to pick one of the parents. You can even mix and match these. But you can also always get the ID from git log and use that. Or, you can use a tag if youve tagged a certain commit.\nJust make sure you are working with the commit before the last commit you want to edit. In this case, we wanted to edit HEAD~ (or HEAD~1, if you prefer), so we had to rebase HEAD~2. If you really want to edit using the commit number you actually want to edit, just put a ~ after it. That selects the parent of the specified ID.\nNon-Interactive Mode\nYou can, of course, do rebasing without the interactive mode, but it is a lot of work. The interactive mode is good, too, for things like splitting a commit into multiple commits. Thats because when you edit a commit, you can actually add multiple commits as part of the edit.\nYoull find if you start rebasing, youll use git log a lot. There is a post that shows how to make better-looking output if you prefer. Turns out, you can use git for a lot of things. If you crave something simpler, try the gitless shell that runs over git."}