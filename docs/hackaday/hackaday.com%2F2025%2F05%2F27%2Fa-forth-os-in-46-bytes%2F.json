{"pubDate": "2025-05-27T11:00:44", "original_title": "A Forth OS in 46 Bytes", "link": "https://hackaday.com/2025/05/27/a-forth-os-in-46-bytes/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/05/10biForthOs.png", "original_content": "\nIt\u2019s not often that we can include an operating system in a Hackaday article, but here\u2019s the full 46-byte source of [Philippe Brochard]\u2019s 10biForthOS in 8086 opcodes:\n50b8 8e00 31d8 e8ff 0017 003c 0575 00ea5000 3c00 7401 eb02 e8ee 0005 0588 eb47b8e6 0200 d231 14cd e480 7580 c3f4\nAdmittedly, this is quite a minimal operating system. It\u2019s written for the Intel 8086, and consists of a Forth implementation with only two instructions: compile (1) and execute (0). It can receive commands over a serial connection or from a keyboard. This allows a host computer to load more complex software onto it, one byte at a time. In particular, [Philippe] provides instructions for loading more advanced compilers, such as subleq-eForth for a more complete Forth implementation, or SectorC for C programming. He\u2019s also written a 217-byte port of the OS to Linux Intel x64.\n[Philippe] doesn\u2019t take a strong stance on whether this should technically qualify as a Forth implementation, given that the base implementation lacks stacks, dictionaries, and the ability to define words. However, it does have an outer and inner interpreter, the ability to compile and execute code, and most importantly, \u201cthe simplicity and hacky feeling of Forth.\u201d\n[Philippe] writes that this masterpiece of minimalism continues the tradition of the minimal Forth implementations we\u2019ve covered before. We\u2019ve even seen Forth run on an Arduino."}