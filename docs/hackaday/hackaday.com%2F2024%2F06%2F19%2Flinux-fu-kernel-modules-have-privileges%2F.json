{"pubDate": "2024-06-19T14:00:11", "original_title": "Linux Fu: Kernel Modules Have Privileges", "link": "https://hackaday.com/2024/06/19/linux-fu-kernel-modules-have-privileges/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "I did something recently I havent done in a long time: I recompiled the Linux kernel. There was a time when this was a common occurrence. You might want a feature that the default kernel didnt support, or you might have an odd piece of hardware. But these days, in almost all the cases where you need something like this, youll use loadable kernel modules (LKM) instead. These are modules that the kernel can load and unload at run time, which means you can add that new device or strange file system without having to rebuild or even restart the kernel.\nNormally, when you write programs for Linux, they dont have any special permissions. You typically cant do direct port I/O, for example, or arbitrarily access memory. The kernel, however, including modules, has no such restriction. That can make debugging modules tricky because you can easily bring the system to its knees. If possible, you might think about developing on a virtual machine until you have what you want. That way, an errant module just brings down your virtual machine.\nHistory\nSome form of module support has been around since Linux 1.2. However, modern kernels can be built to include support for things or support them as modules. For example, you probably dont want to put drivers for every single known video card in your kernel. But it is perfectly fine to build dozens or hundreds of modules you might need and then load the one you need at run time.\nLKMs are at the heart of device drivers, file system drivers, and network drivers. In addition, modules can add new system calls, override existing system calls, add TTY line disciplines, and handle how executables run.\nIn Use\nIf you want to know what modules you have loaded, thats the lsmod command. Youll see that some modules depend on other modules and some dont. There are two ways to load modules: insmod and modprobe. The insmod command simply tries to load a module. The modprobe command tries to determine if the module it is loading needs other modules and picks them up from a known location.\nYou can also remove modules with rmmod assuming they arent in use. Of course, adding and removing modules requires root access. You can usually run lsmod as a normal user if you like. You might also be interested in depmod to determine dependencies, and modinfo which shows information about modules.\nWriting a Module\nIt is actually quite easy to write your own module. In fact, it is so simple that the first example I want to look at is a little more complex than necessary.\nThis simple module can load and unload. It leaves a message in the system messages (use dmesg, for example) to tell you it is there. In addition, it allows you to specify a key (just an arbitrary integer) when you load it. That number will show up in the output data. Heres the code:\n\n#include linux/module.h\n#include linux/moduleparam.h\n#include linux/printk.h\n\nMODULE_AUTHOR(Al Williams);\nMODULE_DESCRIPTION(Hackaday LKM);\nMODULE_LICENSE(GPLv2); // many options, GPL, GPLv2, Proprietary, etc.\n\nstatic int somedata __initdata=0xbeef; // this is just some static variable available only at init\nstatic int key=0xAA; // you can override this using insmod\n// Note 0644 means that the sysfs entry will be rw-r--r--\nmodule_param(key,int,0644); // use module_param_named if you want different names internal vs external\nMODULE_PARM_DESC(key,An integer ID unique to this module);\n\nstatic int __init had_init(void)\n{\n  // This is the usual way to do this (dont forget \\n and note no comma after KERN_INFO), but...\n  printk(KERN_INFO Hackaday is in control (%x %x)\\n,key,somedata);\n  return 0;\n}\n\nstatic void __exit had_exit(void)\n{\n  // ... you can also use the pr_info macro which does the same thing\n  pr_info(Returning control of your system to you (%x)!\\n,key);\n}\n\nmodule_init(had_init);\nmodule_exit(had_exit);lt;/pregt;\n\nThis isnt hard to puzzle out. Most of it is include files and macros that give modinfo something to print out. There are some variables: somedata is just a set variable that is readable during initialization. The key variable has a default but can be set using insmod. Whats more, is because module_param specifies 0644  an octal Linux permission  there will be an entry in the /sys/modules directory that will let the root set or read the value of the key.\nAt the end, there are two calls that register what happens when the module loads and unloads. The rest of the code is just something to print some info when those events happen.\nI printed data in two ways: the traditional printk and using the pr_info macro which uses printk underneath, anyway. You should probably pick one and stick with it. Id normally just use pr_info.\nBuilding the modules is simple assuming you have the entire build environment and the headers for the kernel. Heres a simple makefile (dont forget to use tabs in your makefile):\n\npreobj-m += hadmod1.o\n\nPWD := $(CURDIR) # not needed in most cases, but useful if using sudo\n\nall:\n\u00a0\u00a0\u00a0 make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n\u00a0\u00a0\u00a0 make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean/pre\n\nOnce you build things, you should have a .ko file (like hadmod.ko). Thats the module. Try a few things:\n\n\nsudo insmod hadmod.ko\u00a0\u00a0 # load the module\n\n\nsudo dmesg\u00a0 # see the module output\n\n\ncat /sys/modules/hadmodule/key\u00a0\u00a0 # see the key (you can set it, too, if you are root)\n\n\nsudo rmmod hadmod.ko\u00a0 # unload the module\n\n\nsudo insmod hadmod.ko key=128\u00a0\u00a0 # set key this time and repeat the other steps\n\n\nThats It?\nThat is it. Of course, the real details lie in how you interact with the kernel or hardware devices, but thats up to you. Just to give a slightly meatier example, I made a second version of the module that adds /proc/jollywrencher to the /proc filesystem. Heres the code:\n\n#include linux/init.h\n#include linux/module.h\n#include linux/moduleparam.h\n#include linux/printk.h\n#include linux/uaccess.h\n#include linux/fs.h\n#include linux/proc_fs.h // Module metadata\n#include linux/version.h\n\nMODULE_AUTHOR(Al Williams);\nMODULE_DESCRIPTION(Hackaday LKM1);\nMODULE_LICENSE(GPLv2); // many options, GPL, GPLv2, Proprietary, etc.\n\n\nstatic char logo[]=\n                                                                                \\n\\\n                                                                                \\n\\\n                                                                                \\n\\\n           #@@@@@@                                            ,@@@@@@           \\n\\\n              @@@@@*                                       @@@@@,             \\n\\\n               @@@@@@%                                     @@@@@@#              \\n\\\n   @@       .@@@@@@@@@                                    .@@@@@@@@@       .@#  \\n\\\n   @@@  /@@@@@@@@@@@@                                   @@@@@@@@@@@@   @@@@*  \\n\\\n    @@@@@@@@@@@@@@@@@@@@@#                             @@@@@@@@@@@@@@@@@@@@@,   \\n\\\n      @@@@@@@@@@@@@@@@@@@@@*    ,@@@@@@@@@@@@%     @@@@@@@@@@@@@@@@@@@@@*     \\n\\\n           ,*.  @@@@@@@@@@@/ .@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@#  **           \\n\\\n                   @@@@@@, @@@@@@@@@@@@@@@@@@@@@@@@@, %@@@@@                  \\n\\\n                     ,@ /@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@                     \\n\\\n                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*                       \\n\\\n                       %@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.                      \\n\\\n                       @@@@@@       #@@@@@@@.      /@@@@@@                      \\n\\\n                      /@@@@         @@@@@@.         @@@@@                      \\n\\\n                      ,@@@@%      (@@@@@@@@@@*      @@@@@                      \\n\\\n                       @@@@@#  @@@@@@@@@@@@@@@@@@%  @@@@@                      \\n\\\n                       /@@@@@@@@@@@@@@@, #@@@@@@@@@@@@@@@                       \\n\\\n                     @@ *@@@@@@@@@@@@@ ( @@@@@@@@@@@@@@ .@(                    \\n\\\n                  %@@@@@. @@@@@@@@@@@@@@@@@@@@@@@@@@@@% #@@@@@*                 \\n\\\n          (%%((@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@% ,@@@@@@@@@@*##/         \\n\\\n      @@@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@(  @@@@@@@@@@@@@@@@@@@@@     \\n\\\n    @@@@@@@@@@@@@@@@@@@@@     @@@@@@*@@@@@@/%@@@@@    *@@@@@@@@@@@@@@@@@@@@#   \\n\\\n   @@@@.   @@@@@@@@@@@.         ..      .      .          (@@@@@@@@@@#   /@@@*  \\n\\\n   @,        %@@@@@@@@                                    .@@@@@@@@.        #  \\n\\\n               ,@@@@@(                                     @@@@@@               \\n\\\n             *@@@@@@                                        (@@@@@@             \\n\\\n           @@@@@@,                                             %@@@@@@          \\n\\\n                                                                                \\n\\\n                                                                                ;\n\nstatic struct proc_dir_entry *proc_entry;\nstatic ssize_t had_read(struct file *f, char __user * user_buffer, size_t count, loff_t * offset)\n  {\n  size_t len;\n  if (*offset0) return 0; // no seeking, please!\n  copy_to_user(user_buffer,logo,len=strlen(logo)); // skipped error check\n  *offset=len;\n  return len;\n  }\n\n#if LINUX_VERSION_CODE = KERNEL_VERSION(5,6,0)\nstatic struct proc_ops procop = // prior to Linux 5.6 you needed file_operations\n{\n  .proc_read=had_read\n};\n#else\nstatic struct file_operations procop =\n{\n  .owner=THIS_MODULE,\n  .read=had_read\n#endif\n\nstatic int __init had_init(void)\n{\n  // This is the usual way to do this (dont forget \\n and note no comma after KERN_INFO), but...\n  printk(KERN_INFO Hackaday1; is in control\\n);\n  proc_entry=proc_create(jollywrencher,0644,NULL,amp;procop);\n  return 0;\n}\n\nstatic void __exit had_exit(void)\n{\n  // ... you can also use the pr_info macro which does the same thing\n  pr_info(Returning control of your system to you...\\n);\n  proc_remove(proc_entry);\n}\n\nmodule_init(had_init);\nmodule_exit(had_exit);\n\nThe only thing here is you have an extra function that you have to register and deregister with the kernel. However, that interface changed in Kernel 5.6, so the code tries to do the right thing. Until, of course, it gets changed again.\nOnce you load this module using insmod, you can cat /proc/jollywrencher to see your favorite web sites logo.\nOf course, this is a dead simple example, but it is enough to get you started. You can grab all the source code online. One great way to learn more is to find something similar to what you want to build and take it apart.\nWe dont suggest it, but you can write an LKM in Scratch. If you really want to learn the kernel, maybe start at the beginning.", "title": "Linux\u30ab\u30fc\u30cd\u30eb\u3092\u518d\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u65b9\u6cd5", "body": "Linux\u30ab\u30fc\u30cd\u30eb\u306e\u518d\u30b3\u30f3\u30d1\u30a4\u30eb\u304c\u5fc5\u8981\u306a\u30b1\u30fc\u30b9\u306f\u73cd\u3057\u3044\u3002\u3053\u308c\u3067\u306f\u65b0\u6a5f\u80fd\u3084\u5947\u5999\u306a\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u5411\u3051\u306b\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u4f7f\u7528\u3059\u3079\u304d\u3002Linux\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u66f8\u304d\u65b9\u3084\u30c7\u30d0\u30c3\u30b0\u624b\u6cd5\u3082\u8aac\u660e\u3002\u8981\u70b9\uff1aLKMs\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u30ed\u30fc\u30c9\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u524a\u9664\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u8a18\u8ff0\u624b\u6cd5\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u30d3\u30eb\u30c9\u65b9\u6cd5\u3001\u30b7\u30f3\u30d7\u30eb\u306a\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u4f8b\u3002", "titles": ["Linux\u30ab\u30fc\u30cd\u30eb\u3092\u518d\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u65b9\u6cd5", "\u30ed\u30fc\u30c9\u53ef\u80fd\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\uff08LKM\uff09\u306e\u6d3b\u7528\u65b9\u6cd5", "Linux\u30e2\u30b8\u30e5\u30fc\u30eb\u958b\u767a\u5165\u9580", "\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u66f8\u304d\u65b9", "\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u30d3\u30eb\u30c9\u3057\u3066\u5229\u7528\u3059\u308b\u65b9\u6cd5"]}