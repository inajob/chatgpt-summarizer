{"pubDate": "2024-07-16T20:00:25", "original_title": "Playing Rock, Paper Scissors With A Time of Flight Sensor", "link": "https://hackaday.com/2024/07/16/playing-rock-paper-scissors-with-a-time-of-flight-sensor/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/07/vlcsnap-00057_be3ac4-e1721114096679.png", "original_content": "You can do all kinds of wonderful things with cameras and image recognition. However, sometimes spatial data is useful, too. As [madmcu] demonstrates, you can use depth data from a time-of-flight sensor for gesture recognition, as seen in this rock-paper-scissors demo.\nIf youre unfamiliar with time-of-flight sensors, theyre easy enough to understand. They measure distance by determining the time it takes photons to travel from one place to another. For example, by shooting out light from the sensor and measuring how long it takes to bounce back, the sensor can determine how far away an object is. Take an array of time-of-flight measurements, and you can get simple spatial data for further analysis.\nThe build uses an Arduino Uno R4 Minima, paired with a demo board for the VL53L5CX time-of-flight sensor. The software is developed using NanoEdge AI Studio. In a basic sense, the system uses a machine learning model to classify data captured by the time-of-flight sensor into gestures matching rock, paper, or scissors\u2014or nothing, if no hand is present. If you dont find [madmcu]s tutorial enough, you can take a look at the original version from STMicroelectronics, too.\nIt takes some training, and it only works in the right lighting conditions, but this is a functional system that can determine real hand sign and play the game. Weve seen similar techniques help more advanced robots cheat at this game before, too! What a time to be alive.", "title": "\u30ab\u30e1\u30e9\u3068\u30bb\u30f3\u30b5\u30fc\u3092\u4f7f\u3063\u305f\u624b\u8a71\u8a8d\u8b58\u30b7\u30b9\u30c6\u30e0\u306e\u69cb\u7bc9\u65b9\u6cd5", "body": "\u30ab\u30e1\u30e9\u3068\u753b\u50cf\u8a8d\u8b58\u3067\u7d20\u6674\u3089\u3057\u3044\u3053\u3068\u304c\u3067\u304d\u308b\u304c\u3001\u6642\u306b\u306f\u7a7a\u9593\u30c7\u30fc\u30bf\u3082\u6709\u7528\u3002[madmcu]\u306eRock-paper-scissors\u30c7\u30e2\u3067\u306f\u3001\u6642\u9593-\u98db\u884c\u578b\u30bb\u30f3\u30b5\u30fc\u306e\u6df1\u5ea6\u30c7\u30fc\u30bf\u3092\u5229\u7528\u3057\u305f\u30b8\u30a7\u30b9\u30c1\u30e3\u30fc\u8a8d\u8b58\u304c\u7d39\u4ecb\u3055\u308c\u3066\u3044\u308b\u3002Arduino Uno R4 Minima\u3068VL53L5CX\u30bb\u30f3\u30b5\u30fc\u3092\u4f7f\u7528\u3002", "titles": ["\u30ab\u30e1\u30e9\u3068\u30bb\u30f3\u30b5\u30fc\u3092\u4f7f\u3063\u305f\u624b\u8a71\u8a8d\u8b58\u30b7\u30b9\u30c6\u30e0\u306e\u69cb\u7bc9\u65b9\u6cd5", "\u6df1\u5c64\u30c7\u30fc\u30bf\u3092\u5229\u7528\u3057\u305f\u30b8\u30a7\u30b9\u30c1\u30e3\u30fc\u8a8d\u8b58\u30b7\u30b9\u30c6\u30e0\u306e\u88fd\u4f5c", "Arduino\u3068VL53L5CX\u30bb\u30f3\u30b5\u30fc\u3092\u6d3b\u7528\u3057\u305f\u624b\u8a71\u30c7\u30e2\u306e\u4f5c\u6210\u624b\u9806", "\u6642\u5dee\u98db\u884c\u30bb\u30f3\u30b5\u30fc\u3092\u7528\u3044\u305f\u30b8\u30a7\u30b9\u30c1\u30e3\u30fc\u8a8d\u8b58\u30b7\u30b9\u30c6\u30e0\u306e\u958b\u767a", "\u6642\u5dee\u98db\u884c\u30bb\u30f3\u30b5\u30fc\u3092\u4f7f\u3063\u305f\u30ed\u30c3\u30af\u30fb\u30da\u30fc\u30d1\u30fc\u30fb\u30b7\u30b6\u30fc\u30ba\u30b2\u30fc\u30e0\u306e\u5b9f\u73fe"]}