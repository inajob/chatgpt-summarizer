{"pubDate": "2023-10-11T14:00:40", "original_title": "Meshtastic and Owntracks to Kick your Google Habit", "link": "https://hackaday.com/2023/10/11/meshtastic-and-owntracks-to-kick-your-google-habit/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/06/Meshtatic.jpg", "original_content": "I have an admission to make. I have a Google addiction. Not the normal addiction  I have a problem with Google Maps, and the timeline feature. I know, Im giving my location data to Google, who does who-knows-what-all with it. But its convenient to have an easy way to share location with my wife, and very useful to track my business related travel for each month. What we could really use is a self-hosted, open source system to track locations and display location history. And for bonus points, lets include some extra features, like the ability to track vehicles, kids, and pets that arent carrying a dedicated Internet connection.\nYou can read the title  you know where were going with this. Were setting up an Owntracks service, and then tying it to Meshtastic for off-Internet usability. The backbone that makes this work is MQTT, a network message bus that has really found its niche in the Home Assistant project among others. Its a simple protocol, where clients send brief messages labeled by topic, and can also subscribe to specific topics. For this little endeavor well use the Mosquito MQTT broker.\nOne of the nice things about MQTT is that the messages are all text strings, and often take the form of JSON. When trying to get two applications to talking using a shared MQTT server, there may need to be a bit of translation. One application may label a field latitude, and the other shortens it to lat. The glue code to put these together is often known as an MQTT translator, or sometimes an MQTT bridge. This is a program that listens to a given topic, ingests each message, and sends it back to the MQTT server in a different format and topic name.\nThe last piece is Owntracks, which has a recorder project, which pulls locations from the MQTT server, and stores it locally. Then theres Owntracks Frontend, which is a much nicer user interface, with some nice features like viewing movement a day at a time.\nGetting started\nSo up first, pick a machine to host the service. Well use Docker-compose to build our mini-cluster of services. A Linux machine is a great choice, though it should be possible to run on Windows through either Docker desktop, or WSL. But if you go that route, youre a bit on your own. Youll need Docker and docker-compose, with the Docker service running  ideally set to autostart via systemd. And reminder, youll probably need to add your user to the docker group, with sudo gpasswd -a $USER docker.\nNow just a quick note: Im going to describe the process of setting this up from scratch. At the end of this article there will be a link to a Github repository, where you can grab nearly everything all at once.\nItll help to read through the details at least once, to understand what were building, so hang in there.\nWe start by creating a folder in /etc, called owntracks-meshtastic. In that folder, we want to create a directory called mosquitto, and then create the mosquitto configuration file. We want to add two lines to that file, instructing our MQTT server to listen on port 1883, and to accept unauthenticated connections.\nsudo mkdir /etc/owntracks-meshtastic\ncd /etc/owntracks-meshtastic\nsudo mkdir mosquitto\nsudo touch mosquitto/mosquitto.conf\necho allow_anonymous true | sudo tee -a mosquitto/mosquitto.conf\necho listener 1883 | sudo tee -a mosquitto/mosquitto.conf\n\nWith the configuration file in place, its time to start on our docker-compose.yml file, using sudo nano /etc/owntracks-meshtastic/docker-compose.yml. A docker compose file is really pretty simple once you break it down into parts. We start with a services heading, and under that will be a block for each docker service we want to run. Each block starts with a service name, and includes the Docker image itself, what files and folders we want to map into the Docker image, and what ports to expose. For Mosquitto, we just need the configuration file and a pair of ports for sending MQTT data.\n\nservices:\n  mosquitto:\n    image: eclipse-mosquitto\n    volumes:\n      - /etc/owntracks-meshtastic/mosquitto:/mosquitto/config\n    ports:\n      - 1883:1883\n      - 9001:9001\n\n\nOnce that file is saved, we start a test-run by running a simple docker-compose up. This should download the Mosquitto docker image and start it up. Then we can use a simple client like MQTT Explorer to make sure that were actually running. If your OS has any firewalls in place, this is the time to add an MQTT exception to the firewall. Once youre ready to go back to working on configuration, use Ctrl+c and run docker-compose down\nFirst Real Data\nWe have enough of our system in place to start sending some real data. For this we need a Meshtastic node to work as a base station. This will need to be a device that can connect to the network, likely over wifi. There are several great options, like a Heltec LoRa32 v3, the Lilygo T-Beam (ideally the one with the SX1262 LoRa chip), or the Station G1 for the increased transmit power. Regardless of which device we choose, we need to connect it to wifi to enable communication with our new MQTT service.\nThats most easily done through the Android or iOS app, through radio configuration, network, and setting the WiFi SSID and PSK. Then its on to MQTT Config, to turn on MQTT Enabled. Set the MQTT Server Address to the machine running Mosquitto, blank out MQTT Username and MQTT Password, and finally turn on JSON output enabled. The device will reboot, and should start sending data to the MQTT server. In MQTT Explorer, were looking for the msh topic.\nOnce thats flowing, its time to add the next step, Meshtastic-bridge. Well start with creating the config file, sudo nano /etc/owntracks-meshtastic/config.yaml. We need to inform Meshtastic-bridge which server to use, and then set up a pipeline to convert the Meshtastic data to the MQTT format that Owntracks expects. Youll need to update the server IP and populate the tid_table with your Meshtastic node IDs, which can be found using meshtastic --nodes.\n\nmqtt_servers:\n  - name: external\n    server: YOURSERVERIP\n    port: 1883\n    topic: msh/2/json/#\n    pipelines:\n      owntrack:\n      - owntracks_plugin:\n          log_level: debug\n          server_name: external\n          tid_table:\n            !a56f7c45: [Meshenger, MS]\n\nNext were going to clone the meshtastic-bridge repository right into this folder, using sudo git clone https://github.com/jp-bennett/meshtastic-bridge. From there we add another service to our docker-compose.yml file to build a Docker image from that repository. We also pass our config file through as a Docker volume. Again use sudo nano /etc/owntracks-meshtastic/docker-compose.yml:\n\nservices:\n  mosquitto:\n    image: eclipse-mosquitto\n    volumes:\n      - /etc/owntracks-meshtastic/mosquitto:/mosquitto/config\n    ports:\n      - 1883:1883\n      - 9001:9001\n  meshtastic-bridge:\n    build:\n      context: /etc/owntracks-meshtastic/meshtastic-bridge\n      dockerfile: Dockerfile\n    volumes:\n      - /etc/owntracks-meshtastic/config.yaml:/code/config.yaml\n\nMap it!\nBelieve it or not, were nearly done. Up next is adding the Owntracks-recorder Docker image to our compose file. First, we need to create a data directory, using sudo mkdir store. Then its just a matter of adding the owntracks-recorder service to our docker-compose.yml and updating the IP address to our server IP again. Once again, use sudo nano /etc/owntracks-meshtastic/docker-compose.yml\n\nservices:\n  mosquitto:\n    image: eclipse-mosquitto\n    volumes:\n      - /etc/owntracks-meshtastic/mosquitto:/mosquitto/config\n    ports:\n      - 1883:1883\n      - 9001:9001\n  meshtastic-bridge:\n    build:\n      context: /etc/owntracks-meshtastic/meshtastic-bridge\n      dockerfile: Dockerfile\n    volumes:\n      - /etc/owntracks-meshtastic/config.yaml:/code/config.yaml\n  owntracks-recorder:\n    image: owntracks/recorder\n    volumes:\n      - /etc/owntracks-meshtastic/store:/store\n    ports:\n      - 8083:8083\n    environment:\n      - OTR_HOST=YOURSEVERIP\n\nFrom there, you should be able to pull up your owntracks instance at http://YOURSERVERADDRESS:8083. Once your Meshtastic node broadcasts a location, it should show up in the table of known nodes, and be visible on the map. Now as cool as this is, you may notice that its a bit bare-bones.\n\nTheres one more piece to wire in, and thats the Owntracks-frontend interface. This is the fancy single-page site that shows location history, heat maps, and more. And its pretty easy to add to our setup. Just add it to the bottom of your docker-compose.yml using sudo nano /etc/owntracks-meshtastic/docker-compose.yml, making the final file look like this:\n\nservices:\n  mosquitto:\n    image: eclipse-mosquitto\n    volumes:\n      - /etc/owntracks-meshtastic/mosquitto:/mosquitto/config\n    ports:\n      - 1883:1883\n      - 9001:9001\n  meshtastic-bridge:\n    build:\n      context: /etc/owntracks-meshtastic/meshtastic-bridge\n      dockerfile: Dockerfile\n    volumes:\n      - /etc/owntracks-meshtastic/config.yaml:/code/config.yaml\n  owntracks-recorder:\n    image: owntracks/recorder\n    volumes:\n      - /etc/owntracks-meshtastic/store:/store\n    ports:\n      - 8083:8083\n    environment:\n      - OTR_HOST=YOURSEVERIP\n  owntracks-frontend:\n    image: owntracks/frontend\n    ports:\n      - 80:80\n    environment:\n      - SERVER_HOST=YOURSEVERIP\n      - SERVER_PORT=8083\n\nAnd thats it! Run docker-compose up -d to start your miniature swarm of docker instances, and watch your Meshtastic devices populate the map with live data! No dependency on Internet, no sending your location data to Google, its just open source data collection goodness. And if you want some added goodies, there is an Owntracks mobile app that can connect directly to your own backend. That app pushes and pulls live location data, ideally over a VPN for security.\nNow you may want to set this to run automatically, and theres a systemd service for that. Youll just need to save the following with sudo nano /etc/systemd/system/docker-compose-owntracks.service:\n\n# /etc/systemd/system/docker-compose-owntracks.service\n# https://stackoverflow.com/questions/43671482/how-to-run-docker-compose-up-d-at-system-start-up\n\n[Unit]\nDescription=Docker Compose Owntracks Service\nRequires=docker.service\nAfter=docker.service\nStartLimitIntervalSec=60\n\n[Service]\nWorkingDirectory=/etc/owntracks-meshtastic\nExecStart=/docker-compose up\nExecStop=docker-compose down\nTimeoutStartSec=0\nRestart=on-failure\nStartLimitBurst=3\n\n[Install]\nWantedBy=multi-user.target\n\nWith that in place, you can use sudo systemctl enable docker-compose-owntracks --now to start and enable the whole service.\nNow thats a lot of work. So as promised, we have a quicker way to do it. The whole thing is available as a single repository. All that needs to be done after running the following command is to change the server IP, fill out the tid-table, and deploy the systemd service file.\nsudo git clone https://github.com/jp-bennett/owntracks-meshtastic --recurse-submodules /etc/owntracks-meshtastic/\nThats Meshtastic, MQTT, and Owntracks all rolled up into your own location tracking service. Let us know if you follow the instructions and set this up for yourself. And look forward to the third part in this series, how to use Meshtastic to extend your projects with a wireless, encrypted serial connection.", "title": "\u81ea\u5df1\u30db\u30b9\u30c8\u578b\u306e\u4f4d\u7f6e\u60c5\u5831\u8ffd\u8de1\u30b7\u30b9\u30c6\u30e0\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5", "body": "\u79c1\u306fGoogle\u306b\u4f9d\u5b58\u3057\u3066\u3044\u307e\u3059\u304c\u3001\u81ea\u5206\u306e\u4f4d\u7f6e\u60c5\u5831\u3092\u5171\u6709\u3057\u305f\u308a\u3001\u30d3\u30b8\u30cd\u30b9\u95a2\u9023\u306e\u79fb\u52d5\u3092\u8ffd\u8de1\u3057\u305f\u308a\u3059\u308b\u305f\u3081\u306b\u4fbf\u5229\u3067\u3059\u3002\u30bb\u30eb\u30d5\u30db\u30b9\u30c8\u578b\u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30b7\u30b9\u30c6\u30e0\u3092\u4f7f\u3044\u305f\u3044\u3067\u3059\u3002\u3055\u3089\u306b\u3001\u8eca\u3084\u5b50\u4f9b\u3001\u30da\u30c3\u30c8\u306e\u4f4d\u7f6e\u3092\u8ffd\u8de1\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\u3044\u3067\u3059\u3002", "titles": ["\u81ea\u5df1\u30db\u30b9\u30c8\u578b\u306e\u4f4d\u7f6e\u60c5\u5831\u8ffd\u8de1\u30b7\u30b9\u30c6\u30e0\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5", "Google\u306b\u4f9d\u5b58\u305b\u305a\u306b\u4f4d\u7f6e\u60c5\u5831\u3092\u8ffd\u8de1\u3059\u308b\u65b9\u6cd5", "Meshtastic\u3068MQTT\u3092\u4f7f\u3063\u305f\u4f4d\u7f6e\u60c5\u5831\u8ffd\u8de1\u30b7\u30b9\u30c6\u30e0\u306e\u69cb\u7bc9\u624b\u9806", "\u96fb\u5b50\u5de5\u4f5c\u611b\u597d\u8005\u5fc5\u898b\uff01\u81ea\u4f5c\u306e\u4f4d\u7f6e\u8ffd\u8de1\u30b7\u30b9\u30c6\u30e0\u306e\u4f5c\u308a\u65b9", "\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u306e\u4f4d\u7f6e\u60c5\u5831\u8ffd\u8de1\u30b7\u30b9\u30c6\u30e0\u306e\u69cb\u7bc9\u30ac\u30a4\u30c9"]}