{"pubDate": "2024-10-08T17:00:55", "original_title": "3D Printering: Listen to Klipper", "link": "https://hackaday.com/2024/10/08/3d-printering-listen-to-klipper/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/02/3D-Printering-Header-New.jpg", "original_content": "I recently wrote about using Klipper to drive my 3D printers, and one natural question is: Why use Klipper instead of Marlin? To some degree thats like asking why write in one programming language instead of another. However, Klipper does offer some opportunities to extend the environment more easily. Klipper runs on a Linux host, so you can do all of the normal Linux things.\nWhat if you wanted to create a custom G-code that would play a wave file on a speaker? That would let you have custom sounds for starting a print, aborting a print, or even finishing a print.\nIf you recall, I mentioned that the Klipper system is really two parts. Well, actually more than two parts, but two important parts at the core. Klipper is, technically, just the small software stub that runs on your 3D printer. It does almost nothing. The real work is in Klippy, which is mostly Python software that runs on a host computer like a Raspberry Pi or, in my case, an old laptop.\nBecause it is Python and quite modular, it is very simple to write your own extensions without having to major surgery or even fork Klipper. At least in theory. Most of the time, you wind up just writing G-code macros. Thats fine, but there are some limitations. This time, Im going to show you how easy it can be using the sound player as an example.\nMacros All the Way Down\nNormally, you think of gcode as something like: G1 X50 Y50. Some of the newer codes dont start with G, but they look similar. But with Klipper, G1, M205, and MeltdownExtruder are all legitimate tokens that could be G-code.\nFor example, suppose you wanted to implement a new command called G_PURGE to create a purge line (case doesnt matter, by the way). Thats easy. You just need to put in your configuration file:\n[gcode_macro g_purge]\ngcode:\n# do your purge code here\nThe only restriction is that numbers have to occur at the end of the name, if at all. You can create a macro called Hackaday2024, but you cant create one called Hackaday2024_Test. At least, the documentation says so. We havent tried it.\nTheres more to macros. You can add descriptions, for example. You can also override an existing macro and even call it from within your new macro. Suppose you want to do something special before and after a G28 homing command:\n[gcode_macro g28]\ndescription: Macro to do homing (no arguments)\nrename_existing: g28_original\ngcode:\nM117 Homing...\ng28_original\nM117 Home done....\n\nNot Enough!\nBy default, your G-code macros cant call shell commands. There are some ways to add that feature, but letting a file just run any old command seems like an unnecessary invitation for mayhem. Instead, well write a Klippy extra. This is a Python class that resides in your klipper/klippy/extra directory.\nYour code will run with a config object that lets you learn about the system in different ways. Suppose you are writing code to set up one single item, and it doesnt make sense that you might have more than one. For example, consider an extra that raises the print speed for all printing. Then, youd provide an entry point, load_config, and it would receive the config object.\nHowever, it is more common to write code to handle things that could  at least in theory  have multiple instances. For example, if you wanted to control a fan, you might imagine that a printer could have more than one of these fans. In that case, you use load_config_prefix. That allows someone who writes a configuration file to specify multiple copies of the thing you define:\n[hackaday_fan fan1]\npin: 8\n[hackaday_fan_fan2]\npin: 9\nThe Sounds\nIn this case, we do want to allow for different sounds to play, so well use load_config_prefix. Heres the short bit of code that does the trick:\n\n\nh1Play a sound from gcode/h1\n\n#\n\nh1Copyright (C) 2023 Al Williams/h1\n\nh1 /h1\n\n#\n\nh1This file may be distributed under the terms of the GNU GPLv3 license./h1\n\nimport os\nimport shlex\nimport subprocess\nimport logging\nclass AplayCommand:\n   def stronginit/strong(self, config):\n   self.name = config.get_name().split()-1] # get our name\n   self.printer = config.get_printer()\n   self.gcode = self.printer.lookup_object(#039;gcode#039;) # get wave and path\n   wav = config.get(#039;wave#039;)\n   path = config.get(#039;path#039;,None)\n   if path!=None:\n      wav = quot;aplay quot;+path+#039;/#039;+wav\n   else:\n      wav = quot;aplay quot; + wav\n   self.wav = shlex.split(wav) # build command line\n   self.gcode.register_mux_command( # register new command for gcode_macro\n       quot;APLAYquot;, quot;SOUNDquot;, self.name,\n       self.cmd_APLAY_COMMAND, # worker for new command\n   desc=self.cmd_APLAY_COMMAND_help) # help text\n\ncmd_APLAY_COMMAND_help = quot;Play a soundquot;\n\ndef cmd_APLAY_COMMAND(self, params):\n      try:\n         proc = subprocess.run(self.wav) # run aplay\n      except Exception:\n         logging.exception(\n         quot;aplay: Wave {%s} failedquot; % (self.name))\n      raise self.gcode.error(quot;Error playing {%s}quot; % (self.name))\n\nh1main entry point/h1\n\ndef load_config_prefix(config):\n   return AplayCommand(config)\n\n\nNote that the AplayCommand object does all the actual configuration when you initialize it with a config object. So, to create an aplay object in your config files:\n[aplay startup]\nwave: powerup.wav\npath: /home/klipper/sounds\n\n[aplay magic]\nwave: /home/klipper/sounds/wand.wav\nThen, to use that sound in a macro, you only need to use:\n[gcode_macro get_ready]\ngcode:\n\u00a0\u00a0 aplay sound=startup\nYou can make as many different sounds as you like, and if you provide an entire path for the wave parameter, you can omit the path. Optional parameters like this require a default in your code:\n path = config.get('path',None)\nObviously, this assumes your Klipper computer has aplay installed and the wave files you want to play. Or, switch players and use whatever format you want.\nYou can read more about options and other things you can do in the Adding a host module section of the code overview documentation. Another good resource is the source code for the stock extras, many of which arent really things youd probably consider as extra.\nSo next time you want to add some features to your printer, you can do it in Python with less work than you probably thought. Havent tried Klipper? You can learn more and get set up fairly quickly."}