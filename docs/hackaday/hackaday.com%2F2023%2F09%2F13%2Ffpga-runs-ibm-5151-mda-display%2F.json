{"pubDate": "2023-09-14T05:00:50", "original_title": "FPGA Runs IBM 5151 MDA Display", "link": "https://hackaday.com/2023/09/13/fpga-runs-ibm-5151-mda-display/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/09/1688521681366884937-e1694507585355.jpg", "original_content": "When it comes to driving a display, you can do all kinds of fancy tricks with microcontrollers to get an image up. Really, though, FPGAs are the weapon of choice for playing with these kinds of signals. [Ted Fried] put one to great work driving an ancient IBM 5151 MDA display, and shared his results on Hackaday.io.\nThe build relies on a Digilent Arty Z7-20 SOC FPGA development board, which has a beefy 600 MHz ARM processor on board. It also packs 500 MB of DRAM\u2014more than enough for storing pixel data for an ancient display.\nTo drive the old display, [Ted] whipped up a state machine on the FPGA. Its tasked with fetching display data from RAM and creating the appropriate timings for the MDA display interface. The images are stored directly in an array in C code running on the ARM core. From there, they are copied into the FPGAs RAM for trucking out to the display. The 720350 images are stored as 1 bit per pixel, and are created by converting the original JPEGs into single-bit bitmaps in GIMP, before final conversion into a C code array via utility of [Teds] own design.\nIf youve ever wanted to display your images in resplendent amber or green, then this could be the project for you. Its also just a great way to learn about using FPGAs and interfacing with alternative display technologies. If youve been whipping up your own retro display hacks, dont hesitate to drop us a line.", "title": "\u30ec\u30c8\u30ed\u306aIBM 5151 MDA\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u3092FPGA\u3067\u99c6\u52d5\u3059\u308b\u65b9\u6cd5", "body": "FPGA\u3067\u53e4\u3044IBM 5151 MDA\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u3092\u52d5\u304b\u3059\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u304c\u3042\u308a\u307e\u3059\u3002ARM\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u642d\u8f09\u3057\u305fDigilent Arty Z7-20 SOC FPGA\u958b\u767a\u30dc\u30fc\u30c9\u3092\u4f7f\u7528\u3057\u3001C\u30b3\u30fc\u30c9\u3067\u753b\u50cf\u3092\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306b\u8868\u793a\u3055\u305b\u307e\u3059\u3002\u53e4\u3044\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u3092\u4f7f\u3063\u305f\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3084FPGA\u306e\u6d3b\u7528\u306b\u8208\u5473\u304c\u3042\u308b\u65b9\u306b\u304a\u3059\u3059\u3081\u3002", "titles": ["\u30ec\u30c8\u30ed\u306aIBM 5151 MDA\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u3092FPGA\u3067\u99c6\u52d5\u3059\u308b\u65b9\u6cd5", "Digilent Arty Z7-20 SOC FPGA\u3092\u4f7f\u7528\u3057\u305f\u53e4\u3044\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306e\u99c6\u52d5\u65b9\u6cd5", "\u30d4\u30af\u30bb\u30eb\u30c7\u30fc\u30bf\u3092RAM\u306b\u683c\u7d0d\u3057\u3001MDA\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306b\u9069\u5207\u306a\u30bf\u30a4\u30df\u30f3\u30b0\u3067\u8868\u793a\u3059\u308b", "1\u30d4\u30af\u30bb\u30eb\u3042\u305f\u308a1\u30d3\u30c3\u30c8\u306e\u753b\u50cf\u3092FPGA\u3067\u4f5c\u6210\u3057\u3001\u53e4\u3044\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306b\u8868\u793a\u3059\u308b\u65b9\u6cd5", "FPGA\u3092\u4f7f\u7528\u3057\u3066\u30ec\u30c8\u30ed\u306a\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u6280\u8853\u3068\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u5b66\u3076\u65b9\u6cd5"]}