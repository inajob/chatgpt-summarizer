{"pubDate": "2025-09-04T14:00:47", "original_title": "Bootstrapping Android Development: a Survival Guide", "link": "https://hackaday.com/2025/09/04/bootstrapping-android-development-a-survival-guide/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/08/AndroidBootstrap.jpg", "original_content": "Developing Android applications seems like it should be fairly straightforward if you believe the glossy marketing by Google and others. Its certainly possible to just follow the well-trodden path, use existing templates and example code  or even use one of those WYSIWYG app generators  to create something passable that should work okay for a range of common applications. Thats a far cry from learning general Android development, of course.\nThe process has changed somewhat over the years, especially with the big move from the Eclipse-based IDE with the Android Development Tools (ADT) plugin, to todays Jetbrains IntelliJ IDEA-based Android Studio. Its fortunately still possible to download just the command-line tools to obtain the SDK components without needing the Google-blessed IDE. Using the CLI tools its not only possible to use your preferred code editor, but also integrate with IDEs that provide an alternate Android development path, such as Qt with its Qt Creator IDE.\n\nPicking Poison\nBoth Qt Creator and ADT/Android Studio offer a WYSIWYG experience for GUI design, though the formers design tools are incomparably better. Much of this appears to be due to how Qt Creators GUI design tools follow the standard desktop GUI paradigms, with standard elements and constraint patterns. After over a decade of having wrangled the  also XML-based  UI files and WYSIWYG design tools in ADT/Android Studio, it never ceases to amaze how simple things like placing UI elements and adding constraints love to explode on you.\nThe intuitive Android Studio WYSIWYG experience.\nSomewhat recently the original Android API layouts also got ditched in favor of the refactored AndroidX API layouts, with apparently now this Jetpack Compose being the (high-level) way to use. Over the years of me having developed for Android, many APIs and tools have been introduced, deprecated and removed at an increasingly rapid pace, to the point where having Android Studio or the CLI tools not freak out when confronted with a one year old project is a pleasant surprise.\nDesigning GUIs in Qt Creators Designer mode.\nAlthough Qt isnt the only alternative to the Android Studio experience, it serves to highlight the major differences encountered when approaching Android development. In fact, Qt for Android offers a few options, including building a desktop Qt application for Android, which can also use the Qt Quick elements, or including Qt Quick within your existing Android application. For Qt Quick you want to either create the UIs by hand, or using Qt Quick Designer, though I have so far mostly just stuck to using Qt Creator and liberally applied stylesheets to make the UI fit the target Android UI.\nWhichever way you choose, its important to know your requirements and take some time to work through a few test projects before investing a lot of time in a single approach.\nThe Build System\nNo matter what approach you choose, the build system for Android is based on what is objectively one of the worst build automation tools conceivable, in the form of Gradle. Not only does it take ages to even start doing anything, its also agonizingly slow, insists on repeating tasks that should already have been completed previously, provides few ways to interact or get more information without getting absolutely swamped in useless verbosity, and loves to fail silently if you get just the wrong Gradle version installed in your Android project.\nDid I mention yet that the entire Gradle tool is a permanent fixture of your Android project? Android Studio will want to upgrade it almost every time you open the project, and if you dont use an IDE like it which automates Gradle upgrades, you better learn how to do it manually. Dont forget to install the right Java Development Kit (JDK) either, or Android Studio, Gradle or both will get very upset.\nIf your IDE doesnt pave over many of these inane issues, then getting familiar with the Gradle wrapper CLI commands is right on the top of your list, as you will need them. Fortunately sticking to an IDE here tends to avoid the biggest pitfalls, except for having enough time with each build session to fetch a coffee and go on a brisk walk before returning to address the next build failure.\nThere are no real solutions here, just a call for perseverance and documenting solutions that worked previously, because you will always encounter the same errors again some day.\nTest, Debug And Deploy\nCreating a new virtual Android device.\nEven if you have built that shiny APK or app bundle, theres a very high likelihood that there will be issues while running it. Fortunately the one advantage of JVM-based environments is that you get blasted with details when something violently explodes. Of course, that is unless someone screwed up exception handling in the code and your backtrace explodes somewhere in thin air instead. For the same reason using a debugger is pretty easy too, especially if you are using an IDE like Android Studio or Qt Creator that provides easy debugger access.\nLogging in Android tends to be rather verbose, with the LogCat functionality providing you with a veritable flood of logging messages, most of which you want to filter out. Using the filter function of your IDE of choice is basically essential here. Usually when I do Android application debugging, I am either already running Qt Creator where I can start up a debug session, or I can fire up Android Studio and do the same here as at its core its the same Gradle-based project.\n\nThe NymphCast Player Android build, with default skin.\nOf course, in order to have something catch on fire you first need to run the application, which is where you get two options: run on real hardware or use an emulator. Real hardware is easier in some ways, as unlike an emulated Android Virtual Device (AVD) your application can directly access the network and internet, whereas an AVD instance requires you to wrangle with network redirects each session.\nOn the other hand, using an AVD can be handy as it allows you to create devices with a wide range of screen resolutions, so it can be quite nifty to test applications that do not require you to connect to externally via the network. If you want to know for example how well your UI scales across screen sizes, and how it looks on something like a tablet, then using an AVD is a pretty good option.\nSome hardware devices are also quite annoyingly locked-down, such as Xiaomi phones that at least for a while have refused to allow you to toggle on remote debugging via USB unless you install a SIM card. Fortunately this could be circumvented by clicking through an alternate path that the Xiaomi developers had not locked down, but these are just some of the obnoxious hurdles that you may encounter with real hardware.\nWith that out of the way, deploying to an AVD or real device is basically the same, either by using the Start or similar function in your IDE of choice with the target device selected, or by doing so via the command-line, either with ADB, or via the Gradle wrapper with ./gradlew InstallDebug or equivalent.\nThis will of course be a debug build, with creating a release build also being an option, but this will not be signed by default. Signing an APK requires a whole other procedure, and is honestly something thats best done via the friendly-ish dialogs in an IDE, rather than by burning a lot of time and sanity on the command-line. Whether you want to sign the APK or app bundle depends mostly on your needs/wants and what a potential app store demands.\nEver since Google began to demand that all developers  including Open Source hobbyists  send in a scan of their government ID and full address, I have resorted to just distributing the Android builds of my NymphCast player and server via GitHub, from where they can be sideloaded.\nThis NymphCast server is incidentally the topic of the next installment in this mini-series, in which we will be doing a deep dive into native Android development using the NDK.", "title": "**Android\u30a2\u30d7\u30ea\u958b\u767a\u306e\u57fa\u790e\u3068\u9032\u5316**", "body": "Android\u30a2\u30d7\u30ea\u958b\u767a\u306f\u591a\u69d8\u306a\u9078\u629e\u80a2\u304c\u3042\u308b\u304c\u3001Gradle\u306e\u4f7f\u3044\u52dd\u624b\u304c\u60aa\u3044\u3002", "titles": ["**Android\u30a2\u30d7\u30ea\u958b\u767a\u306e\u57fa\u790e\u3068\u9032\u5316**", "**Qt Creator vs Android Studio: GUI\u30c7\u30b6\u30a4\u30f3\u306e\u9055\u3044**", "**Gradle\u3068\u95d8\u3046: Android\u30d3\u30eb\u30c9\u30b7\u30b9\u30c6\u30e0\u306e\u8ab2\u984c**", "**\u30c7\u30d0\u30c3\u30b0\u3068\u30c6\u30b9\u30c8: Android\u30a2\u30d7\u30ea\u306e\u54c1\u8cea\u5411\u4e0a**", "**\u30ea\u30a2\u30eb\u30c7\u30d0\u30a4\u30b9\u3068\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc: \u30a2\u30d7\u30ea\u306e\u52d5\u4f5c\u691c\u8a3c\u65b9\u6cd5**"]}