{"pubDate": "2024-04-06T08:00:54", "original_title": "Linear Feedback Shift Registers for FPGAs", "link": "https://hackaday.com/2024/04/06/linear-feedback-shift-registers-for-fpgas/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/04/lfsr.png", "original_content": "If you want to start an argument at a Hackaday meeting, you have only to ask something like How much does this weigh? or What time is it? But if you really want to start a street brawl, you can always say, Are these numbers random? Making random numbers that are actually random is actually a tough nut to crack. Most of what we do is, technically, pseudo-random (but well say random number and assume you know what we mean). One way to generate seemingly random sequences is to use a linear feedback shift register or LFSR. You can use LFSRs in software, but they are also very useful in hardware design and [Adam Taylor] takes us through his use of them on FPGAs in a recent post.\nAs [Adam] points out, they not only generate random-like patterns but they are often used as high-performance counters and in error detection and correction schemes. As the name implies, the mechanism is a simple shift register with one or more of its outputs fed back around to the input. How can that be random? Well, it cant be, but it is often good enough for places where you need a sequence of numbers. Depending on how you organize the outputs  or taps  and how you feed them back means you can control the pseudo-random sequence.\nA Fibonacci LFSR\nThere are two common methods for creating LFSRs. A Fibonacci-style design uses XOR (or inverted XOR) gates in the feedback loop. For example, consider an eight-stage counter. The post shows the output of flip flop 4, feeding an XOR gate that drives the counters input. The other input of the XOR gate is the output of another XOR gate that receives input from flip flop 5 and the output of yet another XOR gate. That XOR gate receives its inputs from flip flop 6 and the output of the shift register.\nThe Galois scheme is similar, but uses the XOR gates in the shift path. In other words, the output of the shift register directly feeds the input, but it also feeds several XOR gates that go between the flip flops. Why choose one over the other? Read the post. The summary is that it depends on how your FPGA resets and what kind of support it has for shift registers so, as usual, it pays to understand whats going on in the FPGA fabric.\nAs for where to put the taps, it depends on how you want the pattern to repeat. If you want the repeating kept to a minimum, you can look them up in a table based on research from [Wayne Stahnke] and popularized by Xilinx in an app note. [Solomon Golumb] also published tables of taps for maximum sequence generation. As you might expect, theres a program that will help you if you dont want to use the tables.\nThe math may be hairy, but implementing this in hardware is simple if you ever need a random-looking sequence. Maybe you want a random flicker in your fake candle. You can do it with relays, even.", "title": "\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u8a2d\u8a08\u306b\u304a\u3051\u308b\u7dda\u5f62\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30d5\u30c8\u30ec\u30b8\u30b9\u30bf\uff08LFSR\uff09\u306e\u6d3b\u7528", "body": "\u8a18\u4e8b\u3067\u306f\u3001\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u30c7\u30b6\u30a4\u30f3\u306b\u304a\u3051\u308b\u7591\u4f3c\u4e71\u6570\u751f\u6210\u306b\u4f7f\u7528\u3055\u308c\u308bLFSR\uff08\u7dda\u5f62\u5e30\u9084\u30b7\u30d5\u30c8\u30ec\u30b8\u30b9\u30bf\uff09\u306b\u3064\u3044\u3066\u8aac\u660e\u3055\u308c\u3066\u3044\u308b\u3002XOR\u30b2\u30fc\u30c8\u3092\u4f7f\u3063\u305fFibonacci\u30b9\u30bf\u30a4\u30eb\u3068Galois\u30b9\u30ad\u30fc\u30e0\u306e2\u3064\u306e\u65b9\u6cd5\u304c\u7d39\u4ecb\u3055\u308c\u3001\u7591\u4f3c\u4e71\u6570\u5217\u306e\u751f\u6210\u65b9\u6cd5\u304c\u89e3\u8aac\u3055\u308c\u3066\u3044\u308b\u3002", "titles": ["\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u8a2d\u8a08\u306b\u304a\u3051\u308b\u7dda\u5f62\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30d5\u30c8\u30ec\u30b8\u30b9\u30bf\uff08LFSR\uff09\u306e\u6d3b\u7528", "\u30e9\u30f3\u30c0\u30e0\u6570\u5024\u751f\u6210\u306e\u305f\u3081\u306e\u7dda\u5f62\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30d5\u30c8\u30ec\u30b8\u30b9\u30bf\uff08LFSR\uff09\u306e\u4f7f\u3044\u65b9", "LFSR\uff08\u7dda\u5f62\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30d5\u30c8\u30ec\u30b8\u30b9\u30bf\uff09\u3092\u4f7f\u3063\u305f\u64ec\u4f3c\u4e71\u6570\u306e\u751f\u6210\u65b9\u6cd5", "FPGA\u3067\u306e\u7dda\u5f62\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30d5\u30c8\u30ec\u30b8\u30b9\u30bf\uff08LFSR\uff09\u306e\u5b9f\u88c5\u65b9\u6cd5", "\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u8a2d\u8a08\u306b\u304a\u3051\u308b\u7591\u4f3c\u4e71\u6570\u751f\u6210\u5668\uff1a\u7dda\u5f62\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30d5\u30c8\u30ec\u30b8\u30b9\u30bf\uff08LFSR\uff09"]}