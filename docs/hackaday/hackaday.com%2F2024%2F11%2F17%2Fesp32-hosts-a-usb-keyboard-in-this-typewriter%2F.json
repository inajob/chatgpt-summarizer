{"pubDate": "2024-11-17T15:00:45", "original_title": "ESP32 hosts a USB keyboard in this Typewriter", "link": "https://hackaday.com/2024/11/17/esp32-hosts-a-usb-keyboard-in-this-typewriter/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/11/volos1.png", "youtube": "https://www.youtube.com/watch?v=NcncyV8UWsc", "original_content": "Did you know the ESP32 can be a USB host? Well it can, and\u00a0[Volos] uses host mode to build this fun little word processor.\nThe venerable ESP32 has a well-known USB device mode. Anyone who has programmed one has used it. A bit less known is the microcontrollers ability to host USB devices. These days, operating as a USB device is relatively simple. But acting as a host is a much more complex task. The ESP32 has a software host that works  but only for Human Interface Devices (HID).\u00a0 Human interface devices generally are keyboards, mice, trackballs, and similar devices that handle data relatively slowly, forming the interface with us simple humans.\n[Volos] uses the EspUsbHost Arduino library for this project. The library makes USB host mode simple to use. Another piece of the puzzle is the LCD board [Volos] picked. It has a dual-role USB Type-C port, meaning the hardware to switch roles is baked in. Other boards may require some modifications or special cables to make things work.\nThe software is the best part of this build. [Volos] implemented a simple word processor. It can save and load files from a microSD card and, of course, edit text  all controlled by a USB keyboard. He had to use a 4-bit palette to save memory. This gives the device a retro charm that reminds us of Don Lancasters TV Typewriter. The source for this and all of [Volos] projects can be found on GitHub. Now, all we need is a spell check that can fit in the memory constraints of the ESP32! We have to admit the chip has a lot of potential USB tricks.\n\n", "title": "ESP32\u3092USB\u30db\u30b9\u30c8\u306b\u5909\u8eab\u3055\u305b\u308b\u65b9\u6cd5", "body": "ESP32\u306fUSB\u30db\u30b9\u30c8\u3068\u3057\u3066\u3082\u6d3b\u7528\u3067\u304d\u3001\u6587\u7ae0\u4f5c\u6210\u6a5f\u80fd\u3092\u63d0\u4f9b\u3002", "titles": ["ESP32\u3092USB\u30db\u30b9\u30c8\u306b\u5909\u8eab\u3055\u305b\u308b\u65b9\u6cd5", "\u7c21\u5358\u306a\u30ef\u30fc\u30c9\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u4f5c\u308bESP32\u30d7\u30ed\u30b8\u30a7\u30af\u30c8", "HID\u30c7\u30d0\u30a4\u30b9\u3092\u5229\u7528\u3057\u305fESP32\u306eUSB\u30db\u30b9\u30c6\u30a3\u30f3\u30b0", "\u30de\u30a4\u30af\u30edSD\u30ab\u30fc\u30c9\u5bfe\u5fdc\u306eESP32\u30ef\u30fc\u30c9\u30d7\u30ed\u30bb\u30c3\u30b5\u5b9f\u88c5", "\u30ec\u30c8\u30ed\u306a\u9b45\u529b\u3092\u6301\u3064ESP32\u306e\u30c6\u30ad\u30b9\u30c8\u30a8\u30c7\u30a3\u30bf"]}