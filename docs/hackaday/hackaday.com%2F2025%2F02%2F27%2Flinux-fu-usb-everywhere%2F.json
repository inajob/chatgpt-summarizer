{"pubDate": "2025-02-27T18:00:34", "original_title": "Linux Fu: USB Everywhere", "link": "https://hackaday.com/2025/02/27/linux-fu-usb-everywhere/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "It is a common problem: I have a USB device on a computer out in the shop, and I want to use it from the comfort of my office. What to do? Well, you could remote desktop into the distant machine. But, honestly, I always find any remote desktop more than ssh clunky and somewhat undesirable. Fortunately, Linux can do virtually anything if you only know how to do it. So, this time, Ill show you how to transport a USB device over your network. Of course, I have a network that reaches out to the shop. It should be a simple matter to tell my desktop machine that one of its USB devices lives across the network. Well, it wasnt that simple, but it is doable.\nThe Tools\nThe whole thing involves a program called usbip. That should be the end of it, but of course, it isnt. In order for this to work, both machines on the network will need some kernel modules and a daemon on the server: the machine with the USB devices to share.\nYou may be able to install usbip from your package manager. On Ubuntu, it is in the linux-tools-common package, so a simple apt-get might give you everything you need. I wasnt so lucky.\nHow far away can you mount this USB drive?\nI use a custom kernel (xanmod), so I had a problem. While I had the kernel modules, I didnt have the client tools and the ones in the standard repository are tied to your kernel version. Running the stock versions gave me an error message. So I had to find a way to make things myself.\nHeres what you need in the way of kernel modules on the server: usbip_core, usbip_host. You also need usbipd (the daemon). On both machines, you need the control program, usbip. On the client machine, you need the vhci_hcd module. If you can get all this working and with compatible versions, you are pretty much home-free.\nIn my case, I had to download my kernel source and find the tools/usb/usbip directory. Normally, you can build everything with the Makefile in tools/, but this seems to be a special case. You run the autogen.sh file to create the build setup. Then do a ./configure and a make. A make install will finish things up. Just be sure that where it installs for you is where you run the tools in the next steps.\nThe Pi Connection\nMany people use a Raspberry Pi as a sort of USB server. In that case, the setup is pretty easy:\nsudo apt install usbip hwdata usbutils\nThat should get you everything you need. For that matter, if you run a pretty stock version of Ubuntu, you might try:\nsudo apt install linux-tools-generic linux-cloud-tools-generic\nFor anything else, youll need to do some homework.\nSetup\nAssuming you have everything ready, you need to do several things. First, you must load the modules on both the server and the client. Then, you need to run the daemon on the server. You can bind one or more USB devices to the server using the command line tool. Notice that the USB device has to be free; once you bind it to the server, you cant use it directly anymore.\nYoull then connect with the client. Again, one client acquires the device, and thats it. It cant be shared. Sure, you can release it, and someone else can get it. Or the server can drop it, returning the device for local use. However, while the server has the device, only one client can use that device at any given time.\nLoading the modules is easy with modprobe, although over the long term, you probably want to add them to /etc/modules-load.d so they will load at boot time. For now, on the server, try:\nsudo modprobe -a usbip_core usbip_host\nOn the client:\nsudo modprobe -a vhci_hcd\nYoull also have to run usbipd on the server. You can do that in any way you usually run a daemon, including systemd, rc.local, or whatever. For now, just run it as root from the command line.\nYou need to find at least one device to share, so from the server try:\nsudo usbip list -l\u00a0\u00a0 # -l for local\nThis will give you a list of devices. What you want is the bus id. Suppose it is 4-3.1. Youll bind that device to the server:\nsudo usbpip bind -b 4-3.1\nNow, from the client, you should be able to see the device:\nsudo usbip list -r myserver.local\u00a0 # use your server name or IP\nYou can then attach to it:\nusbip attach -r myserver.local -b 4-3.1\nCommands\nA good first test is to share a USB drive over the network. There are other ways to do this, but it is easy to see that it works with standard software. Heres a transcript, assuming root prompts on both server and client, along with all the preliminary setup:\nserver # usbip list -l\n\n...\n\n- busid 5-2.1.2.3 (0781:5575)\nSanDisk Corp. : Cruzer Glide (0781:5575)\n...\n\nserver # usbip bind -b 5-2.1.2.3\n\nclient # usbip list -r 192.168.1.2\u00a0\u00a0 # or whatever IP/address\n\nExportable USB devices\n======================\n- 192.168.1.2\n5-2.1.2.3: SanDisk Corp. : Cruzer Glide (0781:5575)\n: /sys/devices/pci0000:00/0000:00:01.2/0000:01:00.0/0000:02:08.0/0000:08:00.3/usb5/5-2/5-2.1/5-2.1.2/5-2.1.2.3\n: (Defined at Interface level) (00/00/00)\n\nclient # ls /dev/sd*\u00a0\u00a0\u00a0 # see what hard drives are available before sharing\n\n/dev/sda \u00a0/dev/sda1 \u00a0/dev/sda2 \u00a0/dev/sda3\n\nclient # usbip attach -r 192.168.1.2 -b 5-2.1.2.3\nclient # ls /dev/sd*\n/dev/sda \u00a0/dev/sda1 \u00a0/dev/sda2 \u00a0/dev/sda3 \u00a0/dev/sdb \u00a0/dev/sdb1 \u00a0/dev/sdb2 \u00a0/dev/sdb3\nclient # mount /dev/sdb3 /mnt\nclient # ls /mnt\n\n... output of ls ...\n\nclient # umount /mnt\nclient # usbip port\n\nImported USB devices\n====================\nPort 00: Port in Use at High Speed(480Mbps)\nSanDisk Corp. : Cruzer Glide (0781:5575)\n3-1 - usbip://192.168.1.2:3240/5-2.1.2.3\n- remote bus/dev 005/028\n\nclient # usbip detach -p 00\u00a0 # 00 is port number from above\n\nserver # usbip unbind -b 5-2.1.2.3\u00a0\u00a0\u00a0 # release from server, too\nNote that you have to detach by port number, even though everything else takes a bus ID, which is somewhat dynamic across reboots. Also, if the system suspends, you may have to reshare the device.\nThis GUI for usbip has a Hackaday.io page and a project on GitHub.\nTo summarize, you can use variations of the list command to show local or remote devices. If you ask the server to show you remote devices on 127.0.0.1, you can easily see what devices are exported. On the client, the port command shows you whats connected.\nOn the server, you bind or unbind devices. On the client, you attach and detach.\nOnce the device attaches, it looks like any other USB port on your system. Pretty cool!\nIf the command line isnt your thing, we noticed a Hackaday.io project aimed at creating a Qt GUI for the client work. It doesnt seem to be active, but it might be something to try or someplace to start.\nThe Windows Connection\nThere are two clients for using USB devices on Windows. The newer one requires you to be in test signing mode and has several other warnings. It originally forked from an older version that some people prefer and may support the server part, too. I havent tried it, so if you want to explore using Windows, you are on your own but do report what you find in the comments.\nUsually, we want our USB cables shorter, not longer. We wonder if a USB keyboard and monitor with a Pi server could make a good remote terminal.", "title": "\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u8d8a\u3057\u306bUSB\u30c7\u30d0\u30a4\u30b9\u3092\u5229\u7528\u3059\u308b\u65b9\u6cd5", "body": "USB\u30c7\u30d0\u30a4\u30b9\u3092\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u8d8a\u3057\u306b\u5229\u7528\u3059\u308b\u65b9\u6cd5\u3092\u89e3\u8aac\u3057\u3066\u3044\u307e\u3059\u3002", "titles": ["\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u8d8a\u3057\u306bUSB\u30c7\u30d0\u30a4\u30b9\u3092\u5229\u7528\u3059\u308b\u65b9\u6cd5", "Linux\u3067\u306eUSB\u30c7\u30d0\u30a4\u30b9\u306e\u30ea\u30e2\u30fc\u30c8\u5171\u6709", "Raspberry Pi\u3092USB\u30b5\u30fc\u30d0\u30fc\u3068\u3057\u3066\u6d3b\u7528\u3059\u308b", "usbip\u3092\u4f7f\u3063\u305fUSB\u30c7\u30d0\u30a4\u30b9\u306e\u5171\u6709\u624b\u9806", "Windows\u3067\u306eUSB\u30c7\u30d0\u30a4\u30b9\u4f7f\u7528\u65b9\u6cd5\u306e\u30ac\u30a4\u30c9"]}