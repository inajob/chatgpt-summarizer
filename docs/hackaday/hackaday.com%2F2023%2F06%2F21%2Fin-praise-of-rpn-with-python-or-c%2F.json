{"pubDate": "2023-06-21T14:00:35", "original_title": "In Praise of RPN (with Python or C)", "link": "https://hackaday.com/2023/06/21/in-praise-of-rpn-with-python-or-c/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "HP calculators, slide rules, and Forth all have something in common: reverse polish notation or RPN. Admittedly, slide rules dont really have RPN, but you work problems on them the same way you do with an RPN calculator. For whatever reason, RPN didnt really succeed in the general marketplace, and you might wonder why it was ever a thing. The biggest reason is that RPN is very easy to implement compared to working through proper algebraic, or infix, notation. In addition, in the early years of computers and calculators, you didnt have much to work with, and people were used to using slide rules, so having something that didnt take a lot of code that matched how users worked anyway was a win-win.\nWhat is RPN?\nIf you havent encountered RPN before, it is an easy way to express math without ambiguity. For example, whats 5 + 3 * 6?\u00a0 Its 23 and not 48. By order of operations you know that you have to multiply before you add, even if you wrote down the multiplication second. You have to read through the whole equation before you can get started with math, and if you want to force the other result, youll need parentheses.\nWith RPN, there is no ambiguity depending on secret rules or parentheses, nor is there any reason to remember things unnecessarily. For instance, to calculate our example you have to read all the way through once to figure out that you have to multiply first, then you need to remember that is pending and add the 5. With RPN, you go left to right, and every time you see an operator, you act on it and move on. With RPN, you would write 3 6 * 5 +.\nWhile HP calculators were the most common place to encounter RPN, it wasnt the only place. Friden calculators had it, too. Some early computers and calculators supported it but didnt name it. Some Soviet-era calculators used it, too, including the famous Elektronika B3-34, which was featured in a science fiction story in a Soviet magazine aimed at young people in 1985. The story set problems that had to be worked on the calculator.\n\nHow to Do Algebraic\nIt is illustrative to see how complex it is to do algebraic expressions the normal way. The usual method is to use two stacks and a precedence table. The steps are:\n1. Grab a token\n2. If the token is a number, push it on the value stack.\n3. If the token is an operator, check to see if it is lower in precedence than the top of the operator stack (e.g., this is a plus sign, and the top of the stack is for multiplication). If so, do the indicated operation from the top of the stack, update the value stack, and then repeat this step.\n4. Once the current operator is higher in precedence than the top of the operator stack, push it on the operator stack.\n5. Repeat all steps until you are done, and then work through whatever is left on the stack.\nUsually, you have a low precedence start marker and a high precedence end marker that are fake tokens. Open parenthesis is also high precedence. After that, you have the operators in their usual order. So consider (5+2) + 6*3. If you add the start and end markers (Ill use []), you get [(5+2)+6*3].\nAfter processing the first plus sign, the operator stack will contain: [(+, and the value stack will have 5 (and, soon, 5 2). The close parenthesis will cause 5+2 to calculate and remove the opening match. So then the value stack will have 7, and the operator stack will be empty except for the start marker.\nWhen you read the end marker, the value stack will be 7 6 3, and the operator stack will be [+ *. Since the end marker is higher than everything else, step 3 will cause it first to compute 6*3, leaving the stacks to contain 7 18 and [+. Another pass through step 3 leaves 25 and [ which matches the ], and the operation is complete.\nWhile this isnt that hard, it does take two stacks and a table. The stacks can be arbitrarily long, although in practice, that isnt necessary. But it still seems like a lot of work.\nPython RPN\nProcessing RPN, on the other hand, is easy. If you see a number, push it on the value stack. If you see an operator, pop off enough stuff from the stack, do the operation, and put the result back on the stack. In Python, this is very simple (see the entire code on this gist):\n\n# parse an RPN string and execute it \ndef parse(self,s):\n   tokens=s.split()\n   for token in tokens:\n      try:\n         num=float(token)\n         rpn.push(num)\n       except ValueError:\n         if token==x or token==X: # exchange top of stack\n            exchange()\n          elif token==?: # dump stack\n             self.dump()\n          elif token==+:\n             rpn.add()\n          elif token=='-':\n             rpn.sub()\n          elif token==*:\n             rpn.mul()\n          elif token==/:\n             rpn.div()\n          elif token[0]==!:\n             self.vars[token[1:]]=self.peek() # store tos in var\n          elif token[0]==@:\n             self.push(self.vars[token[1:]]) # push var to tos\n          else:\n              raise Exception(Unknown operator or number: + token)\n\nThis handles the four basic math functions and a few special operators to exchange the two top stack elements or display the stack. It can also store named variables (!somevar) and use them again later (@somevar). Prefer C? There is a simple version in the gist, also.\nWhy Not?\nIf you need to represent math in a program, you might consider RPN. It is fast to write and easy on resources. Of course, you can just as easily make the infix algorithm spit out RPN code instead of doing the work itself, but there isnt much benefit to that unless you are writing a compiler. Going the other way is possible, too, but a little harder.\nThen again, if you dont mind having a lot more power and you are using Python, you might think about using eval() for infix notation. However, since it can execute anything Python, thats not the right answer for all programs, especially not those that process user input. Not to mention, thats notoriously hard to do in compiled languages like C.\nSome pretty beefy computer/calculators used RPN. Or, you can homebrew one."}