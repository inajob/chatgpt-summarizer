{"pubDate": "2025-07-18T14:00:34", "original_title": "This Week in Security: Trains, Fake Homebrew, and AI Auto-Hacking", "link": "https://hackaday.com/2025/07/18/this-week-in-security-trains-fake-homebrew-and-ai-auto-hacking/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2016/01/darkarts.jpg", "original_content": "Theres a train vulnerability making the rounds this week. The research comes from [midwestneil], who first discovered an issue way back in 2012, and tried to raise the alarm.\n\nTurns out you can just hack any train in the USA and take control over the brakes. This is CVE-2025-1727 and it took me 12 years to get this published. This vulnerability is still not patched. Here's the story: https://t.co/MKRFSOa3XY\n neils (@midwestneil) July 11, 2025\n\nTo understand the problem, we have to first talk about the caboose. The caboose was the last car in the train, served as an office for the conductor, and station for train workers to work out of while tending to the train and watching for problems. Two more important details about the caboose, is that it carried the lighted markers to indicate the end of the train, and was part of the trains breaking system. In the US, in the 1980s, the caboose was phased out, and replaced with automated End Of Train (EOT) devices.\nThese devices were used to wirelessly monitor the trains air brake system, control the Flashing Rear End Device (FRED), and even trigger the brakes in an emergency. Now heres the security element. How did the cryptography on that wireless signal work in the 1980s? And has it been updated since then?\nThe only cryptography at play in the FRED system is a BCH checksum, which is not an encryption or authentication tool, but an error correction algorithm. And even though another researcher discovered this issue and reported it as far back as 2005, the systems are still using 1980s era wireless systems. Now that CISA and various news outlets have picked on the vulnerability, the Association of American Railroads are finally acknowledging it and beginning to work on upgrading.\nPutting GitHub Secrets to Work\nWeve covered GitHub secret mining several times in this column in the past. This week we cover research from GitGuardian and Synacktiv, discovering how to put one specific leaked secret to use. The target here is Laravel, an Open Source PHP framework. Laravel is genuinely impressive, and sites built with this tool use an internal APP_KEY to encrypt things like cookies, session keys, and password reset tokens.\nLaravel provides the encrypt() and decrypt() functions to make that process easy. The decrypt() function even does the deserialization automatically.  You may be able to see where this is going. If an attacker has the APP_KEY, and can convince a Laravel site to decrypt arbitrary data, there is likely a way to trigger remote code execution through a deserialization attack, particularly if the backend isnt fully up to date.\nSo how bad is the issue? By pulling from their records of GitHub, GitGuardian found 10,000 APP_KEYs. 1,300 of which also included URLs, and 400 of those could actually be validated as still in use. The lesson here is once again, when you accidentally push a secret to Github (or anywhere on the public Internet), you must rotate that secret. Just force pushing over your mistake is not enough.\nFake Homebrew\nTheres a case to be made that browsers should be blocking advertisements simply for mitigating the security risk that comes along with ads on the web. Case in point is the fake Homebrew install malware. This write-up comes from the security team at Deriv, where a MacOS device triggered the security alarms. The investigation revealed that an employee was trying to install Homebrew, searched for the instructions, and clicked on a sponsored result in the search engine. This led to a legitimate looking GitHub project containing only a readme with a single command to automatically install Homebrew.\nThe command downloads and runs a script that does indeed install Homebrew. It also prompts for and saves the users password, and drops a malware loader. This story has a happy ending, with the companys security software catching the malware right away. This is yet another example of why its foolhardy to run commands from the Internet without knowing exactly what they do. Not to mention, this is exactly the scenario that led to the creation of Workbrew.\nSQL Injection\nYes, its 2025, and were still covering SQL injections. This vulnerability in Fortinets Fortiweb Fabric Connector was discovered independently by [0x_shaq] and the folks at WatchTowr. The flaw here is the get_fabric_user_by_token() function, which regrettably appends the given token directly to a SQL query. Hence the Proof of Concept:\nGET /api/fabric/device/status HTTP/1.1\nHost: 192.168.10.144\nAuthorization: Bearer 123'//or//'x'='x\nAnd if the simple injection wasnt enough, the watchTowr write-up manages a direct Remote Code Execution (RCE) from an unauthenticated user, via a SQL query containing an os.system() call. And since MySQL runs as root on these systems, thats pretty much everything one could ask for.\nAI guided AI attacks\nThe most intriguing story from this week is from [Golan Yosef], describing a vibe-researching session with the Claude LLM. The setup is a Gmail account and the Gmail MCP server to feed spammy emails into Claude desktop, and the Shell MCP server installed on that machine. The goal is to convince Claude to take some malicious action in response to an incoming, unsolicited email. The first attempt failed, and in fact the local Claude install warned [Golan] that the email may be a phishing attack. Where this mildly interesting research takes a really interesting turn, is when he asked Claude if such an attack could ever work.\nClaude gave some scenarios where such an attack might succeed, and [Golan] pointed out that each new conversation with Claude is a blank slate. This led to a bizarre exchange where the running instance of Claude would play security researcher, and write emails intended to trick another instance of Claude into doing something it shouldnt. [Golan] would send the emails to himself, collect the result, and then come back and tell Researcher Claude what happened. Its quite the bizarre scenario. And it did eventually work. After multiple tries, Claude did write an email that was able to coerce the fresh instance of Claude to manipulate the file system and run calc.exe. This is almost the AI-guided fuzzing that is inevitably going to change security research. It would be interesting to automate the process, so [Golan] didnt have to do the busywork of shuffling the messages between the two iterations of Claude. Im confident well cover many more stories in this vein in the future.\n\nBits and Bytes\nSugarCRM fixed a LESS code injection in an unauthenticated endpoint. These releases landed in October of last year, in versions 13.0.4 and 14.0.1. While there isnt any RCE at play here, this does allow Server-Side Request Forgery, or arbitrary file reads.\nCryptojacking is the technique where a malicious website embeds a crypto miner in the site. And while it was particularly popular in 2017-2019, browser safeguards against blatant cryptojacking put an end to the practice. What c/side researchers discovered is that cryptojacking is still happening, just very quietly.\nTheres browser tidbits to cover in both major browsers. In Chrome its a sandbox escape paired with a Windows NT read function with a race condition, that makes it work as a write primitive. To actually make use of it, [Vincent Yeo] needed a Chrome sandbox escape.\nZDI has the story of Firefox and a JavaScript Math confusion attack. By manipulating the indexes of arrays and abusing the behavior when integer values wrap-around their max value, malicious code could read and write to memory outside of the allocated array. This was used at Pwn2Own Berlin earlier in the year, and Firefox patched the bug on the very next day. Enjoy!", "title": "\u300c\u30a2\u30e1\u30ea\u30ab\u306e\u9244\u9053\u30b7\u30b9\u30c6\u30e0\u306b\u6f5c\u3080\u8106\u5f31\u6027\u3068\u305d\u306e\u5f71\u97ff\u300d", "body": "\u7c73\u56fd\u306e\u5217\u8eca\u304c\u30cf\u30c3\u30ad\u30f3\u30b0\u3055\u308c\u3001\u30d6\u30ec\u30fc\u30ad\u3092\u64cd\u4f5c\u53ef\u80fd\u306a\u8106\u5f31\u6027\u3092\u5831\u544a\u3002", "titles": ["\u300c\u30a2\u30e1\u30ea\u30ab\u306e\u9244\u9053\u30b7\u30b9\u30c6\u30e0\u306b\u6f5c\u3080\u8106\u5f31\u6027\u3068\u305d\u306e\u5f71\u97ff\u300d", "\u300cLaravel\u306eAPP_KEY\u6f0f\u6d29\u3001\u30ea\u30e2\u30fc\u30c8\u30b3\u30fc\u30c9\u5b9f\u884c\u306e\u30ea\u30b9\u30af\u300d", "\u300c\u507d\u306eHomebrew\u30a4\u30f3\u30b9\u30c8\u30fc\u30e9\u30fc\u304c\u5f15\u304d\u8d77\u3053\u3059\u30de\u30eb\u30a6\u30a7\u30a2\u306e\u8105\u5a01\u300d", "\u300cFortinet\u88fd\u54c1\u306eSQL\u30a4\u30f3\u30b8\u30a7\u30af\u30b7\u30e7\u30f3\u554f\u984c\u3068\u305d\u306e\u6df1\u523b\u3055\u300d", "\u300cAI\u3092\u5229\u7528\u3057\u305f\u30b5\u30a4\u30d0\u30fc\u653b\u6483\u306e\u53ef\u80fd\u6027\u3068\u65b0\u3057\u3044\u7814\u7a76\u300d"]}