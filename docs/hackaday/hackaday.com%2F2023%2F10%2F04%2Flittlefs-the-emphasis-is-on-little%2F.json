{"pubDate": "2023-10-04T17:00:31", "original_title": "LittleFS: the Emphasis is on Little", "link": "https://hackaday.com/2023/10/04/littlefs-the-emphasis-is-on-little/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/10/installing-cosmac-elf-os-on-the-1802black-idft5l0-ols-mkv-shot0005.jpg", "original_content": "It used to be that developing for microcontrollers was relatively relaxing. These days, even a cheap micro like the Raspberry Pi Pico has multiple cores, networking (for the W, at least), and file systems. Just like desktop computers. Sort of. I found out about the sort of part a few weeks ago when I decided to embark on a little historical project. I wanted a file system with a large file that emulates a disk drive. The Pico supports LittleFS, and I figured that would be the easy thing to do. Turns out the Little in LittleFS might be more literal than you think. On the plus side, I did manage to get things working, but it took a well  dare I say hack?  to make it all work.\nHistory\nIm an unabashed fan of the RCA 1802 CPU, which is, of course, distinctly retro. The problem is, I keep losing my old computers to moves, natural disasters, and whatnot. Ive had several machines over the years, but they seem to be a favorite target of Murphys law for me. I do currently have a small piece of hardware called an Elf Membership Card (by [Lee Hart]), but it lacks fancy features like disk drives, and while it could be expanded, theres something charming about its current small size. So that led me to repurpose a 6502 emulator for the KIM-1 to act like an 1802 instead. This is even less capable than the membership card, so it was sort of a toy. But I always thought I should upgrade the Arduino inside the emulator to a processor with more memory, and thats what I did.\nI started out with a Blackpill STM32F board and called the project 1802Black. The code is a little messy since it started out as [Oscars] KimUNO code, and then my updates layered with new updates. Also, for now, I shut off the hardware parts so it wont use the KimUNO hardware  you only need a Blackpill (or a Pico, see below) and nothing else, although I may reenable the hardware integration later.\nIt wasnt that hard to get it running with just more memory. Still, I wanted to run [Mike Rileys] Elf/OS operating system and I also had a pair of Raspberry Pi Picos mocking me for not using them in a project yet. The chip has excellent Arduino board support. But what sealed the deal was noticing that you can partition the Picos flash drive to use some of it for your program and the rest for a file system. You can get other RP2040 dev boards with 16 MB of flash, which would let me have a nearly 15 MB hard drive, which would have been huge in the 1802s day. Sounds simple. If it were, though, we wouldnt be talking.\n\nEmulated BIOS\nELF/OS and programs that run under it expect a certain BIOS, and the 1802 emulation already hooked many of these calls since other programs are written to use the BIOS, too. A BIOS call that might, say, output a character gets intercepted, and the Arduino code just does the work.\nHowever, with the new filesystem in place, I needed to intercept and flesh out the basic file system API. Theres nothing exotic here. Given a disk block address, you just need to read or write a 512-byte sector. I planned to create a file the size of the virtual disk drive. Then, each read or write would just seek to the correct position and do the read or write.\nAs you might expect, that works. But theres a problem. It works slowly. I know you might think, What did you expect? This is a little computer that costs less than $10. But I mean, like, super slowly. Disk formatting was painful. Even just writing a few sectors would take minutes.\nInvestigation\nI was sure something was wrong, so I did what anyone does today when faced with a technical challenge. I searched the Web. Turns out, I wasnt the only person to notice the slow performance of LittleFS. But it wasnt everyone. LittleFS is fine for several things: reading files and writing to the end of files. Apparently, writing to the middle of files is slow. Very slow. I didnt look at the code, but it appears that if you write to the middle of a file, the file system has to rewrite everything from the point you write to the end of the file. If the file is small, thats not a huge problem. But with a 10 MB file, it takes forever.\nI sort of get it if you were inserting things into a file, but in my case, it was just writing data over in place. It seems like you should be able to isolate the flash block that changes and only reflash it. So my choices were: 1) Fork LittleFS and try to fix whatever makes it perform poorly; 2) Use something else; 3) Work around the problem.\nForking LittleFS would be a big project, and then it is hard to benefit from upgrades. I didnt really see anything attractive for option 2. So that left me with option 3.\nThe Final Option\nI thought about caching more disk sectors, but since the problem was on writing, that would lead to data loss eventually. If we cant stop LittleFS from rewriting files, it seemed the answer was to make that take less time. That means smaller files, and, in fact, that solution worked well.\nEach disk call has an entry for a head, cylinder, and sector. However, the software treats it as a linear block address, so really, it is just a 24-bit number made of the cylinder and sector. My first attempt was to store each cylinder in a file and remember which file was open. When a new cylinder access occurs, the code opens a file like IDENN.DSK, where NN is the cylinder number. 256 cylinders (about 32 MB) seemed like plenty, although it would be easy to handle more if you have enough flash. Then, the code uses the sector number to seek to a particular spot in that file. If the file is already open, you just do the seek.\nThis immediately worked better, but still felt a little slow. A little trial and error showed that it was better to break the tracks into quarters (128 sectors each). The files now have a letter suffix like ide00A.dsk, followed by ide00B.dsk, and so on. After ide00D.dsk, the numbering scheme moves to ide01A.dsk.The read and write calls use the same logic, so I wrapped it up in ideseek:\n\nint ideseek(uint8_t h, uint16_t c, uint8_t s)\n{\n  unsigned newpos;\n  if (!dis_diskled) digitalWrite(DISKACT, 1);  // light stays on if error!\n\n  if (h  != 0 )\n    {\n      Serial.println(Bad head);\n      return -1;\n    }\n\n   if (c  MAXCYL)   // too big?\n        return -1;\n\n      newpos = (s0x3F) * sizeof(sector);  // computer position\n      if (c != currentcy || ((s0xC0)!=(currsector0xC0)))  // see if we already have the file open\n      {\n        int subtrack = (s  0xC0)  6;   // no, so build the name\n        char subname[] = ABCD;\n        sprintf(fname, /ide%02x%c.dsk, c,subname[subtrack]);\n        if (currentcy != 0xFFFF)          // if a file is already open, then close it\n        {\n          fide.close();\n        }\n        fide = LittleFS.open(fname, r+);    // open for read/write (assumes file exists)\n        if (!fide)\n        {\n          fide = LittleFS.open(fname, w+);  // oops, create file\n        }\n        if (!fide)                           // couldn't open or create file!\n        {\n          return -1;\n        }\n        currentcy = c;\n        currsector = s;\n        if (!fide.seek(newpos, SeekSet))       // go to the right place\n          return -1;\n        cpos = newpos + sizeof(sector); // for next time \n  }\n  else  // file already open\n  {\n    if (cpos!=newpos)                   // see if we are already there\n      if (!fide.seek(newpos, SeekSet))  // no so do a seek\n        return -1;\n    cpos = newpos + sizeof(sector);      // this is where head will be next time\n    currsector = s;                      // remember where we are\n  }\n  if (!dis_diskled) digitalWrite(DISKACT, 0);  // DISK led off\n  return 0; \n}\n\nNow, when LittleFS needs to write an entire file, it wont be larger than 32 KB, which seems to work well enough. Seeking seems to be expensive, so the code knows that each BIOS call only reads or writes a single sector and adjusts its idea of the current position accordingly. If you ever called ideseek for another reason, this would be dangerous since each call primes the next call to think the current position is a sector beyond the last one.\nIn Practice\nIf you want to see the OS running on this file system, I have a few quick and dirty demo videos below. Or grab a Raspberry Pi Pico and learn something about the 1802. By the way, my intent here is not to knock LittleFS. It does great for storing small configuration files and logging data that tends to stream to the end. Those are the overwhelming use cases. I could have bit the bullet and used the flash interface directly, which would have probably been a lot smarter and faster. If you wonder why anyone wants to run a disk operating system on old hardware  real or emulated  well refer you to our thoughts on retrocomputing.\n\n", "title": "\u30e9\u30ba\u30d9\u30ea\u30fc\u30d1\u30a4Pico\u3092\u4f7f\u7528\u3057\u3066\u4eee\u60f3\u30c7\u30a3\u30b9\u30af\u30c9\u30e9\u30a4\u30d6\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5", "body": "\u300cRaspberry Pi Pico\u300d\u306e\u30d5\u30a1\u30a4\u30eb\u30b7\u30b9\u30c6\u30e0\u300cLittleFS\u300d\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u304c\u9045\u3044\u305f\u3081\u3001\u81ea\u4f5c\u30d5\u30a1\u30a4\u30eb\u30b7\u30b9\u30c6\u30e0\u3092\u4f5c\u6210\u300232KB\u307e\u3067\u3057\u304b\u66f8\u304d\u8fbc\u3081\u306a\u3044\u304c\u3001\u5341\u5206\u306b\u52d5\u4f5c\u3059\u308b\u3002", "titles": ["\u30e9\u30ba\u30d9\u30ea\u30fc\u30d1\u30a4Pico\u3092\u4f7f\u7528\u3057\u3066\u4eee\u60f3\u30c7\u30a3\u30b9\u30af\u30c9\u30e9\u30a4\u30d6\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5", "1802\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3092\u4f7f\u7528\u3057\u3066\u53e4\u3044\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3092\u30a2\u30c3\u30d7\u30b0\u30ec\u30fc\u30c9\u3059\u308b\u65b9\u6cd5", "\u5c0f\u3055\u306a\u30d5\u30a1\u30a4\u30eb\u30b7\u30b9\u30c6\u30e0\u3092\u4f7f\u7528\u3057\u3066\u30c7\u30fc\u30bf\u306e\u66f8\u304d\u8fbc\u307f\u3092\u9ad8\u901f\u5316\u3059\u308b\u65b9\u6cd5", "LittleFS\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u6539\u5584\u3059\u308btips", "\u65b0\u3057\u3044\u30d5\u30a1\u30a4\u30eb\u30b7\u30b9\u30c6\u30e0API\u306e\u30a4\u30f3\u30bf\u30fc\u30bb\u30d7\u30c8\u3068\u62e1\u5f35\u65b9\u6cd5"]}