{"pubDate": "2023-12-10T06:00:51", "original_title": "Clockhands For Faster CPU Execution", "link": "https://hackaday.com/2023/12/09/clockhands-for-faster-cpu-execution/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/12/hands.png", "original_content": "When you design your first homebrew CPU, you probably are happy if it works and you dont worry as much about performance. But, eventually, youll start trying to think about how to make things run faster. For a single CPU, the standard strategy is to execute multiple instructions at the same time. This is feasible because you can do different parts of the instructions at the same time. But like most solutions, this one comes with a new set of problems. Japanese researchers are proposing a novel way to work around some of those problems in a recent paper about a technique they call Clockhands.\nSuppose you have a set of instructions like this:\nLOAD A, 10\nLOAD B, 20\nSUB A,B\nLOAD B, 30\nJMPZ\u00a0 DONE\nINC B\nIf you do these one at a time, you have no problem. But if you try to execute them all together, there are a variety of problems. First, the subtract has to wait for A and B to have the proper values in them. Also, the INC B may or may not execute, and unless we know the values of A and B ahead of time (which, of course, we do here), we cant tell until run time. But the biggest problem is the subtract has to use B before B contains 30, and the increment has to use it afterward. If everything is running together, it can be hard to keep straight.\n\nThe normal way to do this is register renaming. Instead of using A and B as registers, the CPU uses physical registers that it can call A or B (or something else) as it sees fit. So, for example, the subtraction wont really be SUB A,B but  internally  something like SUB R004,R009. The LOAD instruction for 30 writes to B, but it doesnt really. It actually assigns a currently unused register to B and loads 30 into that (e.g., LOAD R001,30). Now the SUB instruction will still use 20 (in R009) when it gets around to executing.\nThis is a bit of an oversimplification, but the point is theres plenty of circuitry in a modern CPU thinking about which registers are in use and which one corresponds to a logical register for this particular instruction. One proposed way to do this is to stop referring to registers directly and, instead, refer to them by how far away they are in the code (e.g., SUB A-2, B-1). This can be easier for the hardware, but more difficult for the compiler.\nWhere Clockhands is different is it refers to the number of writes to the register, not the number of instructions. It is somewhat like using a stack for each register and allowing the instructions to refer to a specific value on the stack. The hardware becomes easier, there is less for the compiler to do. This could potentially reduce power consumption as well.\nConfused? Read the paper if you want to know more. Some background from Wikipedia might help, too. It reminded us of a CPU architecture from way back called The Mill (dead link inside, but theres always a copy). If you didnt know your CPU registers arent what you think they are, it is even worse than you think."}