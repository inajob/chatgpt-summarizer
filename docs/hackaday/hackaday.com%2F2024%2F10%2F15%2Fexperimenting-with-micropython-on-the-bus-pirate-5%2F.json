{"pubDate": "2024-10-15T17:00:39", "original_title": "Experimenting with MicroPython on the Bus Pirate 5", "link": "https://hackaday.com/2024/10/15/experimenting-with-micropython-on-the-bus-pirate-5/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/09/bp5-feature.png", "youtube": "https://www.youtube.com/watch?v=iEQQWpjgFd8", "original_content": "I recently got one of the new RP2040-based Bus Pirate 5 (BP5), a multi-purpose interface debugging and testing tool. Scanning the various such tools in my toolbox already: an Analog Discovery 2, a new Glasgow Interface Explorer, and a couple of pyboards, I realized they all had a Python or Micropython user interface. A few people on the BP5 forums had tossed around the idea of MicroPython, and it just so happened that I was experimenting with building beta versions of MicroPython for a RP2350 board at the time. Naturally, I started wondering, just how hard can it be to get MicroPython running on the BP5?\nThe Lazy Approach\nRather than duplicating the BP5 firmware functionality, I decided to ignore it completely and go with existing MicroPython capabilities. I planned to just make a simple set of board definition files  perhaps Board Support Package (BSP) is a better term? Ive done this a dozen times before for development and custom boards. Then write a collection of MicroPython modules to conform to the unique aspects in the BP5 hardware. As user [torwag] over on the BusPirate forums said back in March:\nMicropython comes already with some modules and enough functions to get some stuff out-of-the-box working. E.g. the infamous version of \u201chello world\u201d for microcontrollers aka led-blinking.\n\nThe Tailoring\nThe main interfaces to the BP5s RP2040 MCU were apparently done with the Pico reference design in mind. That is why \u00a0you can just load and run the latest RP2 MicroPython build without defining a custom board ( note that this only worked with the current v1.24, and failed when I tried to load v1.23 using Thonny, \u00a0something I did not investigate further ). But there are some things that can be done to tweak the build, so I did go ahead and make set of custom board definition files for the BP5.\nFirst I tried to tell MicroPython about the larger QSPI flash. This is a standard thing in configuring MicroPython, but I found an issue with the RP2. The Pico C SDK has a 2 GiB hard-coded flash limit in a linker script. One can fix this by hand editing and rebuilding the SDK, something I decided to leave for later. So I did all my testing using just 2 GiB of the flash.\nSeveral of the constomizations that I would normally make, like the serial interface pins assignments, were not necessary. The customization I did make was for help files. Since the intended application of this project is a manual debugging, I wanted the modules and funtions to have help text. By default, MicroPython builds on the RP2 do not enable __doc__ strings, but they can be reenabled with a compiler directive. Unfortunately, while the __doc__ strings are now retained, the build-in help() function doesnt print them like CPython. The workaround is to add a help() funtion to each class. So instead of help(adc) yout type add.help().\nFinally, I wanted to add a board top-level help screen, appending to the existing RP2 port help screen. That turned out to be much harder to do, and in the end, I just gave up doing that in the BP5 board definition folder. Instead, I kludged a couple of files in the RP2 port directory  ugly, but this is just an experiment after all.\nThe Interfaces\nThese are the basic interfaces of the BP5 hardware, and all of them are arleady or easily supported in MicroPython.\n\nEight Buffered IO pins\nProgrammable Power Supply\nNAND flash 1Gbit\nIPS LCD screen, 320 x 240 pixels\n18 RGB LEDs\nPush button\n\nGoing for some instant gratification, I decided to drive the chain of LEDs around the perimeter of the unit first. The RP2 port of MicroPython already has a Neopixel class. Once I sorted out the chained shift register I/O expansion circuitry, I was running MicroPython and blinking LEDs in no time. The eight main buffered I/O signals posed a bit more challenge, because there are bidirectional logic level translators on each pin. After writing a BP5 I/O pin wrapper class around the regular MP Pin class to handle that aspect of the hardware, I realized that wasnt quite enough.\nBut the digital I/O signals on the BP5 arent useful until you also control the adjustable voltage reference rail. That led to the Power supply class next, which in turn led to the Analog to Digital class to handle ADC operations. To do this, you need to control the analog MUX. And you need to drive the 74HC595 output expander shift register to select the desired analog MUX channel. No more instant gratification.\nThe shift register was pretty easy, as I have done this before. The only thing I noted was that there is no feedback, so you cant read the current state. This requires instead that you keep a shadow register of the current output expander state.\n[Ian], the father of the BP5 and indeed all Bus Pirates to date, did a great job in the documentation of explaining all these hardware sections of the design. \u00a0The resulting power supply circuit is quite flexible. In brief, voltage and current control are done using PWM outputs, and actual voltage and current are sensed using the RP2040s internal ADCs via the MUX. In addition, a programmable current limit threshold triggers a power supply shutdown, which can be overridden or reset as desired.\nThe Display\nThe BP5 uses a two inch IPS TFT LCD having 240320 pixel resolution. It is controlled using a Sitronix ST7789 over SPI. Having driven similar setups before from MicroPython, this was pretty easy. At first. I used the ST7789 library by Russ Hughes. The display was up and displaying text and running a few demo examples in short order.\nThe NAND Flash\nTurning attention to the Micron MT29F1G01A 1 Gib ( 128 MiB ) NAND flash next, I ran into some difficulty. [Peter Hinch]s memory chip driver library seemed like a good start. But this chip isnt on the list of already tested chips. I changed the scan function to recognized the Micron ID manufacturers byte codes, but after configuring the correct chip size, sector size, and block size parameters, it still didnt work. After finally asking for help, [Mr Hinch] explained that my problem was the large 138 KiB block size of this chip. His library buffers one entire block, and 138 KiB is just too big for most microprocessors.\nHe pointed me to a non-buffered SPI block device driver by [Robert Hammelrath]. I tried this briefly, but gave up after a few hours because I was spending too much time on this chip. This is a solvable problem, but not strictly needed for this goals of this experimental project.\nThe Images\nSpeaking of wasting time, I spent way too much time on this part of the project. Not because it was necessary, but just because it was just cool. My idea was a pong-like demo where an icon moves around the screen, rebounding off the screen edges. These LCD screen driver chips use a packed pixel format, RGB565. I found a tool on GitHub called rgb565-converter which converts PNG images to and from RGB565 format in C++ format. I forked and heavily modified this to generate Python code as well, in addition to 4-bit grayscale format as well. The animated GIF shows this in action.\nThe Wrapup\nI emjoyed making this project, and learned a few more things about MicroPython along the way. I knew that the STM32 and the ESP8266 / ESP32 families had been long supported by MicroPython almost since the beginning, and that the Pico RP2040 was a relative newcomer to the ecosystem. But I was surprised when I stumbled on this talk by founder [Damien George] about the history of the project at the 2023 PyCon Australia conference. He shows some statistics collected over 8 years of downloads broken down by microprocessor family. The RP2040 has been extremely popular since its introduction, quickly surpassing all other families.\nMicroPython Monthly Downloads by MCU Family, provided by [Damien George]This project presented a few frustrating issues, none of which would be showstoppers if this approach were to be developed further. I continue to be impressed by the number of people in the MicroPython community who have developed a wide variety of support libraries and continue to work on the project to this day.\nWhich begs the question, does the idea of MicroPython on the BusPirate even make sense? The existing C-based BusPirate firmware is now well established and works well for its intended purpose  quick explorations of an interface from the command line. Would a alternate MicroPython build benefit the community or just waste peoples limited development hours?\nThere could be some way to create an MicroPython implementation without duplicating a lot of code. The existing BP5 firmware could be treated as a library, and compiled with various C to MicroPython shim functions to create an extensively customized build. That is beyond my MicroPython experience for now, but it might be worth consideration.\nAnother way would be just build a set of big Python classes to represent the BP5 on the desktop. This module would talk to the BP5 using the existing serial / USB port protocol, potentially requiring no firmware modifications at all. This seems like a good idea in general, since it allows users to easily script operations from the desktop using Python, and still retain the original capabilities of the BP5 in standalone operation.\nThe code for this project and associated documentation can be found here on GitHub. You can build your own binary if you want, but one is provided in the repo. And as [torwag] said back in March, you can just run the factory RP2040 MicroPython as well. In my testing, the only thing youll miss are the help messages.\nIf you want to learn more about MicroPython, visit their website and GitHub repository. Prebuilt binaries are available for many standard development boards, and instructions on building it for a custom boards are quite clear and easy to follow. Ive heard rumors that docker containers may be available soon, to make the building process even easier. Visit the Bus Pirate website and corresponding GitHub repository \u00a0 to learn more about the latest Bus Pirate 5 project. We have covered both projects over the years on Hackaday. Most recently [Tom Nardi] did an extensive hands-on writeup \u00a0 \u00a0on the release of the Bus Pirate 5 back in February. Also [Arya Voronova] has written several articles on MicroPython, including this one on the eleventh anniversary of the MicroPython project. Do you use MicroPython in your projects, and whats your take on the idea of using it with the Bus Pirate 5 board?"}