{"pubDate": "2025-04-13T08:00:29", "original_title": "Learning Linux Kernel Modules Using COM Binary Support", "link": "https://hackaday.com/2025/04/13/learning-linux-kernel-modules-using-com-binary-support/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/04/cartoon2.jpg", "original_content": "Have you ever felt the urge to make your own private binary format for use in Linux? Perhaps you have looked at creating the smallest possible binary when compiling a project, and felt disgusted with how bloated the ELF format is? If you are like [Brian Raiter], then this has led you down many rabbit holes, with the conclusion being that flat binary formats are the way to go if you want sleek, streamlined binaries. These are formats like COM, which many know from MS-DOS, but which was already around in the CP/M days. Here flat means that the entire binary is loaded into RAM without any fuss or foreplay.\nAlthough Linux does not (yet) support this binary format, the good news is that you can learn how to write kernel modules by implementing COM support for the Linux kernel. In the article [Brian] takes us down this COM rabbit hole, which involves setting up a kernel module development environment and exploring how to implement a binary file format. This leads us past familiar paths for those who have looked at e.g. how the Linux kernel handles the shebang (#!) and misc formats.\nOn Windows, the kernel identifies the COM file by its extension, after which it gives it 640 kB  an interrupt table to play with. The kernel module does pretty much the same, which still involves a lot of code.\nOf course, this particular rabbit hole wasnt deep enough yet, so the COM format was extended into the .\u265a (Unicode U+265A) format, because this is 2025 and we have to use all those Unicode glyphs for something. This format extension allows for amazing things like automatically exiting after finishing execution (like crashing).\nAt the end of all these efforts we have not only learned how to write kernel modules and add new binary file formats to Linux, we have also learned to embrace the freedom of accepting the richness of the Unicode glyph space, rather than remain confined by ASCII. All of which is perfectly fine.\nTop image: Illustration of [Brian Raiter] surveying the fruits of his labor by [Bomberanian]", "title": "Linux\u3067\u306e\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u30d0\u30a4\u30ca\u30ea\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306e\u4f5c\u6210\u65b9\u6cd5", "body": "Linux\u7528\u306e\u72ec\u81ea\u30d0\u30a4\u30ca\u30ea\u5f62\u5f0fCOM\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5\u306b\u3064\u3044\u3066\u89e3\u8aac\u3002", "titles": ["Linux\u3067\u306e\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u30d0\u30a4\u30ca\u30ea\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306e\u4f5c\u6210\u65b9\u6cd5", "\u30b3\u30f3\u30d7\u3068\u30e6\u30cb\u30b3\u30fc\u30c9\uff1a\u65b0\u3057\u3044\u30d0\u30a4\u30ca\u30ea\u5f62\u5f0f\u306e\u63a2\u6c42", "Linux\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3088\u308bCOM\u30b5\u30dd\u30fc\u30c8\u306e\u5b9f\u88c5", "\u30d0\u30a4\u30ca\u30ea\u30d5\u30a1\u30a4\u30eb\u5f62\u5f0f\u306e\u9032\u5316\u3068\u305d\u306e\u81ea\u7531", "ASCII\u3092\u8d85\u3048\u305f\u30e6\u30cb\u30b3\u30fc\u30c9\u306e\u8c4a\u304b\u3055\u3092\u6d3b\u304b\u3059\u96fb\u5b50\u5de5\u4f5c"]}