{"pubDate": "2025-05-24T14:00:43", "original_title": "The Need For Speed?", "link": "https://hackaday.com/2025/05/24/the-need-for-speed/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2021/07/ElectricSpeed.jpg", "original_content": "We wrote up a video about speeding up Arduino code, specifically by avoiding DigitalWrite. Now, the fact that DigitalWrite is slow as dirt is long known. Indeed, a quick search pulls up a Hackaday article from 2010 demonstrating that it\u2019s fifty times slower than toggling the pin directly using the native pin registers, but this is still one of those facts that gets periodically rediscovered from generation to generation. How can this be new again?\nFirst off, sometimes you just don\u2019t need the speed. When you\u2019re just blinking LEDs on a human timescale, the general-purpose Arduino functions are good enough. I\u2019ve written loads of useful firmware that fits this description. When the timing requirements aren\u2019t tight, slow as dirt can be fast enough.\nBut eventually you\u2019ll want to build a project where the old slow-speed pin toggling just won\u2019t cut it. Maybe it\u2019s a large LED matrix, or maybe it\u2019s a motor-control application where the loop time really matters. Or maybe it\u2019s driving something like audio or video that just needs more bits per second. One way out is clever coding, maybe falling back to assembly language primitives, but I would claim that the right way is almost always to use the hardware peripherals that the chipmakers gave you.\nFor instance, in the end of the video linked above, the hacker wants to drive a large shift register string that\u2019s lighting up an LED matrix. That\u2019s exactly what SPI is for, and coming to this realization makes the project work with timing to spare, and in just a few lines of code. That is the way.\nWhich brings me to the double-edged sword that the Arduino\u2019s abstraction creates. By abstracting away the chips\u2019 hardware peripherals, it makes code more portable and certainly more accessible to beginners, who don\u2019t want to learn about SPI and I2C and I2S and DMA just yet. But by hiding the inner workings of the chips in \u201cuser friendly\u201d libraries, it blinds new users to the useful applications of these same hardware peripherals that clever chip-design engineers have poured their sweat and brains into making do just exactly what we need.\nThis isn\u2019t really meant to be a rant against Arduino, though. Everyone has to start somewhere, and the abstractions are great for getting your feet wet. And because everything\u2019s open source anyway, nothing stops you from digging deeper into the datasheet. You just have to know that you need to. And that\u2019s why we write up videos like this every five years or so, to show the next crop of new hackers that there\u2019s a lot to gain underneath the abstractions.\n\nThis article is part of the Hackaday.com newsletter, delivered every seven days for each of the last 200+ weeks. It also includes our favorite articles from the last seven days that you can see on the web version of the newsletter.\n\nWant this type of article to hit your inbox every Friday morning? You should sign up!\n\n"}