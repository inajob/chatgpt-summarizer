{"pubDate": "2025-01-08T03:00:23", "original_title": "Regular (Expression) Chess", "link": "https://hackaday.com/2025/01/07/regular-expression-chess/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/01/chess.png", "original_content": "[Nicholas Carlini] found some extra time on his hands over the holiday, so he decide to do something with entirely no purpose. The result: 84,688 regular expressions that can play chess using a 2-ply minmax strategy. No kidding. We think we can do some heavy-duty regular expressions, but this is a whole other level.\nAs you might expect, the code to play is extremely simple as it just runs the board through series of regular expressions that implement the game logic. Of course, that doesnt count the thousands of strings containing the regular expressions.\n\nHow does this work? Luckily, [Nicholas] explains it in some detail. The trick isnt making a chess engine. Instead, he creates a branch-free, conditional-execution, single-instruction multiple-data CPU. Once you have a CPU, of course it is easy to play chess. Well, relatively easy, anyway.\nThe computers stack and registers are all in a long string, perfect for evaluation by a regular expression. From there, the rest is pretty easy. Sure, you cant have loops and conditionals cant branch. You can, however, fork a thread into two parts. Pretty amazing.\nProgramming the machine must be pretty hard, right? Well, no. Theres also a sort-of language that looks a lot like Python that can compile code for the CPU. For example:\ndef fib():\n\u00a0\u00a0\u00a0 a = 1\n\u00a0\u00a0\u00a0 b = 2\n\u00a0\u00a0 for _ in range(10):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 next = a + b\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 a = b\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 b = next\nThen you only have to write the chess engine. It isnt fast, but that really isnt the point.\nOf course, chess doesnt have to be that hard. The assembler reminds us a bit of our universal cross assembler."}