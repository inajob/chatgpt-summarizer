{"pubDate": "2025-05-06T08:00:53", "original_title": "Hardware Built For Executing Python (Not Pythons)", "link": "https://hackaday.com/2025/05/06/hardware-built-for-executing-python-not-pythons/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/04/Screenshot-2025-05-01-114025-e1746063734236.png", "original_content": "Lots of microcontrollers will accept Python these days, with CircuitPython and MicroPython becoming ever more popular in recent years. However, theres now a new player in town. Enter PyXL, a project to run Python directly in hardware for maximum speed.\nWhats the deal with PyXL? Its actual Python executed in silicon, notes the project site. A custom toolchain compiles a .py file into CPython ByteCode, translates it to a custom assembly, and produces a binary that runs on a pipelined processor built from scratch. Currently, there isnt a hard silicon version of PyXL  no surprise given what it costs to make a chip from scratch. For now, it exists as logic running on a Zynq-7000 FPGA on a Arty-Z7-20 devboard. Theres an ARM CPU helping out with setup and memory tasks for now, but the Python code is executed entirely in dedicated hardware.\nThe headline feature of PyXL is speed. A comparison video demonstrates this with a measurement of GPIO latency. In this test, the PyXL runs at 100 MHz, achieving a round-trip latency of 480 nanoseconds. This is compared to MicroPython running on a PyBoard at 168 MHz, which achieves a much slower 15,000 nanoseconds by comparison. The project site claims PyXL can be 30x faster than MicroPython based on this result, or 50x faster when normalized for the clock speed differences.\nPython has never been the most real-time of languages, but efforts like this attempt to push it this way. The aim is that it may finally be possible to write performance-critical code in Python from the outset. Weve taken a look at Python in the embedded world before, too, albeit in very different contexts.\n\n", "title": "- \u65b0\u6642\u4ee3\u306e\u30de\u30a4\u30af\u30ed\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc: PyXL\u3067\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u4e0a\u3067\u5b9f\u884c\u3059\u308bPython", "body": "PyXL\u306f\u3001\u5c02\u7528\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3067Python\u3092\u9ad8\u901f\u5b9f\u884c\u3059\u308b\u65b0\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3067\u3059\u3002", "titles": ["- \u65b0\u6642\u4ee3\u306e\u30de\u30a4\u30af\u30ed\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc: PyXL\u3067\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u4e0a\u3067\u5b9f\u884c\u3059\u308bPython", "- PyXL\u306e\u767b\u5834: \u901f\u5ea6\u3092\u8ffd\u6c42\u3057\u305f\u65b0\u3057\u3044Python\u5b9f\u884c\u74b0\u5883", "- CPython\u3092\u76f4\u63a5\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3067\u8d70\u3089\u305b\u308bPyXL\u306e\u4ed5\u7d44\u307f", "- PyXL vs. MicroPython: 30\u500d\u306e\u30b9\u30d4\u30fc\u30c9\u5dee\u3092\u5b9f\u73fe\u3059\u308b\u65b0\u6280\u8853", "- \u57cb\u3081\u8fbc\u307f\u30b7\u30b9\u30c6\u30e0\u306b\u304a\u3051\u308bPython\u306e\u9032\u5316: PyXL\u306e\u53ef\u80fd\u6027\u3068\u306f"]}