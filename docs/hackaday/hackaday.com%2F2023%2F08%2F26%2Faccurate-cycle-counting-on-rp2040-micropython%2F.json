{"pubDate": "2023-08-27T05:00:19", "original_title": "Accurate Cycle Counting on RP2040 MicroPython", "link": "https://hackaday.com/2023/08/26/accurate-cycle-counting-on-rp2040-micropython/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/08/edge_count.png", "original_content": "The RP2040 is a gorgeous little chip with a well-defined datasheet and a fantastic price tag. Two SDKs are even offered: one based on C and the other MicroPython. More experienced MCU wranglers will likely reach for the C variant, but Python does bring a certain speed when banging out a quick project or proof of concept. Perhaps thats why [Jeremy Bentham] ported his RP2040-based vehicle speedometer to MicroPython.\nThe two things that make that difficult are that MicroPython tries to be pretty generic, which means some hackery is needed to talk to the low-level hardware, and that MicroPython doesnt have a reputation for accurate cycle counting. In this case, the low-level hardware is the PWM peripheral. He details the underlying mechanism in more detail in the C version. On the RP2040, the PWM module can count pulse edges on an input. However, you must start and stop it accurately to calculate the amount of time captured. From there, its just edges divided by time. For this, the DMA system is pulled in. A DMA request can be triggered once the PWM counter rolls over. The other PWM channel acts as a timer, and when the timer expires, the DMA request turns off the counter. This works great for fast signals but is inaccurate for slow signals (below 1kHz). So, a reciprocal or time-interval system is included, where the time between edges is captured instead of counting the number of edges in a period,\nWhats interesting here is how the hardware details are wrapped neatly into pico_devices.py. The uctypes module from MicroPython allows access to MMIO devices such as DMA and PWM.\u00a0The code is available on GitHub. Of course, [Jeremy] is no stranger to hacking around on the RP2040, as he has previously rolled his own WiFi driver for the Pico W.", "title": "RP2040\u3092\u4f7f\u7528\u3057\u305f\u30de\u30a4\u30af\u30ed\u30d1\u30a4\u30bd\u30f3\u306b\u3088\u308b\u8eca\u306e\u901f\u5ea6\u8a08\u306e\u4f5c\u6210\u65b9\u6cd5", "body": "RP2040\u306f\u30c7\u30fc\u30bf\u30b7\u30fc\u30c8\u304c\u3057\u3063\u304b\u308a\u3057\u3066\u304a\u308a\u3001\u4fa1\u683c\u3082\u7d20\u6674\u3089\u3057\u3044\u30c1\u30c3\u30d7\u3067\u3059\u3002C\u3068MicroPython\u306e2\u3064\u306eSDK\u304c\u63d0\u4f9b\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u3088\u308a\u7d4c\u9a13\u8c4a\u5bcc\u306a\u958b\u767a\u8005\u306fC\u3092\u9078\u3076\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u3001Python\u306f\u7d20\u65e9\u3044\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3084\u6982\u5ff5\u306e\u8a3c\u660e\u306b\u306f\u4fbf\u5229\u3067\u3059\u3002\u30b8\u30a7\u30ec\u30df\u30fc\u30fb\u30d9\u30f3\u30b5\u30e0\u6c0f\u306fRP2040\u30d9\u30fc\u30b9\u306e\u8eca\u306e\u901f\u5ea6\u8a08\u3092MicroPython\u306b\u79fb\u690d\u3057\u307e\u3057\u305f\u3002", "titles": ["RP2040\u3092\u4f7f\u7528\u3057\u305f\u30de\u30a4\u30af\u30ed\u30d1\u30a4\u30bd\u30f3\u306b\u3088\u308b\u8eca\u306e\u901f\u5ea6\u8a08\u306e\u4f5c\u6210\u65b9\u6cd5", "PWM\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u4f7f\u7528\u3057\u305fRP2040\u306e\u4f4e\u30ec\u30d9\u30eb\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u5236\u5fa1\u65b9\u6cd5", "\u30de\u30a4\u30af\u30ed\u30d1\u30a4\u30bd\u30f3\u3067\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u5236\u5fa1\u3092\u884c\u3046\u305f\u3081\u306epico_devices.py\u306e\u6d3b\u7528\u65b9\u6cd5", "RP2040\u3092\u4f7f\u7528\u3057\u305f\u7269\u7406\u8a08\u6e2c\u306b\u304a\u3051\u308b\u7cbe\u5ea6\u306e\u5411\u4e0a\u65b9\u6cd5", "RP2040\u3067\u306e\u96fb\u5b50\u5de5\u4f5c\u306b\u304a\u3051\u308bDMA\u30b7\u30b9\u30c6\u30e0\u306e\u52b9\u679c\u7684\u306a\u6d3b\u7528\u6cd5"]}