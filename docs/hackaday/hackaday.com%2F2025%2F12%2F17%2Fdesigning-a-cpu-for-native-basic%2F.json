{"pubDate": "2025-12-18T06:00:07", "original_title": "Designing a CPU for Native BASIC", "link": "https://hackaday.com/2025/12/17/designing-a-cpu-for-native-basic/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/12/native_basic_cpu.png", "original_content": "\nOver the years there have been a few CPUs designed to directly run a high-level programming language, the most common approach being to build a physical manifestation of a portable code virtual machine. An example might be the experimental Java processors which implemented the JVM. Similarly, in 1976 Itty Bitty Computers released an implementation of Tiny BASIC which used a simple virtual machine, and to celebrate 50 years of Tiny BASIC, [Zoltan Pekic] designed a CPU that mirrors that VM.\nThe CPU was created within a Digilent Anvyl board, and the VHDL file is freely available. The microcode mapping ROM was generated by a microcode compiler, also written by [Zoltan]. The original design could execute all of the 40 instructions included in the reference implementation of Tiny BASIC; later iterations extended it a bit more. To benchmark its performance, [Zoltan] set the clock rate on the development board equal to those of various other retrocomputers, then compared the times each took to calculate the prime numbers under 1000 using the same Tiny BASIC program. The BASIC CPU outperformed all of them except for Digital Microsystems\u2019 HEX29.\nThe next step was to add a number of performance optimizations, including a GOTO cache and better use of parallel operations. [Zoltan] then wrote a \u201cHello World\u201d demo, which can be seen below, and extended the dialect of Tiny BASIC with FOR loops, INPUT statements, multiple LET statements, the modulo operator, and more. Finally, he also extended the CPU from 16-bit to 32-bit to be able to run an additional benchmark, on which it once again outperformed retrocomputers with comparable clock speeds.\nWe\u2019ve previously seen [Zoltan]\u2019s work with FPGAs, whether it\u2019s giving one a cassette interface or using one to directly access a CPU\u2019s memory bus. BASIC has always been a cross-platform pioneer, once even to the extent of creating a free national standard.\n", "title": "\u300cTiny BASIC\u306e50\u5468\u5e74\u3092\u795d\u3046\u65b0\u3057\u3044CPU\u8a2d\u8a08\u300d", "body": "Tiny BASIC\u306e\u305f\u3081\u306b\u8a2d\u8a08\u3055\u308c\u305fCPU\u304c\u958b\u767a\u3055\u308c\u3001\u6700\u9069\u5316\u3055\u308c\u3066\u6027\u80fd\u304c\u5411\u4e0a\u3002", "titles": ["\u300cTiny BASIC\u306e50\u5468\u5e74\u3092\u795d\u3046\u65b0\u3057\u3044CPU\u8a2d\u8a08\u300d", "\u300cZoltan Pekic\u304c\u4f5c\u308bTiny BASIC\u5bfe\u5fdc\u306eCPU\u300d", "\u300c\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u5411\u4e0a\uff01\u65b0\u3057\u3044Tiny BASIC CPU\u306e\u6700\u9069\u5316\u624b\u6cd5\u300d", "\u300c16\u30d3\u30c3\u30c8\u304b\u308932\u30d3\u30c3\u30c8\u3078\uff1aTiny BASIC CPU\u306e\u9032\u5316\u300d", "\u300c\u30ec\u30c8\u30ed\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3068\u306e\u6027\u80fd\u6bd4\u8f03\uff1aTiny BASIC CPU\u306e\u5b9f\u529b\u300d"]}