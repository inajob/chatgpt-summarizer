{"pubDate": "2024-04-16T14:00:32", "original_title": "Linux Fu: Stupid Systemd Tricks", "link": "https://hackaday.com/2024/04/16/linux-fu-stupid-systemd-tricks/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "Last time, I gave a whirlwind introduction to a very small slice of systemd. If you arent comfortable with systemd services, timers, and mounts, you might want to read that now. Otherwise, press on to see a few interesting uses for custom systemd units, including running a few things on a schedule and automatically mounting a Raspberry Pi Zero.\nCan you do every one of these things in a different way? Of course you can. Im not debating the relative merits of using or not using systemd. However, unless you totally control your own environment, good chance you are going to have to interact with systemd at some point.\nStupid Trick #1: Update Your IP Address\nA few years ago, I talked about updating your remote DNS server with your public IP address. This lets you refer to a hostname like snoopy.hackaday.com and get back to your computer that often changes IP addresses. Sure, you can get services to do that for you, but you must either pay or agree to read ads on their site to keep your hostname going. This is all under your control. In the original post, I suggested using cron or NetworkManager to run the update script. I also hinted you could do it with systemd, but I didnt tell you how. Lets fix that.\n\nStep one is simple: create a one shot service that executes the command required:\n\n[Unit] \nDescription=Update IP via SSH (called by timer) \n\n[Service] \nType=oneshot \nExecStart=/usr/bin/ssh awce ./updateip - wd5gnr.com dyn E\nWorkingDirectory=/home/alw/bin\n\nYou can read about why that works in the original post. This is an easy-to-understand unit. A one-shot service runs once and then it is done The rest is the program to run and the working directory. Piece of cake.\nNext, you need a timer. The timers name is the same as the service except for the extension. That is, updateip.service and updateip.timer go together.\n\n\n[Unit] \nDescription=Timer to update public IP via SSH \n\n[Timer] \nOnCalendar=*-*-* *:01,16,31,46:00 \nPersistent=true \n\n[Install] \nWantedBy=timers.target\n\n\n\nHere, we ask the system to run the code every hour of every day at minutes :01, :16, :31, and :46. It is persistent, so if a timer misses, it will run as soon as possible. In theory, we should make this all dependent on the network being up, but it doesnt hurt to try and fail since if the network is down, this doesnt matter.\nStupid Trick #2: Shut Up Baloo!\nRecent versions of KDE love Baloo, the file indexer. While it is nice to instantly find files in your home directories, and it handles a few other tasks, it also is known to eat up system resources. Ive used cgroups and other tricks to limit Baloos insatiable desire for CPU and I/O time. But what works best is to shut it down in the morning and let it start again late at night.\nThis is not quite the same as updating the IP address. For one thing, it happens at an absolute time. It would be easy, too, to have it do different times on the weekend, for example. The other thing to note is that this timer, as it is now, should probably not be persistent. It might be smarter to make it persistent and have one script that decides what to do based on the time, but I didnt elect to go that way.\nHowever, I did want to stop the timer from running if there was no GUI session. This is, it turns out, tricky. Youd think you could set the timer to be WantedBy the GUI target, but thats not the case. Heres how I turn off Baloo:\n\n\n[Unit]\nDescription=Stop KDEs Baloo File Indexing Service\n# Ensure this only runs in a graphical session by checking for the DISPLAY variable\nConditionEnvironment=DISPLAY\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/systemctl --user stop kde-baloo\n\n\nNote that the service actually calls systemd again to stop the predefined kde-baloo service. The ConditionEnvironment line means it only does this if there is a DISPLAY variable set. Thats not foolproof, but it should work for most caes.\nYou still need a timer:\n\n[Unit]\nDescription=Timer to Stop KDEs Baloo File Indexing Service Daily at 06:45\n\n[Timer]\nOnCalendar=*-*-* 06:45:00\nPersistent=true\nUnit=baloo-off.service\n\n[Install]\nWantedBy=timers.target\n\n\nOf course, the baloo-on pair looks just the same, with obvious changes to the service names and time specifications.\nStupid Trick #3: Automount your Raspberry Pi Pico\nAnother item systemd handles is mounting filesystems. What happened to fstab? Nothing. A special program reads fstab and creates systemd mount units for you automatically. The unit files wind up somewhere like /run/systemd/generator, at least on my system.\nIf you use the Raspberry Pi Pico, youve probably noticed that when it is in boot mode, it presents a different ID to the system each time. That makes it hard to tell the system to mount it automatically. However, it should have a constant label. Making systemd automount your Pi requires two files (in /etc/systemd/system). First, there is the .mount file:\n\n\n[Unit]\nDescription=Mount Raspberry Pi Pico at startup\n\n[Mount]\nWhat=/dev/disk/by-label/RPI-RP2\nWhere=/media/alw/RPI-RP2\nType=vfat\nOptions=defaults\n\n[Install]\nWantedBy=multi-user.target\n\n\nThen there is a .automount file with the same base name:\n\n\n[Unit]\nDescription=Automount Raspberry Pi Pico\n\n[Automount]\nWhere=/media/alw/RPI-RP2\nTimeoutIdleSec=0\n\n[Install]\nWantedBy=multi-user.target\n\nSpeaking of the name, systemd expects a file that mounts at path /x/y/z to be named x-y-z.mount. Thats fine until you want to mount something at path /x/y-z. Thats because the name x-y-z.mount should go to /x/y/z, not /x/y-z. To solve this, the file name needs to have an escaped hyphen in it like this: media-alw-RPI\\x2dRP2.mount. That backslash needs to actually be in the file name, so youll have to quote or escape it in the shell, too.\nNow, when you boot the Pi into bootloader mode, the system will mount it at the designated location.\nThats a Wrap!\nActually, thats not a wrap. This shows nearly the bare minimum of what you can do with systemd. There is a question if it is desirable for one thing to do so much, but Im trying to ignore that elephant. For today, systemd is here, and we might as well use it. If you work with others or deliver software to other users, it is a good bet youll have no choice.", "title": "\u30ab\u30b9\u30bf\u30e0systemd\u30e6\u30cb\u30c3\u30c8\u306e\u9762\u767d\u3044\u6d3b\u7528\u6cd5", "body": "systemd\u306b\u95a2\u3059\u308b\u3055\u307e\u3056\u307e\u306a\u4f7f\u3044\u65b9\u304c\u8a18\u8f09\u3055\u308c\u3066\u3044\u307e\u3059\u3002IP\u30a2\u30c9\u30ec\u30b9\u306e\u66f4\u65b0\u3068CPU\u30ea\u30bd\u30fc\u30b9\u5236\u9650\u3001Raspberry Pi Pico\u306e\u81ea\u52d5\u30de\u30a6\u30f3\u30c8\u306a\u3069\u304c\u7d39\u4ecb\u3055\u308c\u3066\u3044\u307e\u3059\u3002 systemd\u306f\u74b0\u5883\u3092\u5236\u5fa1\u3059\u308b\u969b\u306b\u5fc5\u8981\u3067\u3042\u308a\u3001\u3044\u308d\u3044\u308d\u306a\u81ea\u52d5\u5316\u304c\u53ef\u80fd\u3067\u3059\u3002", "titles": ["\u30ab\u30b9\u30bf\u30e0systemd\u30e6\u30cb\u30c3\u30c8\u306e\u9762\u767d\u3044\u6d3b\u7528\u6cd5", "IP\u30a2\u30c9\u30ec\u30b9\u306e\u66f4\u65b0\u65b9\u6cd5", "Baloo\u30d5\u30a1\u30a4\u30eb\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u30b5\u30fc\u30d3\u30b9\u306e\u6642\u9593\u6307\u5b9a\u505c\u6b62", "Raspberry Pi Pico\u306e\u81ea\u52d5\u30de\u30a6\u30f3\u30c8", "systemd\u306e\u6d3b\u7528\u65b9\u6cd5"]}