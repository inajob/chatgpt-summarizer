{"pubDate": "2025-03-11T14:00:37", "original_title": "TrapC: A C Extension For the Memory Safety Boogeyman", "link": "https://hackaday.com/2025/03/11/trapc-a-c-extension-for-the-memory-safety-boogeyman/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2017/08/memory.jpg", "original_content": "In the world of programming languages it often feels like being stuck in a Groundhog Day-esque loop through purgatory, as effectively the same problems are being solved over and over, with previous solutions forgotten and theres always that one jubilant inventor stumbling out of a darkened basement with the One True Solution to everything that plagues this world beset by the Unspeakable Horror that is the C programming language.\nAs the latest entry to pledge its fealty at the altar of the Church of the Holy Memory Safety, TrapC promises to fix C, while also lambasting Rust for allowing that terrible unsafe keyword. Of course, since this is yet another loop through purgatory, the entire idea that the problem is C and some perceived issue with this nebulous memory safety is still a red herring, as pointed out previously.\nIn other words, its time for a fun trip back to the 1970s when many of the same arguments were being rehashed already, before the early 1980s saw the Steelman language requirements condensed by renowned experts into the Ada programming language. As it turns out, memory safety is a miniscule part of a well-written program.\n\nIts A Trap\nPretty much the entire raison d\u00eatre for new programming languages like TrapC, Rust, Zig, and kin is this fixation on memory safety, with the idea being that the problem with C is that it doesnt check memory boundaries and allows usage of memory addresses in ways that can lead to Bad Things. Which is not to say that such events arent bad, but because they are so obvious, they are also very easy to detect both using static and dynamic analysis tools.\nAs a proposed C-language extension, TrapC would add:\n\nmemory-safe pointers.\nconstructors  destructors.\nthe trap and alias keywords.\nRun-Time Type Information.\n\nIt would also remove:\n\nthe goto and union keywords.\n\nThe author, Robin Rowe, freely admits to this extension being C++ like, which takes us right back to 1979 when a then young Danish computer scientist (Bjarne Stroustrup) created a C-language extension cheekily called C++ to denote it as enhanced C. C++ adds many Simula features, a language which is considered the first Object-Oriented (OO) programming language and is an indirect descendant of ALGOL. These OO features include constructors and destructors. Together with (optional) smart pointers and the bounds-checked strings and containers from the Standard Template Library (STL) C++ is thus memory safe.\nSo what is the point of removing keywords like goto and union? The former is pretty much the most controversial keyword in the history of programming languages, even though it derives essentially directly from jumps in assembly language. In the Ada programming language you also have the goto keyword, with it often used to provide more flexibility where restrictive language choices would lead to e.g. convoluted loop constructs to the point where some C-isms do not exist in Ada, like the continue keyword.\nThe union keyword is similarly removed in TrapC, with the justification that both keywords are unsafe and widely deprecated. Which makes one wonder how much real-life C  C++ code has been analyzed to come to this conclusion. In particular in the field of embedded- and driver programming with low-level memory (and register) access the use of union is widely used for the flexibility it offers.\nOf course, if youre doing low-level memory access youre also free to use whatever pointer offset and type casting you require, together with very unsafe, but efficient, memcpy() and similar operations. There is a reason why C++ doesnt forbid low-level access without guardrails, as sometimes its necessary and youre expected to know what youre doing. This freedom in choosing between strict memory safety and the untamed wilds of C is a deliberate design choice in C++. In embedded programming you tend to compile C++ with both RTTI  exceptions disabled as well due to the overhead from them.\nDont Call It C++\nEffectively, TrapC adds RTTI, exceptions (or traps), OO classes, safe pointers, and similar C++ features to C, which raises the question of why its any different, especially since the whitepaper describes TrapC and C++ code usually looking the same as a feature. Here the language seems to regard itself as being a better C++, mostly in terms of exception handling and templates, using traps and castplates. Curiously theres not much focus on resource allocation is initialization (RAII) that is such a cornerstone of C++.\nMeanwhile castplates are advertised as a way to make C containers typesafe, but unlike C++ templates they are created implicitly using RTTI and one might argue somewhat opaque (C++ template-like) syntax. There are few people who would argue that C++ template code is easy to read. Of note here is that in embedded programming you tend to compile C++ with both RTTI  exceptions disabled due to the overhead from them. The extensive reliance on RTTI in TrapC would seem to preclude such an option.\nCircling back on the other added keyword, alias, this is TrapCs way to providing function overloading, and it works like a C preprocessor #define:\nvoid puts(void* x) alias printf(\"{}n\",x);\nThen there is the new trap keyword thats apparently important enough to be captured in the extensions name. These are offered as an alternative to C++ exceptions, but the description is rather confusing, other than that its supposedly less complicated and does not support cascading exceptions up the stack. Here I do not personally see much value either way, as like so many C++ developers I loathe C++ exceptions with the fire of a thousand Suns and do my utmost to avoid them.\nMy favorite approach here is found in Ada, which not only cleanly separates functions and procedures, but also requires, during compile time, that any return value from a function is handled, and implements exceptions in a way that is both light-weight and very informative, as I found for example while extensively using the Ada array type in the context of a lock-free ring buffer. During testing there were zero crashes, just the program bailing out with an exception due to a faulty offset into the array and listing the exact location and cause, as in Ada everything is bound-checked by default.\nMemory Safety\nMuch of the safety in TrapC would come from managed pointers, with its author describing TrapCs memory management as automatic in a recent presentation at an ISO C meeting. Pointers are lifetime-managed, but as the whitepaper states, the exact method used is implementation defined, instead of reference counting as in the C++ specification.\nYet none of this matters in the context of actual security issues. As I noted in 2024, the red herring part refers to the real-life security issues that are captured in CVEs and their exploitation. Virtually all of the worst CVEs involve a lack of input validation, which allows users to access data in restricted folders and gain access to databases and other resources. None of which involve memory safety in any way or form, and thus the onus lies on preventing logic errors, solid input validation and preventing lazy or inattentive programmers from introducing the next world-famous CVE.\nAs a long-time C  C++ programmer, I have come to love the warts in these languages as well as the lack of guardrails for the freedom they provide. Meanwhile I have learned to write test cases and harnesses to strap my code into for QA sessions, because the best way to validate code is by stressing it. Along the way I have found myself incredibly fond of Ada, as its focus on preventing ambiguity and logic errors is self-evident and regularly keeps me from making inattentive mistakes. Mistakes that in C++ would show up in the next test and/or Valgrind cycle followed by a facepalm moment and recompile, yet somehow programming in Ada doesnt feel more restrictive than writing in C++.\nThus Ill keep postulating that the issues with C were already solved in 1983 with the introduction of Ada, and accepting this fact is the only way out of this endless Groundhog Day purgatory."}