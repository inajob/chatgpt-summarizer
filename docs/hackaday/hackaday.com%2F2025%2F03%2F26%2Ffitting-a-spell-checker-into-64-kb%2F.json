{"pubDate": "2025-03-27T02:00:04", "original_title": "Fitting a Spell Checker into 64 kB", "link": "https://hackaday.com/2025/03/26/fitting-a-spell-checker-into-64-kb/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/03/unix-spell-main.jpg", "original_content": "By some estimates, the English language contains over a million unique words. This is perhaps overly generous, but even conservative estimates generally put the number at over a hundred thousand. Regardless of where the exact number falls between those two extremes, its certainly many more words than could fit in the 64 kB of memory allocated to the spell checking program on some of the first Unix machines. This article by [Abhinav Upadhyay] takes a deep dive on how the early Unix engineers accomplished the feat despite the extreme limitations of the computers they were working with.\nPerhaps the most obvious way to build a spell checker is by simply looking up each word in a dictionary. With modern hardware this wouldnt be too hard, but disks in the 70s were extremely slow and expensive. To move the dictionary into memory it was first whittled down to around 25,000 words by various methods, including using an algorithm to remove all affixes, and then using a Bloom filter to perform the lookups. The team found that this wasnt a big enough dictionary size, and had to change strategies to expand the number of words the spell checker could check. Hash compression was used at first, followed by hash differences and then a special compression method which achieved an almost theoretically perfect compression.\nAlthough most computers that run spell checkers today have much more memory as well as disks which are orders of magnitude larger and faster, a lot of the innovation made by this early Unix team is still relevant for showing how various compression algorithms can be used on data in general. Large language models, for one example, are proving to be the new frontier for text-based data compression.", "title": "- \u521d\u671fUnix\u306b\u304a\u3051\u308b\u30b9\u30da\u30eb\u30c1\u30a7\u30c3\u30ab\u30fc\u306e\u9769\u65b0", "body": "\u521d\u671f\u306eUnix\u306e\u30b9\u30da\u30eb\u30c1\u30a7\u30c3\u30ab\u30fc\u306f\u9650\u3089\u308c\u305f\u30e1\u30e2\u30ea\u3067\u8a00\u8449\u3092\u52b9\u7387\u7684\u306b\u6271\u3063\u305f\u3002", "titles": ["- \u521d\u671fUnix\u306b\u304a\u3051\u308b\u30b9\u30da\u30eb\u30c1\u30a7\u30c3\u30ab\u30fc\u306e\u9769\u65b0", "- \u9650\u754c\u3092\u8d85\u3048\u305f\uff01\u53e4\u3044\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3067\u306e\u8f9e\u66f8\u5727\u7e2e\u6280\u8853", "- \u5236\u7d04\u306e\u4e2d\u3067\u751f\u307e\u308c\u305f\u300125,000\u8a9e\u306e\u8f9e\u66f8\u3068\u306f\uff1f", "- \u30b9\u30da\u30eb\u30c1\u30a7\u30c3\u30ab\u30fc\u306e\u305f\u3081\u306e\u30cf\u30c3\u30b7\u30e5\u5727\u7e2e\u6280\u8853\u306e\u9032\u5316", "- \u73fe\u4ee3\u306e\u30c7\u30fc\u30bf\u5727\u7e2e\u306b\u751f\u304d\u308bUnix\u30a8\u30f3\u30b8\u30cb\u30a2\u306e\u77e5\u6075"]}