{"pubDate": "2023-10-14T14:00:29", "original_title": "Close to the Metal", "link": "https://hackaday.com/2023/10/14/close-to-the-metal/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2019/02/westerndigitalriscv.jpg", "original_content": "Firmware is caught between hardware and software. What do I mean? Microcontroller designers compete on how many interesting and useful hardware peripherals they can add to the chips, and they are all different on purpose. Meanwhile, software designers want to abstract away from the intricacies and idiosyncrasies of the hardware peripherals, because code wants to be generic and portable. Software and hardware designers are Montagues and Capulets, and we\u2019re caught in the crossfire.\nI\u2019m in the middle of a design that takes advantage of perhaps one of the most idiosyncratic microcontroller peripherals out there \u2013 the RP2040\u2019s PIOs. Combining these with the chip\u2019s direct memory access (DMA) controllers allows some fairly high-bandwidth processing, without bogging down the CPUs. But because I want this code to be usable and extensible by a wide audience, I\u2019m also trying to write it in MicroPython. And configuring DMA controllers is just too idiosyncratic for MicroPython.\nBut there\u2019s an escape hatch. In my case, it\u2019s courtesy of the machine.mem32 function, which lets you read and write directly into the chip\u2019s memory, including all of the memory-mapped configuration registers. Sure, it\u2019s absurdly low-level, but it means that anything you read about in the chip\u2019s datasheet, you can do right away, and from within the relative comfort of a Micropython program. Other languages have their PEEK and POKE equivalents as well, or allow inline assembler, or otherwise furnish you the tools to get closer to the metal without having to write all the rest of your code low level.\nI\u2019m honestly usually a straight-C or even Forth programmer, but this experience of using a higher-level language and simultaneously being able to dive down to the lowest levels of bit-twiddling at the same time has been a revelation. If you\u2019re just using Micropython, open up your chip\u2019s datasheet and see what it can offer you. Or if you\u2019re programming at the configure-this-register level, check out the extra benefits you can get from a higher-level language. You can have your cake and eat it too!\n\nThis article is part of the Hackaday.com newsletter, delivered every seven days for each of the last 200+ weeks. It also includes our favorite articles from the last seven days that you can see on the web version of the newsletter.\n\nWant this type of article to hit your inbox every Friday morning? You should sign up!\n\n"}