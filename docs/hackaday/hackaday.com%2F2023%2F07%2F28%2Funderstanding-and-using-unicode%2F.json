{"pubDate": "2023-07-29T02:00:45", "original_title": "Understanding and Using Unicode", "link": "https://hackaday.com/2023/07/28/understanding-and-using-unicode/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/07/uni-feature.png", "original_content": "Computer engineer [Marco Cilloni] realized a lot of developers today still have trouble dealing with Unicode in their programs, especially in the C/C++ world. He wrote an excellent guide that summarizes many of the issues surrounding Unicode and its encoding called Unicode is harder than you think. He first presents a brief history of Unicode and how it came about, so you can understand the reasons for the frustrating edge cases youre bound to encounter.\nThere have been a variety of Unicode encoding methods over the years, but modern programs dealing with strings will probably be using UTF-8 encoding  and you should too. This multibyte encoding scheme has the convenient property of not changing the original character values when dealing with 7-bit ASCII text. We were surprised to read that there is actually an EBCDIC version of UTF still officially on the books today:\nUTF-EBCDIC, a variable-width encoding that uses 1-byte characters designed for IBM\u2019s EBCDIC systems (note: I think it\u2019s safe to argue that using EBCDIC in 2023 edges very close to being a felony)\n[Marco] goes in detail about different problems found when dealing with Unicode strings. When C was being developed, ASCII itself had just been finalized in the form we know today, so it treats characters as single byte numbers. With multi-byte, variable-width character strings, the usual functions like strlen fall apart.\nUnicodes combining characters also causes problems when it comes to comparison and collation of text. These are characters which can be built from multiple glyphs, but they also have a pre-built Unicode point. There are also ligatures that combine multiple characters into a single code point. Suddenly it isnt so clear what character equality even means  Unicode defines two kinds of equivalences, canonical and compatibility.\nThese are but a sampling of the issues [Marco] discusses. The most important takeaway is that Unicode handling is always best left to a library. If your language / compiler of choice doesnt have one, the Unicode organization provides a reference design called the ICU.\nIf this topic interests you, do check out his essay linked above. And if you want to get your hands dirty with Unicode glyphs, check out [Roman Czyborra]s tools here, which are simple command line tools that let you easily experiment using ASCII art. [Roman] founded the open-sourced GNU Unicode Font project back in the 1990s, Unifoundry. Our own [Maya Posch] wrote a great article on the history of Unicode in 2021.", "title": "\"Unicode\u51e6\u7406\u306b\u3064\u3044\u3066\u306e\u77e5\u8b58\u4e0d\u8db3\u3092\u89e3\u6d88\uff01\"", "body": "Unicode\u306b\u95a2\u3059\u308b\u554f\u984c\u3092\u307e\u3068\u3081\u305f\u30ac\u30a4\u30c9\u300cUnicode is harder than you think\u300d\u304c\u3042\u308a\u307e\u3059\u3002UTF-8\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u304c\u4fbf\u5229\u3067\u63a8\u5968\u3055\u308c\u3066\u3044\u307e\u3059\u3002Unicode\u6587\u5b57\u5217\u306e\u6271\u3044\u306f\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u4efb\u305b\u308b\u3079\u304d\u3067\u3059\u3002", "titles": ["\"Unicode\u51e6\u7406\u306b\u3064\u3044\u3066\u306e\u77e5\u8b58\u4e0d\u8db3\u3092\u89e3\u6d88\uff01\"", "\"Unicode\u306e\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u306b\u95a2\u3059\u308b\u554f\u984c\u3092\u7c21\u6f54\u306b\u307e\u3068\u3081\u3066\u89e3\u8aac\"", "\"UTF-8\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u306e\u91cd\u8981\u6027\u3068\u5229\u70b9\u3068\u306f\uff1f\"", "\"Unicode\u6587\u5b57\u5217\u51e6\u7406\u306b\u304a\u3051\u308b\u554f\u984c\u3068\u89e3\u6c7a\u7b56\u306e\u8a73\u7d30\u89e3\u8aac\"", "\"Unicode\u306e\u6271\u3044\u3092\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u4efb\u305b\u307e\u3057\u3087\u3046\uff01\""]}