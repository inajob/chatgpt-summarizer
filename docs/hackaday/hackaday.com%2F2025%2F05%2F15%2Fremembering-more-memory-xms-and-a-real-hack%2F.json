{"pubDate": "2025-05-15T17:00:39", "original_title": "Remembering More Memory: XMS and a Real Hack", "link": "https://hackaday.com/2025/05/15/remembering-more-memory-xms-and-a-real-hack/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/11/ibm-mda-featured.jpg", "original_content": "Last time we talked about how the original PC has a limit of 640 kB for your programs and 1 MB in total. But of course those restrictions chafed. People demanded more memory, and there were workarounds to provide it.\nHowever, the workarounds were made to primarily work with the old 8088 CPU. Expanded memory (EMS) swapped pages of memory into page frames that lived above the 640 kB line (but below 1 MB). The system would work with newer CPUs, but those newer CPUs could already address more memory. That led to new standards, workarounds, and even a classic hack.\nXMS\nIf you had an 80286 or above, you might be better off using extended memory (XMS). This took advantage of the fact that the CPU could address more memory. You didnt need a special board to load 4MB of RAM into an 80286-based PC. You just couldnt get to with MSDOS. In particular, the memory above 1 MB was  in theory  inaccessible to real-mode programs like MSDOS.\nWell, thats not strictly true in two cases. One, youll see in a minute. The other case is because of the overlapping memory segments on an 8088, or in real mode on later processors. Address FFFF:000F was the top of the 1 MB range.\nPCs with more than 20 bits of address space ran into problems since some programs knew that memory access above that would wrap around. That is FFFF:0010, on an 8088, is the same as 0000:0000. They would block A20, the 21st address bit, by default. However, you could turn that block off in software, although exactly how that worked varied by the type of motherboard  yet another complication.\nXMS allowed MSDOS programs to allocate and free blocks of memory that were above the 1 MB line and map them into that special area above FFFF:0010, the so-called high memory area (HMA). \nThe 640 kB user area, 384 kB system area, and almost 64 kB of HMA in a PC (80286 or above)\nBecause of its transient nature, XMS wasnt very useful for code, but it was a way to store data. If you werent using it, you could load some TSRs into the HMA to prevent taking memory from MSDOS.\nProtected Mode Hacks\nThere is another way to access memory above the 1 MB line: protected mode. In protected mode, you still have a segment and an offset, but the segment is just an index into a table that tells you where the segment is and how big it is. The offset is just an offset into the segment. So by setting up the segment table, you can access any memory you like. You can even set up a segment that starts at zero and is as big as all the memory you can have.\nA protected mode segment table entry\nYou can use segments like that in a lot of different ways, but many modern operating systems do set them up very simply. All segments start at address 0 and then go up to the top of user memory. Modern processors, 80386s and up, have a page table mechanism that lets you do many things that segments were meant to do in a more efficient way.\nHowever, MS-DOS cant deal with any of that directly. There were many schemes that would switch to protected mode to deal with upper memory using EMS or XMS and then switch back to real mode.\nUnfortunately, switching back to real mode was expensive because, typically, you had to set a bit in non-volatile memory and reboot the computer! On boot, the BIOS would notice that you werent really rebooting and put you back where you were in real mode. Quite a kludge!\nThere was a better way to run MSDOS in protected mode called Virtual86 mode. However, that was complex to manage and required many instructions to run in an emulated mode, which wasnt great for performance. It did, however, avoid the real mode switch penalty as you tried to access other memory.\nUnreal Mode\nIn true hacker fashion, several of us figured out something that later became known as Unreal Mode. In the CPU documentation, they caution you that before switching to real mode, you need to set all the segment tables to reflect what a segment in real mode looks like. Obviously, you have to think, What if I dont?\nWell, if you dont, then your segments can be as big as you like. Turns out, apparently, some people knew about this even though it was undocumented and perhaps under a non-disclosure agreement. [Michal Necasek] has a great history about the people who independently discovered it, or at least, the ones who talked about it publicly.\nThe method was doomed, though, because of Windows. Windows ran in protected mode and did its own messing with the segment registers. If you wanted to play with that, you needed a different scheme, but thats another story.\nModern Times\nThese days, we dont even use video cards with a paltry 1 MB or even 100 MB of memory! Your PC can adroitly handle tremendous amounts of memory. Im writing this on a machine with 64 GB of physical memory. Even my smallest laptop has 8 GB and at least one of the bigger ones has more.\nThen theres virtual memory, and if you have solid state disk drives, thats probably faster than the old PCs memory, even though today it is considered slow.\nModern memory systems almost dont resemble these old systems even though we abstract them to pretend they do. Your processor really runs out of cache memory. The memory system probably manages several levels of cache. It fills the cache from the actual RAM and fills that from the paging device. Each program can have a totally different view of physical memory with its own idea of what physical memory is at any given address. It is a lot to keep track of.\nTimes change. EMS, XMS, and Unreal mode seemed perfectly normal in their day. It makes you wonder what things we take for granted today will be considered backward and antiquated in the coming decades."}