{"pubDate": "2024-06-15T05:00:40", "original_title": "Easy Retro 3D Look With Voxel Displacement Renderer", "link": "https://hackaday.com/2024/06/14/easy-retro-3d-look-with-voxel-displacement-renderer/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2024/06/banner_project_2024-04-14_01_1600_curve.jpg", "original_content": "Voxels are effectively like 3D pixels, and they form an integral part of what is commonly referred to as a retro 3D look, with pixelated edges sharp enough to cut your retinas on. The problems with modeling a scene using voxels come in the form of creating the geometry and somehow making a physics engine work with voxels rather than conventional triangular (or quad) meshes.\nThe same scene in Blender (above) and in the voxel-based renderer (below). (Credit: Daniel Schroeder)\nThe approach demonstrated by [Daniel Schroeder] comes in the form of a Voxel Displacement Renderer implemented in C++ and using the Vulkan API. Best part of it? It only requires standard meshes along with albedo and displacement maps.\nThese inputs are processed by the C++-based tools, which generate the voxels that should be rendered and their properties, while the GLSL-based shader handles the GPU-based rendering step. The pre-processing steps required make it a good idea to bake these resources rather than try to process it in real-time. With that done, [Daniel]s demo was able to sustain a solid 100+ FPS on a Radeon RX 5700 XT GPU at 1440p, and 60+ FPS on a Steam Deck OLED.\nIn a second blog post [Daniel] goes through his motivations for this project, with it originally having been intended as a showpiece for his resume, but he can imagine it being integrated into a game engine.\nThere are still questions to be resolved, such as how to integrate this technique for in-scene characters and other dynamic elements (i.e. non-static scenery), but in terms of easing voxel-based rendering by supporting a standard mesh-based workflow its an intriguing demonstration.\n\n", "title": "C++\u3068Vulkan API\u3092\u4f7f\u7528\u3057\u305fVoxel Displacement Renderer\u306e\u5b9f\u88c5", "body": "3D\u30d4\u30af\u30bb\u30eb\u3067\u3042\u308b\u30dc\u30af\u30bb\u30eb\u306f\u3001\u53e4\u30443D\u30eb\u30c3\u30af\u306e\u4e00\u90e8\u3068\u3057\u3066\u4f7f\u308f\u308c\u3001\u30b7\u30fc\u30f3\u3092\u30e2\u30c7\u30ea\u30f3\u30b0\u3059\u308b\u969b\u306e\u8ab2\u984c\u3084Vulkan API\u3092\u4f7f\u7528\u3057\u305fVoxel Displacement Renderer\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u306b\u3064\u3044\u3066\u89e3\u8aac\u3055\u308c\u3066\u3044\u307e\u3059\u3002", "titles": ["C++\u3068Vulkan API\u3092\u4f7f\u7528\u3057\u305fVoxel Displacement Renderer\u306e\u5b9f\u88c5", "\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u52d5\u6a5f\u3068\u672a\u89e3\u6c7a\u306e\u8ab2\u984c", "3D\u30d4\u30af\u30bb\u30eb\u306e\u5f79\u5272\uff1a\u30f4\u30a9\u30af\u30bb\u30eb\u306b\u3088\u308b\u30ec\u30c8\u30ed3D\u30eb\u30c3\u30af", "\u30e1\u30c3\u30b7\u30e5\u3068\u30de\u30c3\u30d7\u306e\u307f\u3067\u4f7f\u3048\u308bVoxels\uff1a\u9a5a\u7570\u306e\u5b9f\u884c\u6027\u80fd", "\u6a19\u6e96\u30e1\u30c3\u30b7\u30e5\u306b\u3088\u308b\u30f4\u30a9\u30af\u30bb\u30eb\u30d9\u30fc\u30b9\u306e\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3092\u63a2\u308b"]}