{"pubDate": "2023-07-17T11:00:38", "original_title": "Finding Undocumented 8086 Instructions Via Microcode", "link": "https://hackaday.com/2023/07/17/finding-undocumented-8086-instructions-via-microcode/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/07/x86.png", "original_content": "Video gamers know about cheat codes, but assembly language programmers are often in search of undocumented instructions. One way to find them is to map out all of a CPUs opcodes and where there are holes, try those values, and see what happens. Not good enough for [Ken Shirriff]. He prefers examining the CPUs microcode and deducing what each part of it does.\nMicrocode is a feature of many modern CPUs. The CPU runs several microcode instructions to process a single opcode. For the Intel 8086, there are 512 micro instructions, each with 21 bits. Each instruction has two parts: a part that moves a source to a destination and another that performs some other operation, such as an ALU operation. [Ken] explains it all in the post, including several hidden registers you cant see, but the microcode can.\nSearching for holes in the opcode table.\nSome of the undocumented instructions are probably not useful. They are either impractical or duplicate a function you can already do another way. Not all of the instructions are there for technical reasons. For example, opcode D6, commonly known as SALC for Set AL to Carry, seems to exist only as a trap for anyone making a carbon copy of Intels microcode. When other companies like NEC made 8086 clones, having an undocumented instruction would strongly suggest they just copied Intels intellectual property (in NECs case, they didnt).\nOther cases happen where an instruction just doesnt make sense. For example, you can pop all segment registers, and though it is not documented, you can deduce that POP CS should be opcode 0F. The problem is there is no sane reason to pop CS off the stack. The instruction works; it just isnt useful. The opcodes from 60-6F are conditional jumps that are no different from the instructions at 70-7F because of decoding. There is no reason to document both identical instruction ranges.\nThe plot thickens when you go to two-byte instructions. Youll find plenty of instructions of dubious value. You dont hear much about undocumented instructions anymore. Why? Because modern CPUs have enough circuitry to dedicate some to detecting illegal instructions and halting the CPU. But the 8086 was squeezed too tight to allow for such a luxury. Good thing for people like us who enjoy solving puzzles.\nYou can still get a modern CPU to tell you more about instructions even if it wont run them. Even the 80286 had some secret opcodes.", "title": "\u30a2\u30bb\u30f3\u30d6\u30ea\u8a00\u8a9e\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u5fc5\u898b\uff01CPU\u306e\u30de\u30a4\u30af\u30ed\u30b3\u30fc\u30c9\u304b\u3089\u672a\u516c\u958b\u547d\u4ee4\u3092\u89e3\u8aad\u3059\u308b\u65b9\u6cd5", "body": "\u30b2\u30fc\u30de\u30fc\u306f\u30c1\u30fc\u30c8\u30b3\u30fc\u30c9\u3092\u77e5\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u30a2\u30bb\u30f3\u30d6\u30ea\u8a00\u8a9e\u30d7\u30ed\u30b0\u30e9\u30de\u306f\u672a\u516c\u958b\u306e\u547d\u4ee4\u3092\u63a2\u3057\u3066\u3044\u307e\u3059\u3002CPU\u306e\u30aa\u30da\u30b3\u30fc\u30c9\u3092\u30de\u30c3\u30d4\u30f3\u30b0\u3057\u3001\u7a7a\u3044\u3066\u3044\u308b\u7b87\u6240\u306b\u5024\u3092\u8a66\u3057\u3066\u7d50\u679c\u3092\u898b\u308b\u65b9\u6cd5\u3082\u3042\u308a\u307e\u3059\u304c\u3001[Ken Shirriff]\u306fCPU\u306e\u30de\u30a4\u30af\u30ed\u30b3\u30fc\u30c9\u3092\u8abf\u67fb\u3057\u3066\u5404\u90e8\u5206\u306e\u6a5f\u80fd\u3092\u63a8\u6e2c\u3059\u308b\u3053\u3068\u3092\u597d\u307f\u307e\u3059\u3002\u6700\u65b0\u306eCPU\u306b\u3082\u30de\u30a4\u30af\u30ed\u30b3\u30fc\u30c9\u304c\u3042\u308a\u30011\u3064\u306e\u30aa\u30da\u30b3\u30fc\u30c9\u3092\u51e6\u7406\u3059\u308b\u305f\u3081\u306b\u8907\u6570\u306e\u30de\u30a4\u30af\u30ed\u30b3\u30fc\u30c9\u547d\u4ee4\u304c\u5b9f\u884c\u3055\u308c\u307e\u3059\u3002\u672a\u516c\u958b\u306e\u547d\u4ee4\u306f\u5fc5\u305a\u3057\u3082\u6709\u7528\u3067\u306f\u306a\u3044\u3053\u3068\u3082\u3042\u308a\u307e\u3059\u304c\u30018086\u3067\u3044\u304f\u3064\u304b\u306e\u7a74\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002", "titles": ["\u30a2\u30bb\u30f3\u30d6\u30ea\u8a00\u8a9e\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u5fc5\u898b\uff01CPU\u306e\u30de\u30a4\u30af\u30ed\u30b3\u30fc\u30c9\u304b\u3089\u672a\u516c\u958b\u547d\u4ee4\u3092\u89e3\u8aad\u3059\u308b\u65b9\u6cd5", "\u4e0d\u6587\u66f8\u5316\u3055\u308c\u305f\u547d\u4ee4\u3092\u63a2\u3057\u51fa\u3059\u305f\u3081\u3001CPU\u306e\u30aa\u30da\u30b3\u30fc\u30c9\u3092\u30de\u30c3\u30d4\u30f3\u30b0\u3059\u308b\u65b9\u6cd5", "Intel 8086\u306b\u304a\u3051\u308b\u30de\u30a4\u30af\u30ed\u30b3\u30fc\u30c9\u306e\u89e3\u6790\uff1a\u96a0\u308c\u305f\u30ec\u30b8\u30b9\u30bf\u3068\u4e0d\u660e\u306a\u547d\u4ee4\u306b\u3064\u3044\u3066", "\u30d1\u30ba\u30eb\u597d\u304d\u5fc5\u898b\uff01\u73fe\u4ee3\u306eCPU\u3067\u3082\u4f7f\u308f\u308c\u308b\u79d8\u5bc6\u306e\u30aa\u30da\u30b3\u30fc\u30c9\u306b\u8feb\u308b", "\u65b0\u6642\u4ee3\u306eCPU\u306f\u4e0d\u6cd5\u306a\u547d\u4ee4\u3092\u691c\u51fa\u3057\u3066\u505c\u6b62\u3067\u304d\u308b\u304c\u30018086\u3067\u306f\u672a\u516c\u958b\u547d\u4ee4\u306e\u5b58\u5728\u304c\u8a31\u5bb9\u3055\u308c\u3066\u3044\u305f"]}