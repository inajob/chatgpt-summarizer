{"pubDate": "2023-05-08T17:00:57", "original_title": "A Literate Assembly Language", "link": "https://hackaday.com/2023/05/08/a-literate-assembly-language/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2015/08/universal-assembler.jpg", "original_content": "A recent edition of [Babbages] The Chip Letter discusses the obscurity of assembly language. He points out, and I think correctly, that assembly language is more often read than written, yet nearly all of them are hampered by obscurity left over from the days when punched cards had 80 columns and a six-letter symbol was all you could manage in the limited memory space of the computer. For example,\u00a0 without looking it up, what does the ARM instruction FJCVTZS do? The instructions full name is Floating-point Javascript Convert to Signed Fixed-point Rounding Towards Zero. Not super helpful.\nBut it did occur to me that nothing is stopping you from writing a literate assembler that is made to be easier to read. First, most C compilers will accept some sort of asm statement, and you could probably manage that with compile-time string construction and macros. However, I think there is a better possibility.\nReuse, Recycle\nSince I sometimes develop new CPU architectures, I have a universal cross assembler that is, honestly, an ugly hack, but it works quite well. Ive talked about it before, but if you dont want to read the whole post about it, it uses some simple tricks to convert standard-looking assembly language formats into C code that is then compiled. Executing the resulting program outputs the desired machine language into a desired file format. It is very easy to set up, and in the middle, theres a nice C program that emits machine code. It is not much more readable than the raw assembly, but you shouldnt have to see it. But what if we started the process there and made the format readable?\nAt the heart of the system is a C program that lives in soloasm.c. It handles command line options and output file generation. It calls an external function, genasm with a single integer argument. When that argument is set to 1, it indicates the assembler is in its first pass, and you only need to fill in label values with real numbers. If the pass is a 2, it means actually fill in the array that holds the code.\nThat array is defined in the __solo_info instruction (soloasm.h). It includes the size of the memory, a pointer to the code, the processors word size, the beginning and end addresses, and an error flag. Normally, the system converts your assembly language input into a bunch of function calls it writes inside the genasm function. But in this case, I want to reuse soloasm.c to create a literate assembly language.\nModernize\nI wrote all this a long time ago, but I wanted the creation of literate assembly to be easier, so I decided to do a low-effort conversion to C++. This allows you to use nice data structures for the symbol table, for example. However, I didnt use all the C++ features I could have, simply in the interest of time.\nThe base class is reasonably agnostic about the processor, and, as an example, Ive provided a literate RCA 1802 assembler. Just a proof of concept, so I could probably name the instructions a bit more consistently, and there is plenty of room for other improvements, but it gets my point across.\nHeres an excerpt of a blinking light program written for the 1802 using the standard assembler syntax:\nORG 0\nMain:\n   LDI HIGH(R3Go)\n   PHI R3\n   LDI LOW(R3Go)\n   PLO R3\n   SEP R3\nR3Go: LDI HIGH(Delay)\n   PHI R9\n   LDI LOW(Delay)\n   PLO R9\n   LDI HIGH(Stack)\n   PHI R7\n   LDI LOW(Stack)\n   PLO R7\n   SEX R7\n   LDI 0\n   STR R7\nLoop: OUT 4\n. . .\n   NOP\n   BR DELAY1\n\n   ORG $F0\nStack: DB 0\n   END Main\n\nNow here is the exact same written for the literate assembler:\n\n// Simple 1802 Literate Program\n#include lit1802.h\n\n#define ON 1\n#define OFF 0\n\n#define DELAYPC 9 // delay subroutine\n#define DELAYR 8 // delay count register\n#define MAINPC 3 // Main routine PC\n#define RX 7 // RX value\n#define DELAYVAL 0xFF // time to delay (0-255)\n\nvoid Program(void)\n{\n   Origin(0x0);\n// Blinky light program\n// Main:\nDefine_Label(Main);\n// Force R3 as PC just in case\n   Load_R_Label(MAINPC,R3Go);\n   Set_PC_To_Register(MAINPC);\n// Here we are P=3\n// R3Go:\nDefine_Label(R3Go);\n// Set R9 to delay routine (default PC=0)\n   Load_R_Label(DELAYPC,Delay);\n// Set RX=7 at memory 00F0\n   Load_R_Label(RX,Stack);\n   Set_X_To_Register(RX);\n   Load_D_Imm(0);\n   Store_D_To_Reg_Address(RX);\n\n// Loop:\nDefine_Label(Loop);\n   Output_Mem_RX_Incr(4); // write count to LED\n. . . \n   NOP(10);\n   Branch(Label(Delay1)); // note... could define BRANCH as _BRANCH and then #define Branch(l) _BRANCH(Label(l)) if you like...\n\nLocation(0xF0); // storage for RX\n// Stack:\nDefine_Label(Stack);\n   Byte();\n   End_Program(Label(Main)); // End of program\n}\n\nWell, admittedly, there are comments and symbols, but still. You can download both files if you want to compare. You can also find the entire project online.\nUnder the Hood\nThe idea is simple. Each function simply populates an array with the byte or bytes necessary. Admittedly, the 1802 is pretty simple. It would be harder to do this for a modern processor with many instructions and complex modes. But not impossible.\nYou can do lots of things to make life easier, both while programming and while setting up instructions. For example, if you wanted 100 NOP instructions, you could\u00a0 write:\nfor (int i = 0 ; i  100 ; i++) NOP();\nOn the other hand, NOP has an optional argument that will do it for you. You can freely use the C++ compiler and the macro preprocessor to make your life easier. For example, a common task on the 1802 is putting a constant value like a label into a register. The lit1802.h file has a macro to make this easy:\n\n\nvoid Load_R_Label(uint8_t reg,const std::string s)\n{\n  Load_D_Imm(HIGH(s));\n  Put_High_Register(reg);\n  Load_D_Imm(LOW(s));\n  Put_Low_Register(reg);\n}\n\n\nObviously,\u00a0 you can change the names to suit or have as many aliases as you want. Dont forget that function call overhead, like calling Load_R_Label, is incurred at compile time. You wind up with the same machine code either way.\nThe assembler is two-pass. The first pass only defines labels. The second pass generates real code. This would make it hard, for example, to create a smart jump instruction that used a branch when the target was near and a long jump when it was far unless you dont mind padding the branch with a NOP, which would not save space but might save execution time.\nThere would be other complications for a modern processor. For example, not trying to allocate the entire memory space or generating relocatable output. But this is truly a proof-of-concept. None of those things are impossible, they are just more work.\nBottom Line\nIve written and read dozens of assembly languages for years, so Im pretty comfortable with the status quo and Im unlikely to use litasm myself. However, I did think [Babbages] point was well made. If you want to make assembly more readable, there are benefits and this shows it doesnt have to be that hard to do. You could also write a litasm disassembler to convert object code into this kind of format.\nWant to know more about the Universal Assembler? If youd rather tackle practical x86-64 assembly, we know a good place to start.", "title": "\u300c\u30ea\u30c6\u30e9\u30b7\u30fc\u306a\u30a2\u30bb\u30f3\u30d6\u30e9\u304c\u3042\u308b\u3063\u3066\u77e5\u3063\u3066\u305f\uff1f\u300d", "body": "\u30a2\u30bb\u30f3\u30d6\u30ea\u8a00\u8a9e\u306f\u96e3\u89e3\u3067\u8aad\u307f\u3084\u3059\u304f\u306a\u3044\u305f\u3081\u3001\u8457\u8005\u306f\u3088\u308a\u8aad\u307f\u3084\u3059\u3044\u30ea\u30c6\u30e9\u30eb\u30a2\u30bb\u30f3\u30d6\u30e9\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u304c\u63d0\u6848\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u304b\u3089\u6a5f\u68b0\u8a9e\u3092\u751f\u6210\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u3042\u308b\u300cUniversal cross assembler\u300d\u306e\u62e1\u5f35\u3068\u3057\u3066\u3001\u8457\u8005\u306f\u30ea\u30c6\u30e9\u30eb\u30a2\u30bb\u30f3\u30d6\u30e9\u3092\u30d7\u30ed\u30b0\u30e9\u30e0\u3057\u3001\u8aac\u660e\u3057\u3066\u3044\u307e\u3059\u3002", "titles": ["\u300c\u30ea\u30c6\u30e9\u30b7\u30fc\u306a\u30a2\u30bb\u30f3\u30d6\u30e9\u304c\u3042\u308b\u3063\u3066\u77e5\u3063\u3066\u305f\uff1f\u300d", "\u300c\u30a2\u30bb\u30f3\u30d6\u30ea\u8a00\u8a9e\u3092\u3088\u308a\u8aad\u307f\u3084\u3059\u304f\u3059\u308b\u65b9\u6cd5\u300d", "\u300c\u30a2\u30bb\u30f3\u30d6\u30ea\u8a00\u8a9e\u306e\u66f8\u304d\u3084\u3059\u3055\u306b\u95a2\u3059\u308b\u554f\u984c\u70b9\u300d", "\u300c\u30ea\u30c6\u30e9\u30b7\u30fc\u30a2\u30bb\u30f3\u30d6\u30e9\u30fc\u3092\u73fe\u4ee3\u5316\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3068\u5224\u660e\u300d", "\u300c\u30a2\u30bb\u30f3\u30d6\u30ea\u8a00\u8a9e\u3092\u3088\u308a\u76f4\u611f\u7684\u306b\u3059\u308b\u65b9\u6cd5\u300d"]}