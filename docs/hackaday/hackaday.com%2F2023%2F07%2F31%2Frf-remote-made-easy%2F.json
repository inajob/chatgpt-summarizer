{"pubDate": "2023-07-31T23:00:34", "original_title": "RF Remote Made Easy", "link": "https://hackaday.com/2023/07/31/rf-remote-made-easy/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/07/remote-main.jpg", "original_content": "The 433 MHz spectrum is a little bit of an oddball. Its one of the few areas of the radio spectrum which is nearly universally unlicensed, meaning as long as devices using it adhere to the power restrictions and other guidelines about best practices, its essentially an open playground. IoT devices operate here, as well as security systems and, of course, remote controls. And, using a few off-the-shelf parts [hesam.moshiri] shows us how to take advantage of this piece of spectrum by designing and building a programmable and versatile 4-channel 433 MHz remote control.\nBuilt around an ATmega8 microcontroller, making it easy to work with Arduino sketches, and with a 28 character LCD for ease-of-use when not connected to a computer, the wireless switching device can store up to 80 remote control codes in its EEPROM memory. This was one of the harder parts for [hesam] to sort out, but using structures to store the data for the codes eventually solved the problems. A simple GUI makes using it with whatever remote happens to be on hand fairly straightforward, including the ability to record codes from existing remotes on the fly and also to associate those codes with specific actions.\nSchematics and a bill of materials are available on the projects page, making this fairly accessible to those looking to add some wireless connectivity to a project, home automation system, or IoT device. Its mainly set up as a switching device, but with some modifications could be put to work doing more complex tasks. The 433 MHz spectrum is an exciting place to be, too, and things like setting up entire security systems using it are not too far removed from a switching device like this.\n\n", "title": "\u300cATmega8\u30de\u30a4\u30af\u30ed\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc\u3092\u4f7f\u7528\u3057\u305f433 MHz\u30ea\u30e2\u30fc\u30c8\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u306e\u4f5c\u6210\u65b9\u6cd5\u300d", "body": "433 MHz\u5468\u6ce2\u6570\u5e2f\u57df\u306e\u7121\u7dda\u30ea\u30e2\u30b3\u30f3\u3092\u8a2d\u8a08\u30fb\u69cb\u7bc9\u3059\u308b\u65b9\u6cd5\u304c\u7d39\u4ecb\u3055\u308c\u3066\u3044\u307e\u3059\u3002ATmega8\u30de\u30a4\u30af\u30ed\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u6db2\u6676\u753b\u9762\u3092\u4f7f\u7528\u3057\u300180\u500b\u306e\u30ea\u30e2\u30b3\u30f3\u30b3\u30fc\u30c9\u3092\u4fdd\u5b58\u3067\u304d\u307e\u3059\u3002\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u30da\u30fc\u30b8\u306b\u8a2d\u8a08\u56f3\u3084\u90e8\u54c1\u30ea\u30b9\u30c8\u3082\u3042\u308a\u307e\u3059\u3002\u6700\u592780\u500b\u306e\u30ea\u30e2\u30b3\u30f3\u30b3\u30fc\u30c9\u3092\u4fdd\u5b58\u3067\u304d\u307e\u3059\u3002", "titles": ["\u300cATmega8\u30de\u30a4\u30af\u30ed\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc\u3092\u4f7f\u7528\u3057\u305f433 MHz\u30ea\u30e2\u30fc\u30c8\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u306e\u4f5c\u6210\u65b9\u6cd5\u300d", "\u300c\u30ef\u30a4\u30e4\u30ec\u30b9\u30b9\u30a4\u30c3\u30c1\u30f3\u30b0\u30c7\u30d0\u30a4\u30b9\u306780\u500b\u306e\u30ea\u30e2\u30fc\u30c8\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u30b3\u30fc\u30c9\u3092\u4fdd\u5b58\u300d", "\u300c\u7c21\u5358\u306aGUI\u3067\u4f7f\u3044\u3084\u3059\u3044433 MHz\u30ea\u30e2\u30fc\u30c8\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u30bd\u30ea\u30e5\u30fc\u30b7\u30e7\u30f3\u300d", "\u300c\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u30ef\u30a4\u30e4\u30ec\u30b9\u63a5\u7d9a\u3092\u8ffd\u52a0\u3059\u308b\u305f\u3081\u306e\u30b9\u30ad\u30fc\u30de\u3068\u6750\u6599\u300d", "\u300c\u30db\u30fc\u30e0\u30aa\u30fc\u30c8\u30e1\u30fc\u30b7\u30e7\u30f3\u30b7\u30b9\u30c6\u30e0\u3084IoT\u30c7\u30d0\u30a4\u30b9\u306b\u9069\u3057\u305f433 MHz\u30b9\u30a4\u30c3\u30c1\u30f3\u30b0\u30c7\u30d0\u30a4\u30b9\u306e\u6d3b\u7528\u65b9\u6cd5\u300d"]}