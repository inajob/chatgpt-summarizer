{"pubDate": "2023-06-15T15:30:41", "original_title": "Iran\u2019s Military Quantum Claim: It\u2019s Only 99.4% Ridiculous", "link": "https://hackaday.com/2023/06/15/irans-quantum-computing-on-fpga-claim-its-kinda-a-thing/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/06/iran_quantum_computing_fpga_presentation_2.jpg", "original_content": "When Iran recently announced a quantum processing algorithm (Google translation) that would help its military to detect water surface disturbances, the instant response from Western media was one of ridicule, based on the displayed hardware. The hardware in question was the Digilent ZedBoard Zynq-7000 hybrid SoC/FPGA development board, which can be yours for less than $600.\nSeems absurd, and the claim about any realistic military use absolutely is. But buried deep, deep down, there may be a tiny kernel of truth: because quantum computers are inherently parallel, FPGAs can make a good fit for small-scale quantum simulations.\nDoes this mean that the Iranian Navy would be better off simulating quantum circuits on an FPGA board than on a GPU or even a used laptop? Probably not. Will this hardware serve the proposed military application in the forseeable future? Absolutely not! Was this a misleading and ridiculous photo op? Yup. 100%.\nBut is emulating qubits in FPGA fabric a real thing? Turns out it is! Lets have a look.\n\nFPGA-based quantum system diagram. (Credit: Pilch et al., 2019)\nBecause classical computers are rather slow at running quantum computing algorithms, an FPGA could have a chance at improving performance for this task, as demonstrated in a 2004 paper by A. U. Khalid et al. (also here as a PDF in the masters-thesis version) as well as in An FPGA-based real quantum computer emulator by Jakub Pilch et al.\nIn the latter paper, which includes a great overview of the state of the art, Pilch and colleagues summarize this as shifting the processing from time to space  from using slow sequential CPU processing to hardware complexity, using the FPGAs configurable fabric and inherent parallelism.\nWhats the cost? FPGAs have a limited number of cells, and the time-space tradeoff that Pilch et al are making limit them to two qubits. Thats four states. You have more fingers on one hand. By filling up the entire FPGA, they are essentially able to implement a two-bit quantum XOR. So much for real-world military applications.\nThe less parallel approach taken by Khalid et al allows for nine simulated qubits on the same FPGA, but is dramatically slower and not much more practical. Both papers suggest that the tradeoff between speed and FPGA fabric space looks exponential, so any FPGA simulation will necessarily be very small or very slow, chose one. Indeed, for practical simulations, Google recommends renting a bunch of GPUs instead.\nThe whole promise of a real quantum computer is that it allows for parallelism and speed, and thats of course where all\u00a0 classical simulations come up short. And this is why were calling BS on the Iranian claims. But we were excited to learn about FPGA-based qubit simulation along the way, and any simulation is great for learning. If youre interested and you dont have an FPGA board, you can do it all from the comfort of your web browser, or heck, even an Arduino if you need a prop for the photo op.\nThanks to [Andrew Wilson] for the tip and citations.\n", "title": "FPGA\u3067\u91cf\u5b50\u56de\u8def\u306e\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u304c\u53ef\u80fd", "body": "\u30a4\u30e9\u30f3\u306f\u65b0\u3057\u3044\u91cf\u5b50\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u767a\u8868\u3057\u305f\u304c\u3001\u305d\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u304c\u5b9f\u73fe\u53ef\u80fd\u304b\u3069\u3046\u304b\u306b\u3064\u3044\u3066\u7591\u554f\u8996\u3055\u308c\u305f\u3002\u305d\u308c\u3067\u3082FPGA\u30dc\u30fc\u30c9\u3092\u7528\u3044\u305f\u91cf\u5b50\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u3064\u3044\u3066\u89e3\u8aac\u3055\u308c\u3001FPGA\u306f\u91cf\u5b50\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u5411\u3044\u3066\u3044\u308b\u3053\u3068\u304c\u5206\u304b\u3063\u305f\u3002\u305f\u3060\u3057\u3001\u5b9f\u969b\u306e\u8ecd\u4e8b\u6d3b\u7528\u306b\u306f\u73fe\u72b6\u3067\u306f\u4e0d\u5411\u304d\u3067\u3042\u308b\u3002", "titles": ["FPGA\u3067\u91cf\u5b50\u56de\u8def\u306e\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u304c\u53ef\u80fd", "\u30a4\u30e9\u30f3\u304c\u767a\u8868\u3057\u305f\u91cf\u5b50\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5199\u771f\u306b\u6ce8\u76ee", "FPGAs\u306f\u5c0f\u898f\u6a21\u306a\u91cf\u5b50\u56de\u8def\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u9069\u3057\u3066\u3044\u308b", "\u91cf\u5b50\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30fc\u306e\u73fe\u72b6\u3068FPGA\u306e\u95a2\u4fc2\u306b\u3064\u3044\u3066", "\u5b9f\u7528\u7684\u306a\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u306fGPU\u304c\u304a\u3059\u3059\u3081"]}