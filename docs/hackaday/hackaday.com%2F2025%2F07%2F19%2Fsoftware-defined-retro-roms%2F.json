{"pubDate": "2025-07-20T02:00:36", "original_title": "Software Defined Retro ROMs", "link": "https://hackaday.com/2025/07/19/software-defined-retro-roms/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/07/SoftwareDefinedROM.jpg", "youtube": "https://www.youtube.com/watch?v=Jhe4LF5LrZ8", "original_content": "Heres something fun from our hacker [Piers]: Software Defined ROMs.\nIn this series of three videos, [Piers] runs us through what a software defined ROM is, how to make them, and then how to use them.\nAs [Piers] explains, one frustration a retro technician will face is a failed ROM chip. In the era hes interested in, there are basically three relevant kinds of ROM chip, all 24-pin Dual Inline Package (DIP):\n\n2364 ROM chip: 8KB; 1x chip-select line\n2332 ROM chip: 4KB; 2x chip-select lines\n2316 ROM chip: 2KB; 3x chip-select lines\n\n\nThe chip-select line is how the processor indicates to a particular ROM chip that it should be active. When active, a ROM chip will read the value on the address lines and output the data at that address on the data lines.\nWith his software defined ROMs [Piers] implements the ROM behavior (converting requests on the address lines to results on the data lines) by using a microcontroller. As his ROM boards are software defined, they are eminently configurable, which means he can support all configurations of all three types of ROM.\n[Piers] looks at some old ROM datasheets to get details about timing requirements. His functional requirements are that all three types of ROM can be emulated with a single hardware variant (the same microcontroller) with the same footprint (24-pin DIP), that they be hand-solderable, and cheap. Further technical requirements were that the solutions can all be implemented in software (no FPGA), requiring as few onboard components as possible, that the GPIOs be 5V tolerant, that a fast clock speed be available using the on-chip oscillator, that no more than two PCB layers are required, and that all SMD components are 0603 or larger.\nHe considered various microcontrollers, including PICO/RP2040/RP2350, ESP32, ATMEGA, PIC, STM32F1, and STM32F4. He really wanted the PICO because they are fast and powerful, but they dont have 5V tolerant GPIOs, so he settled on the STM32F4 instead. He talks in detail about pin selection, PCB routing, and ROM preprocessing (mangling) for optimal performance. The chip loads its data from flash storage into RAM so it has reliable and deterministic performance characteristics. Provision is made for programming pins so the ROMs can be reprogrammed in-circuit.\nWhen it comes to programming, [Piers] has implemented most things in hand-rolled assembly code. The reason, he says, is that he didnt want variable implementations depending on the version of compiler used.\nNow that you have a universal software defined ROM, all you need is a reliable ROM dumper.\n\n\n"}