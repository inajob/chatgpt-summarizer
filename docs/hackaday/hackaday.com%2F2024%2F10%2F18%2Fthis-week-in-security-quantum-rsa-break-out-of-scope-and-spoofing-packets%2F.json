{"pubDate": "2024-10-18T14:00:38", "original_title": "This Week in Security: Quantum RSA Break, Out of Scope, and Spoofing Packets", "link": "https://hackaday.com/2024/10/18/this-week-in-security-quantum-rsa-break-out-of-scope-and-spoofing-packets/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2016/01/darkarts.jpg", "original_content": "Depending on who you ask, the big news this week is that quantum computing researchers out of China have broken RSA. (Heres the PDF of their paper.) And thats true sort of. There are multiple caveats, like the fact that this proof of concept is only factoring a 22-bit key. The minimum RSA size in use these days is 1024 bits. The other important note is that this wasnt done on a general purpose quantum computer, but on a D-Wave quantum annealing machine.\nFirst off, what is the difference between a general purpose and annealing quantum computer? Practically speaking, a quantum annealer cant run Shors algorithm, the quantum algorithm that can factor large numbers into primes in a much shorter time than classical computers. While its pretty certain that this algorithm works from a mathematical perspective, its not at all clear that it will ever be possible to build effective quantum computers that can actually run it for the large numbers that are used in cryptography.\nWere going to vastly oversimplify the problem, and say that the challenge with general purpose quantum computing is that each q-bit is error prone, and the more q-bits a system has, the more errors it has. This error rate has proved to be a hard problem. The D-wave quantum annealing machine side-steps the issue by building a different sort of q-bits, that interact differently than in a general purpose quantum computer. The errors become much less of a problem, but you get a much less powerful primitive. And this is why annealing machines cant run Shors algorithm.\nThe news this week is that researchers actually demonstrated a different technique on a D-wave machine that did actually factor an RSA key. From a research and engineering perspective, it is excellent work. But it doesnt necessarily demonstrate the exponential speedup that would be required to break real-world RSA keys. To put it into perspective, you can literally crack a 22 bit RSA key by hand.\n\nZendesk Out of Scope\nHeres an example of two things. First off, a bug being out of scope for a bounty shouldnt stop a researcher from working on a bug. Second, its worth being extra careful in how a bug bountys scope is set up, as sometimes bugs have unforeseen consequences. Were talking here about Zendesk, a customer support tool and ticket manager. [Daniel] found an issue where an attacker could send an email to the support email address from a spoofed sender, and add an arbitrary email address to the ticket, gaining access to the entire ticket history.\nBecause the problem was related to email spoofing, and the Zendesk bounty program on HackerOne considers SPF, DKIM, and DMARC to be out of scope, the ticket was closed as informative and no bounty awarded. But [Daniel] wasnt done. What interesting side effects could he find? How about triggering single sign on verification to go to the support email address? Since an Apple account can be used to sign on to slack, an attacker can create an apple account using the support email address, use the email spoof to get access to the created bug, and therefore the one-time code. Verify the account, and suddenly you have an Apple account at the targets domain. [Daniel] used this to gain access to company Slack channels, but Id guess this could be used for even more mayhem at some businesses.\nGiven that the original bug report was closed as informational, [Daniel] started reporting the bug to other companies that use Zendesk. And it paid off, netting more than $50,000 for the trouble. Zendesk never did pay a bounty on the find, but did ask [Daniel] to stop telling people about it.\nFortinet Fixed It\nThe good folks at Watchtowr Labs have the inside scoop on a recently fixed vulnerability in Fortinets FortiGate VPN appliance. Its a good fix found internally by Fortinet, and gives us a good opportunity to talk about a class of vulnerability we havent ever covered. Namely, a format string vulnerability.\nThe printf() function and its siblings are wonderful things. You give it a string, and it prints it to standard output. You give it a string that contains a format specifier, like %s, and it will replace the specifier with the contents of a variable passed in as an additional argument. I write a lot of printf debugging code when trying to figure out a problem, that looks like printf(\"Processing %d bytes!\\n\", length);\nWhat happens if the specifier doesnt match the data type? Or if there is a specifier and no argument? You probably know the answer: Undefined behavior. Not great for device security. And in this case, it does lead to Remote Code Execution (RCE). The good news is that Fortinet found this internally, and the fix was quietly made available in February. The bad news is that attackers found it, and have since been actively using it in attacks.\nEscape!\n[ading2210] has the story of finding a pair of attack chains in Google Chrome/Chromium, where a malicious extension can access the chrome://policy page, and define a custom browser command to use when accessing specific pages. There are two separate vulnerabilities that can be used to pull off this trick. One is a race condition where disallowed JS code can run before its disabled after a page reload, and the other is a crash in the page inspector view. Thats not a page non-developers have a habit of visiting, so the browser extension just pulls a fast one on install, launching a simple page that claims that something went wrong, asking the user to press f12 to troubleshoot.\nhttps://ading.dev/blog/assets/chrome_sandbox_escape/sandbox_escape_final.mp4\nMultihomed Spoofing\nAt this point, most of us rely on Linux for our routers and firewalls. Whether you realize it or not, its extremely likely that that little magical box that delivers Internet goodness to your devices is a Linux machine, running iptables as the firewall. And while iptables is excellent at its job, it does have its share of quirks. Researchers at Anvil have the low down on ESTABLISHED connection spoofing.\nIptables, when run on the boarder between networks, is often set to block incoming packets by default, and allow outgoing. The catch is that you probably want responses to your requests. To allow TCP connections to work both ways, its common to set iptables to allow ESTABLISHED connections as well. If the IP addresses and ports all match, the packet is treated as ESTABLISHED and allowed through. So whats missing? Unless you explicitly request it, this firewall isnt checking that the source port is the one you expected. Packets on one interface just might get matched to a connection on a different interface and passed through. That has some particularly interesting repercussions for guest networks and the like.\nBits and Bytes\nOn the topic of more secure Linux installs, [Shawn Chang] has thoughts on how to run a container more securely. The easy hint is to use Podman and run rootless containers. If you want even tighter protection, there are restrictions on system calls, selinux, and a few other tricks to think about.\nCheck the logs! Thats the first step to looking for a breach or infection, right? But what exactly are you looking for? The folks at Trunc have thoughts on this. The basic idea is to look for logins that dont belong, IPs that shouldnt be there, and other specific oddities. Its a good checklist for trouble hunting.\nAnd finally, the playlist from DEF CON 32 is available! Among the highlights are [Cory Doctorow] talking about the future of the Internet, [HD Moore] and [Rob King] talking about SSH, and lots lots more!\n"}