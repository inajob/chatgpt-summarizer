{"pubDate": "2023-12-21T18:00:44", "original_title": "Displays We Love Hacking: SPI and I2C", "link": "https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/", "source": "https://hackaday.com/blog/feed/", "original_content": "Ive talked about HD44780 displays before  theyve been a mainstay of microcontroller projects for literal decades. In the modern hobbyist world, theres an elephant in the room  the sheer variety of I2C and SPI displays you can buy. Theyre all so different, some are LCD and some are OLED, some have a touchscreen layer and some dont, some come on breakouts and some are a bare panel. No matter which one you pick, there are things you deserve to know.\nThese displays are exceptionally microcontroller-friendly, they require hardly any GPIOs, or none extra if you already use I2C. Theyre also unbelievably cheap, and so tiny that you can comfortably add one even if youre hurting for space. Sure, they require more RAM and a more sophisticated software library than HD44780, but with modern microcontrollers, this is no problem at all. As a result, you will see them in almost every project under the sun.\nWhat do you need for those? What are the requirements to operate one? What kind of tricks can you use with them? Lets go through the main aspects.\n\nThe Basics\nThese displays are all fundamentally the same in how you create the data to be displayed. Theres no interface to show text strings anymore like there is with HD44780 displays  you take control of pixels, monochrome or color, and you have to send them to the display from your microcontroller. This means you have to have enough RAM to represent all those pixels, or generate them on the fly naturally, which puts a cap on the kinds of MCUs you can use.\nIts possible to send partial updates to such a display, so that you can create UI by sending different chunks of data to different regions of the display. For instance, Ive once built an UI that solely did partial updates for a 320 x 480 color display driven by an ESP32, in a project where RAM was already at a premium. To help with such tasks, many displays allow you to read pixel data out of them. However, it will require more intricate code, so a typical library allocates a full screens worth of space for the display and calls it a day.\nThere are two interfaces typically used for these displays  I2C and SPI. I2C is easier and is likely already available in your project, but it puts a cap on your data transfer speed. This means that you will hardly ever see a color display with an I2C interface  because, as a rule, you need to send 16 times more data to update a color display as opposed to a monochrome one, for the same amount of pixels. You can push SPI faster  whereas I2C typically goes either 100 kHz or 400 kHz, rarely 1 MHz, you can typically push data into an SPI display at a few MHz clock rate, often even 10 MHz.\nThis SPI display gives you a 240320 color pixel area to draw anything on. By [AaltoFablab], CC 2.0On the other hand, I2C is easier to wire up. If your SPI wiring or configuration is incorrect, an SPI display will not display a picture and just leave you hanging. If you can detect an I2C display on the bus, it can accept your data  SPI displays have no such detection mechanism, at least, not as far as I know, and definitely not for the vast majority of small displays that dont even expose the MISO pin.\nIf youve miswired an SPI display, you will get no output and no idea on whats going on, until you re-inspect your wiring and code, thoroughly look the problem up online, or plug a logic analyzer in. Its not like miswiring SPI displays is all that easy, but its not uncommon when doing bringup on unfamiliar displays, and it can happen to anyone. Also, the extra SPI pins require extra GPIOs, and its not uncommon that you cant share the SPI bus with other displays unless you add a 74125 gate to make sure that your SPI display is not interfering with other devices on the bus.\nThese factors are not a problem as such, theyre merely things I describe so that you know which display to pick in which situation. If youre starting out in electronics and youre fine with monochrome output, pick up an I2C OLED, theyre numerous and software support is omnipresent. If you want high speed updates or color output, youll have to work with an SPI display. By the way, displays like SSD1306 and SH1106 OLEDs support both I2C and SPI  it depends on how the breakout is wired up; TFT displays only support SPI as a rule. Picked one of the two, and found the GPIOs needed? Lets talk software.\nA Little Code\nEven an ATMega328P can work with such a display  though, sometimes, barely. By [Turbospok] CC BY-SA 4.0For most of the popular programming languages and platforms, theres already a library to work with an average screen you can buy. If you have a favourite language or platform youd like to use, see if theres a pre-written library for it that works with your specific screen, and purchase accordingly. To look the library up, all you need to know is the display controller name and the display resolution. If there isnt a library yet, you can one by modifying one of the existing screen libraries for your screens parameters. Of course, that might not be how youve planned to spend your evening. But what if you have to? What if you got yourself a display and it doesnt work with existing libraries?\nIf you want to know how a system works, its helpful to see how it breaks  so lets describe possible (but rare) software incompatibilities and see where they come from. Ill discuss wiring problems in a later section, for now, lets assume you have a working link with the display and all GPIOs are in order. First thing to look into, then, is the controller IC type. Every LCD or OLED screen has an IC bonded to the panel  its the square pretty piece of silicon, that is often covered with a black sticker to protect the silicon from stray photons and general damage. Theres different families and models of these ICs, and theyre a defining feature for a typical screen  when picking a library, its important to know which screen controller its for.\nDifferent controllers might require different SPI modes, control pins or clock speeds. However, most often, whats different is the language that the controller uses  its registers and their addresses, the values you need to write into these addresses, and the way it accepts screen data. If you port a library from one controller to another, you might need to change the way that the library speaks to the controller in general, learning it from a working library for your controller in a different language. If controllers are similar, say, ST7789 vs ST7789V, theyll often speak the same fundamental language, and you might only need to change a few register values in the initialization sequence.\nInitialization sequence is a sequence of register writes that you have to send to your display before you can show any data on it, and it is often the key for fixing display problems. For instance, if you have a certain controller display and a library only supports that controller with a different resolution panel connected to it, what youd need to change is the bytes in initialization sequence responsible for controller-to-panel wiring mapping. Sometimes the resolution is the same, but the pixels are wired slightly differently, and that also fixable in the initialization sequence.\nThe initialization sequence is also where you can rotate or flip a display in hardware, in case your project needs the display to be in a certain non-default orientation  find a value to change, and the display will map the pixels in a different way. A single controller IC could work with a myriad, which is why, even if you find a datasheet for the display controller IC, it might not help you when you need to make your actual display work, because the controller datasheet might not have the exact initialization parameters you need to know.\nIf you cant find the proper initialization sequence or its hard to introspect the code, you can always sniff it with a logic analyzer! It can also help you figure out things like different commands to write pixels to the display  sending data to the display also has to be preceded by a certain command sequence, which has you give the display the address of the place you want to push the pixels into. Those commands are somewhat standardized by MIPI Alliance, so theres only a few common ones and they dont tend to change for the same display manufacturer, but its a good thing to keep in mind depending on how much you need to adapt your library.\nThis is about what you need to know when it comes to display software. Chances are, youll never have any problems on this front, but now you know where to look if you do. Lets descend to more earthly matters  wiring.\nA Little Wiring\nThe overwhelming majority of SPI and I2C displays expect 3.3 V VCC. Make sure to not reverse GND and VCC  if you do, your displays controller IC will die. Also, many display breakouts include a 3.3 V linear regulator on them, so that people can power them from 5 V too  its not exactly needed, but it can be nice to have. Other than that, for LCD panels, you will need to manage the backlight. You can typically hardwire it to VCC and GND  a resistor shouldnt be needed, as its usually included on the breakout PCB. If you want manual backlight control, an N-FET or an NPN transistor will make quick work of that if its low-side (GND-side) control, P-FET or PNP for high-side (VCC-side) control, and, of course, you can PWM it!\nSPI and I2C displays differ in their wiring. I2C displays rarely ever need anything other than SDA and SCL. Heres one exception though, and that is the RST signal, something that both I2C and SPI displays tend to need. Everywhere Ive seen it, its a non-negotiable signal  after the display gets powered up, you need to ground RST for a bit before you even dare to send data. If your display breakout has RST exposed and you ignore it, youre setting yourself up for a bad time.\nHowever, that doesnt mean you need to waste a GPIO on a signal that only changes once! As a rule, a simple resistor-capacitor circuit is sufficient to toggle the displays RST pin right after power-up, and many breakouts include this circuit by default, with an extra diode to make sure that even the quickest power dips still result in a display reset. The capacitor has to be in single-digit uF range, but thats not much of a problem to source, it doesnt have to have a super good temperature coefficient or high maximum voltage or anything. Here we go, thats one more spare GPIO for your project use!\nSPI displays also need CS, naturally. Some displays perma-ground CS and never expose it to the user, which takes the SPI bus hostage and is all-around annoying to work with. If you want to ground CS and not waste a GPIO on it, you always do it out of your own volition! Some displays wont like a perma-grounded CS, as they use the CS signal for internal purposes and expect you to switch it as you send data, but, for instance, typical SH1106 OLEDs sure dont seem to mind.\n\nAnother signal that exclusively SPI displays need is D/C, also known as A0. This signal tells the display whether youre currently sending data or commands to it  since displays operate in 8-bit mode and you have to use the whole 8 bits for your commands or data bytes, you need some sort of sideband to tell the display which one its receiving at any given moment. If you want to omit this pin, you can either send data to the display in 9-bit SPI mode instead of the default 8-bit mode, something that your MCU often wont support, or do a witty workaround! Oh, and for panels capable of both SPI and I2C mode, this signal might be used for the LSB of the I2C address when the panel is wired up for I2C mode, so that you can theoretically have two of the same displays on the same bus. If you need more than two of these displays, add more I2C buses, or use I2C address translators.\nA Little Hacking\nIf youre developing your own board, make sure youre using the right FFC pad pitch for the panel connector\nDisplay breakout boards are amazing and theyre what you will use in the majority of case  you can use them easily on your custom boards too, just put a 4-pin header on the board and plug a display breakout into it. However, breakouts shall not constrain you. If you want to build a smaller device, you can always put the bare panel on your board  you need the FPC footprint and mechanical considerations for the bare panel, but thats it. Make sure you really really have the correct pitch for the display FPC connector  lifting it from open-source KiCad projects is your best bet, and a datasheet for the panel (not the controller IC!) will help too. Its really annoying to produce a board that  print the board out on paper if you must.\nMany OLED displays want charge caps  find breakout schematics online and repeat them, and if you cant find schematics, re-draw the breakout you have and measure the caps with a capacitance meter. Some LCD panels require an external boost circuit, especially color OLEDs and some small TFTs  theres some open-source projects to learn from if you want to work with a panel that has such a requirement.\nWhen you need to unglue a display panel from its breakout for whatever purposes, reverse-engineering or repair alike, mind you that its typically glued to the PCB with double-sided tape. Use a hairdryer to heat up the tape from the PCB side (not the screen glass side!) and then use a plastic spudger to lift it equally from all sides, a credit card could work wonders too. Be very, very careful and measured while applying force, dont shatter the LCD/OLED glass, and dont tear the FPC! If youre working on one of the OLED screens that fold over a board, desoldering the FPC first might help  then you can rotate the panel, which should help free up the display from the tape a fair bit faster, just be careful gripping it. Isopropyl alcohol might be tempting to use, but beware  it might damage the polarizer layer on the panel, heat from a hairdryer is what Ive found works best. A hot air gun at soldering temps is likely to cause the SMD parts on the other side of the breakout to shift by accident, but if you dont have any to worry about, that could work in a pinch too!\nA lot of the common OLED and LCD displays have Linux kernel drivers! With the right modprobe command or a DeviceTree snippet, youll be surprised to see the Linux boot logs and then a `tty` prompt appear on your tiny screen. You cant quite send arbitrary commands or tweak the initialization sequence easily while using a Linux driver, but its all open-source, so theres some ways around it.\nThat about sums up what you should know about the most common type of display you can encounter. With the basic things out of the way, you should be able to get to whatever goal you need this display for, instead of spending time debugging common problems. The displays themselves are fascinating, too  just a few months ago, on Hackaday Discord, weve been watching someone abuse the SSD1306 controller OLED screens to create dithering and hardware-accelerated graphics! Whatever thing you might discover, now youre a few steps closer.\nNext time, lets peek into the kingdom of parallel RGB screens. Whenever you want a screen with high resolution and decent refresh rate, or simply a screen wider than 3, maybe you even want a touchscreen-enabled panel, parallel RGB is where its at.", "title": "\u300cI2C\u3068SPI\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306e\u9055\u3044\u3068\u7279\u5fb4\u300d", "body": "HD44780\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306b\u3064\u3044\u3066\u8a71\u3057\u3066\u304d\u307e\u3057\u305f\u304c\u3001I2C\u3068SPI\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306e\u591a\u69d8\u6027\u304c\u3042\u308a\u307e\u3059\u3002I2C\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306fGPIO\u3092\u307b\u3068\u3093\u3069\u5fc5\u8981\u3068\u305b\u305a\u3001\u5b89\u4fa1\u3067\u3042\u308a\u3001\u5c0f\u578b\u3067\u3059\u304c\u3001RAM\u3068\u9ad8\u5ea6\u306a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30e9\u30a4\u30d6\u30e9\u30ea\u304c\u5fc5\u8981\u3067\u3059\u3002SPI\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306f\u9ad8\u901f\u3067\u8272\u306e\u8868\u793a\u3082\u53ef\u80fd\u3067\u3059\u3002", "titles": ["\u300cI2C\u3068SPI\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306e\u9055\u3044\u3068\u7279\u5fb4\u300d", "\u300c\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u5236\u5fa1\u306e\u305f\u3081\u306e\u57fa\u672c\u7684\u306a\u8981\u4ef6\u300d", "\u300c\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306e\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u521d\u671f\u5316\u306e\u4ed5\u7d44\u307f\u300d", "\u300c\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306e\u914d\u7dda\u65b9\u6cd5\u3068\u6ce8\u610f\u70b9\u300d", "\u300c\u72ec\u81ea\u306e\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u57fa\u677f\u3092\u4f5c\u6210\u3059\u308b\u305f\u3081\u306e\u30d2\u30f3\u30c8\u3068\u6280\u5de7\u300d"]}