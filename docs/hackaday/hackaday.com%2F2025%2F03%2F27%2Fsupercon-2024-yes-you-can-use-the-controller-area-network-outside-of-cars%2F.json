{"pubDate": "2025-03-27T17:00:07", "original_title": "Supercon 2024: Yes, You Can Use the Controller Area Network Outside of Cars", "link": "https://hackaday.com/2025/03/27/supercon-2024-yes-you-can-use-the-controller-area-network-outside-of-cars/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2025/03/glenn_feat.png", "youtube": "https://www.youtube.com/watch?v=Uci5aiDWjFI", "original_content": "Ah, the CAN bus. Its become a communication standard in the automotive world, found in a huge swathe of cars built from the mid-1990s onwards. Youll also find it in aircraft, ships, and the vast majority of modern tractors and associated farm machines, too.\nAs far as [Randy Glenn] is concerned, though, the CAN bus doesnt have to be limited to these contexts. It can be useful far beyond its traditional applications with just about any hardware platform you care to use! He came down to tell us all about it at the 2024 Hackaday Supercon.\n\n\n[Randy]s talk was titled Yes, You CAN: Use The Controller Area Network Outside Of Cars. We have to assume the pun was intended. In any case, the CAN bus came to us from Bosch, which began developing the standard in 1983. The company officially released it at the Society of Automotive Engineers conference in 1986, with compatible chips first hitting the market a year later. It took a little while longer for the standard to find traction, with Mercedes-Benz being the first to implement it in a production vehicle in 1991. It soon caught on with the wider industry as a robust and reliable way to let a vehicles various control units communicate with all the important sensors that were proliferating on modern automobiles. CAN got its big break when it was mandated as part of the OBD-II standard in North America, which defacto put it into virtually every car sold in that market from 1996 onwards.\nSince then, CAN has proliferated well beyond the automotive space, into marine and aerospace contexts as well. As [Randy] explains, beyond transportation, youll also find it in everything from robots to pinball machines and even elevators. Basically, wherever its important to have robust local communication between distributed embedded systems, CAN is a great candidate for the job.\nSince its so widespread, its easy to find hardware and software thats CAN-ready out of the box. The vast majority of microcontroller manufacturers include some sort of CAN compatibility; for example, Espressifs ESP32 has the Two Wire Automotive Interface which is built for this purpose. Linux is more than happy to talk CAN, too, and most programming languages have some sort of library available, too. Whether youre working with Arduino, MicroPython, or CircuitPython, you can certainly find what you need. Even if you have a device without CAN built in\u2014like a Raspberry Pi\u2014SPI-ready CAN controllers can be had for cheap from vendors like Microchip.\nDepending on your hardware, you might have to add a CAN controller or transceiver to get it talking on the CAN bus. However, this is usually trivial.\nThere are specific reasons why you might consider CAN for your embedded communication needs. It uses a differential bus, which gives it an inherent ability to resist disruption from electrical noise. Addressing, error-checking, and retransmission functionality are also baked in to CAN controllers, so you dont have to handle it yourself. You can also find tons of CAN compatible hardware on the market to do whatever youre trying to do, and a lot of it is pretty cheap because manufacturers are churning it out by the millions.\nOf course, there are some limits. Traditionally, youre stuck with only 32 devices on a bus, though there are some\u00a0ways to work around it at lower data rates. Peak data rate is 1 megabit per second on a traditional CAN bus operating at the high data rate; this limits you to a total bus length of 25 meters. You can up this to 250 meters if you drop to 250 kbit/s instead. Packets are also limited to 8 bytes in size.\nBeyond the basic performance specs, [Randy] also explains how you might go about typical implementations with different hardware. For example, if youve got a microcontroller with no CAN capability baked in, you might hook it up with a CAN controller and transceiver over SPI. Alternatively, you might choose to work with a more advanced microcontroller that has all the CAN communication hardware built into the chip, simplifying your build. For parts like the ESP32 and some STM32s, you might find youve got a CAN controller on board, but youre lacking the hardware to do the fancy differential signalling\u2014in that case, you just need to hook up a CAN transceiver to get your hardware on the bus. [Randy] also highlights the usual conventions, such as terminology and wire colors, while explaining that these arent always rigidly adhered to in the field.\nTalking CAN on Linux is as easy as plugging in a cheap USB dongle.\nOn the communication level, the CAN bus standard mandates that nodes transmit frames, with each each frame containing up to 8 bytes of data. [Randy] explains how messages are formatted and addressed to ensure the right nodes get the right data theyre looking for. There are standard message frames, as well as Remote Transmission Request (RTR) frames\u2014where one node requests data from another. A typical example is a controller asking a sensor to report a value. There are also special Error and Control Frames, which [Randy] notes are complicated and beyond the scope of his Supercon talk. However, he recommends resources that exist to explain them in great detail.\nData of a complete CAN frame laid over the traces of the bus itself. Credit: Ken Tindell, Canis Automotive Labs Ltd. via CC BY-SA 4.0\nMuch of [Randys] talk explains how CAN works. But, as promised, he also takes the time to explain possible non-automotive applications for this technology. He steps through an amusing Halloween build, where a CAN bus is used to trigger scary lightning and sound effects when people press a doorbell.\nIf youve ever wanted a good CAN primer, [Randy]s talk is just what you need. As far as robust embedded communication standards go, its one of the most popular and long-lived out there. It might just pay dividends to put the CAN bus in your own toolbox for future use!"}