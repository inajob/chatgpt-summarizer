{"pubDate": "2023-11-21T18:00:14", "original_title": "How to Talk to Your Scope", "link": "https://hackaday.com/2023/11/21/how-to-talk-to-your-scope/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2023/11/Sine_wave_10_kHz_displayed_on_analog_oscilloscope_featured.png", "original_content": "It used to be only high-end test equipment that had some sort of remote control port. These days, though, they are quite common. Historically, test gear used IEEE-488 (also known as GPIB or, from the originator, HPIB). But today, your device will likely talk over a USB port, a serial port, or a LAN connection. Youd think that every instrument had unique quirks, and controlling it would be nothing like controlling another piece of gear, especially one from another company. That would be half right. Each vendor and even model indeed has its unique command language. There has been a significant effort to standardize some aspects of test instrument control, and you can quickly write code to control things on any platform using many different programming languages. In a few posts, I will show you just how easy it can be.\nThe key is to use VISA. This protocol is defined by the IVI Foundation that lets you talk to instruments regardless of how they communicate. You do have to build an address that tells the VISA library how to find your device. For example: TCPIP::192.168.1.92::INSTR. But once you have that, it is easy to talk to any instrument anywhere.\nI say that thinking it is a problem is half right because talking to the box is one task of the two you need to complete. The other is what to say to the box and what it will say back to you. There are a few standards in this area, but this is where you get into problems.\nRigol\nThe Rigol web interface is just a duplicate of the touchscreen\nWay back in 2015, I picked up a Rigol DS1052E and wanted to play with the remote control via USB. The resulting code (on GitHub) uses Qt and expects to open a USB port. The command language is simple and, helpfully, includes commands that simulate pressing keys on the front panel. I would find out that my latest Rigol scope, a DHO924S, doesnt provide those KEY commands nor does my DS1154z.\nSo, for a 2023 version, I wanted to abstract some of the complexity away to simplify a future switch between different scopes. I was watching a video review of a DHO900-series scope, and the reviewer complained that while the scope would show its screen via a web interface (and you can operate it via that virtual touchscreen), he missed having access to the knobs next to the screen when using the scope remotely. I realized it would be possible to write a small program to control the scope and provide the missing controls as a panel that could sit next to the scopes web interface.\nPython\nSince I also wanted to use this in scripts and I was freshly off the Hackaday Supercon badge, which used MicroPython, I decided to do this all in Python. My general plan of attack was simple:\n\nUse VISA to connect to the scope\nAbstract the direct SCPI commands using Python methods or properties in a class that represents the scope\nCreate a GUI to use adjacent to the web interface\n\nThis post is about the first two items. Ill cover the GUI next time. However, I didnt totally wrap the entire SCPI command set in the Python class. Instead, I just provided what I needed for the task at hand. As youll see, it is easy to add whatever you like.\nPyVisa\nThe first order of business was to install PyVisa. This sounds like it would be all you need, but it isnt. Instead, it is a wrapper around a real VISA backend. Two popular choices are NI-VISA from National Instruments (free, although you probably have to register) or the open-source pyvisa-py. Try this:\npip3 install pyvisa pyvisa-py\nNote that, as of now, pyvisa-py supports TCP/IP, GPIB, USB, and serial. That covers most bases, but if you need something different, you may have to try a different backend.\nWhen you install pyvisa, it should leave a binary (in ~/.local/bin for me) called pyvisa-info. Run that, and it will tell you if it finds backends and will also tell you other things you might need to install. For example, I have no GPIB bus instruments and didnt install that driver, so it warns me that I should install it if I want to talk to GPIB devices. I dont, so Im good. If you get bad error messages from pyvisa-info, you should fix them before you try to go further.\nWhile SCPI defines some commands, mostly it is hit-and-miss. For example, a Tektronix scope might use CURVe? to get waveform data, while a Rigol might use WAV:DATA? , and other brands might only need DATA?. There are a few things you can usually count on, though.\nWhen you see a question mark (like :WAV:DATA?) you are expecting the scope (or whatever it is) to answer you. When you dont see a question mark, you are just sending data. In addition, when you see something like CURVe? written down, that means you are allowed to omit the e which saves a little time and communication bandwidth. So CURV? and CURVE? are the same thing.\nUsing PyVISA\nTo open a connection to a scope in Python, you will first need to import pyvisa. After that, youll create a resource manager and pass it a special open string. Heres an excerpt from my scope abstraction class (find everything on GitHub):\n\n# do the connect\ndef connect(self,usb,cxstring):\n   if usb==0:\n      cxstr=TCPIP::+cxstring+::INSTR\n   else:\n      cxstr=USB0::0x1AB1::0x044C::+cxstring+::INSTR\n   self.visa=pyvisa.ResourceManager('@py')\n   self.scope=self.visa.open_resource(cxstr)\n   self.connected=True\n\nIn this case, Im using a known scope, so I assume the USB IDs will be the same. If you are using a different instrument, this will change. Helpfully, if you open the Rigols web interface, youll find both connect strings written down for you to copy.\nThe information screen shows connection strings for USB and TCP/IP\nThe connect member function takes just the IP address or scope name and fills in the rest. The usb flag determines if it treats the input as an IP address or a name. The resource manager argument tells the library which backend to use. In this case, Im using pyvisa-py (@py). If you omit the @py string, the library will use the IVI library which will work with backends like NI-VISA and other vendor-specific libraries. If it cant find an IVI library it will fall back to using pyvisa-py. You can also pass a full path name to the library you want to use. If you prefer, you can set the PYVISA_LIBRARY environment variable instead. There is also a .pyvisarc file you can use for configuration.\nMay I See Some ID?\nNearly every instrument supports the query *IDN? to return an identification string. The code defines two methods to send data to the instrument. The write method sends data with no return. The query method gets a return and chops off the trailing new line:\n\n# send a query and return a response\ndef query(self,string):\n   s=self.scope.query(string)\n   if isinstance(s,str):\n      return s[0:len(s)-1]\n   else:\n      return s\n\n# just send\ndef write(self,string):\n   return self.scope.write(string)\n\n# get ID\ndef id(self):\n   return self.query(*IDN?)\n\nOnce you have that, the rest is just writing little wrapper functions. The only real problem is that the scope doesnt offer  that I could find  any way to simulate a front panel key. However, some of the front panel keys behave differently depending on other modes. For example, each click of a knob might represent a different value when the scope is set on a slow sweep vs a fast sweep. Or, for another example, the trigger level knob doesnt have a corresponding SCPI command. Instead, you must set the level for the specific trigger you want to use. That means you must know what triggering mode is set since each one uses a different command to set the level.\nIf you are writing a script, this isnt a big problem because you can just set the triggering mode to a known value before you set the level correctly. But for a user interface, it is a problem because you have to write code to emulate the scopes behavior. Or you can simply do what I did. Make a reasonable assumption and live with it.\nThe Result So Far\nJust as a test, I wrote a little script at the bottom of rigol_scope.py to connect to a fixed IP address (since this is just a test) and put the scope in single mode every 10 seconds.\n\nif __name__==__main__:\n   import time\n# test script\n   scope=Scope()\n   scope.connect(0,192.168.1.92)\n   while True:\n      print(here we go again...)\n      scope.single()\n      time.sleep(10)\n      print(scope.trig_status())\n\nThe next step is a GUI, but that will wait until next time. However, writing the code as a class like this has at least three advantages:\n\nIt would be easy to support multiple scopes; just instantiate more objects\nIt is also easy to provide the same abstracted interface to a different scope\nYou can use the object in other scripts or programs without having to carry along GUI code\n\nBesides that, you could even support multiple GUIs with the same object. Anything you enhance or fix in the scope object benefits all the programs.\nThis isnt the first time weve looked at PyVISA. Or, for that matter, SCPI.\nFeatured image: The delightfully named Sine wave 10 kHz displayed on analog oscilloscope by [Pittigrilli]."}