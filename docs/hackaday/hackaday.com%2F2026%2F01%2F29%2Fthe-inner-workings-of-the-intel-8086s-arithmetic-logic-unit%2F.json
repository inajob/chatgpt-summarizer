{"pubDate": "2026-01-29T19:30:39", "original_title": "The Inner Workings of the Intel 8086\u2019s Arithmetic Logic Unit", "link": "https://hackaday.com/2026/01/29/the-inner-workings-of-the-intel-8086s-arithmetic-logic-unit/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2026/01/8086alu_feat.png", "original_content": "In the 1970s CPUs still had wildly different approaches to basic features, with the Intel 8086 being one of them. Whereas the 6502 used separate circuits for operations, and the Intel 8085 a clump of reconfigurable gates, the 8086 uses microcode that configures the ALU along with two lookup tables. This complexity is one of the reasons why the Intel 8086 is so unique, with [Ken Shirriff] taking an in-depth look at its workings on a functional and die-level.\n\nThese lookup tables are used for the ALU configuration  as in the above schematic  making for a very flexible but also complex system, where the same microcode can be used by multiple instructions. This is effectively the very definition of a CISC-style processor, a legacy that the x86 ISA would carry with it even if the x86 CPUs today are internally more RISC-like. Decoding a single instruction and having it cascade into any of a variety of microcodes and control signals is very powerful, but comes with many trade-offs.\nOf course, as semiconductor technology improved, along with design technologies, many of these trade-offs and disadvantages became less relevant. [Ken] also raises the interesting point that much of this ALU control technology is similar to that used in modern-day FPGAs, with their own reconfigurable logic using LUTs that allow for on-the-fly reconfiguration.", "title": "\u30a4\u30f3\u30c6\u30eb8086: \u8907\u96d1\u3055\u304c\u751f\u3080\u30e6\u30cb\u30fc\u30af\u306a\u8a2d\u8a08", "body": "1970\u5e74\u4ee3\u306eCPU\u306f\u591a\u69d8\u306a\u8a2d\u8a08\u304c\u3042\u308a\u3001Intel 8086\u306f\u30de\u30a4\u30af\u30ed\u30b3\u30fc\u30c9\u3092\u4f7f\u7528\u3002\u67d4\u8edf\u6027\u304c\u3042\u308b\u304c\u8907\u96d1\u306aCISC\u30d7\u30ed\u30bb\u30c3\u30b5\u306e\u5178\u578b\u3002", "titles": ["\u30a4\u30f3\u30c6\u30eb8086: \u8907\u96d1\u3055\u304c\u751f\u3080\u30e6\u30cb\u30fc\u30af\u306a\u8a2d\u8a08", "CISC\u30d7\u30ed\u30bb\u30c3\u30b5\u306e\u5b9a\u7fa9: \u30a4\u30f3\u30c6\u30eb8086\u306e\u30de\u30a4\u30af\u30ed\u30b3\u30fc\u30c9", "ALU\u5236\u5fa1\u6280\u8853\u306e\u9032\u5316: 8086\u3068\u73fe\u4ee3\u306eFPGA\u306e\u6bd4\u8f03", "1970\u5e74\u4ee3\u306eCPU\u30a2\u30d7\u30ed\u30fc\u30c1: 8086\u306e\u7279\u6b8a\u6027\u3068\u5229\u70b9", "\u8a2d\u8a08\u6280\u8853\u306e\u9032\u5316: 8086\u306e\u30c8\u30ec\u30fc\u30c9\u30aa\u30d5\u3068\u305d\u306e\u5f71\u97ff"]}