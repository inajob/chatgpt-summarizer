{"pubDate": "2024-03-29T02:00:46", "original_title": "Is Your Mental Model of Bash Pipelines Wrong?", "link": "https://hackaday.com/2024/03/28/is-your-mental-model-of-bash-pipelines-wrong/", "source": "https://hackaday.com/blog/feed/", "thumbnail": "https://hackaday.com/wp-content/uploads/2020/05/LinuxFu.jpg", "original_content": "[Michael Lynch] encountered a strange situation. Why was compiling then running his program nearly 10x faster than just running the program by itself? [Michael] ran into this issue while benchmarking a programming project, pared it down to its essentials for repeatability and analysis, and discovered it highlighted an incorrect mental model of how bash pipelines worked.\nHeres the situation. The first thing [Michael]s pared-down program does is start a timer. Then it simply reads and counts some bytes from stdin, then prints out how long it took for that to happen. When running the test program in the following way, it takes about 13 microseconds.\n$ echo 00010203040506070809 | xxd -r -p | zig build run -Doptimize=ReleaseFast\nbytes: 10\nexecution time: 13.549\u00b5s\nWhen running the (already-compiled) program directly, execution time swells to 162 microseconds.\n$ echo 00010203040506070809 | xxd -r -p | ./zig-out/bin/count-bytes\nbytes: 10\nexecution time: 162.195\u00b5s\nAgain, the only difference between zig build run and ./zig-out/bin/count-bytes is that the first compiles the code, then immediately runs it. The second simply runs the compiled program.\nHow can adding an extra compile step decrease the execution time? Turns out that [Michael]s mental model of how bash pipelines work was incorrect, and he does a great job of explaining how they actually work, and why that caused the strange behavior he was seeing.\nIn short, commands in a bash pipeline are not launched sequentially. They are all launched at the same time and execute in parallel. That meant that when run directly, [Michael]s byte-counter program launched immediately. Then it waited around doing nothing much for about 150 microseconds while the echo '00010203040506070809' | xxd -r -p part of the pipeline got around to delivering its data for the program to read. This is where the extra execution time comes from when running the already-compiled version.\nSo why is compiling it first running faster? Same basic reason: when the zig build run command kicks off, it spends a little time compiling the program first. Then when the compiled program is actually launched (and begins its execution timer), the input data from the bash pipeline is already ready. So, the freshly-compiled program executes in less time because it doesnt sit around waiting for data from earlier in the pipeline to become available.\nIts an interesting look at how bash pipelines actually function under the hood, and were delighted with the detail [Micheal] puts into the whole journey and explanation. Sooner or later, details like this crop up and cause some eyebrows to raise, like the user who discovered troublesome edge cases regarding spaces in ssh commands."}